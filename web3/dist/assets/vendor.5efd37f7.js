var Zy = Object.defineProperty,
    Qy = Object.defineProperties
var e2 = Object.getOwnPropertyDescriptors
var dh = Object.getOwnPropertySymbols
var t2 = Object.prototype.hasOwnProperty,
    r2 = Object.prototype.propertyIsEnumerable
var hh = (t, e, r) => (e in t ? Zy(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (t[e] = r)),
    Fe = (t, e) => {
        for (var r in e || (e = {})) t2.call(e, r) && hh(t, r, e[r])
        if (dh) for (var r of dh(e)) r2.call(e, r) && hh(t, r, e[r])
        return t
    },
    El = (t, e) => Qy(t, e2(e))
function Dd(t, e) {
    const r = Object.create(null),
        n = t.split(",")
    for (let i = 0; i < n.length; i++) r[n[i]] = !0
    return e ? (i) => !!r[i.toLowerCase()] : (i) => !!r[i]
}
const n2 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    i2 = Dd(n2)
function $m(t) {
    return !!t || t === ""
}
function ni(t) {
    if ($e(t)) {
        const e = {}
        for (let r = 0; r < t.length; r++) {
            const n = t[r],
                i = Ht(n) ? a2(n) : ni(n)
            if (i) for (const s in i) e[s] = i[s]
        }
        return e
    } else {
        if (Ht(t)) return t
        if (Gt(t)) return t
    }
}
const s2 = /;(?![^(]*\))/g,
    o2 = /:(.+)/
function a2(t) {
    const e = {}
    return (
        t.split(s2).forEach((r) => {
            if (r) {
                const n = r.split(o2)
                n.length > 1 && (e[n[0].trim()] = n[1].trim())
            }
        }),
        e
    )
}
function ye(t) {
    let e = ""
    if (Ht(t)) e = t
    else if ($e(t))
        for (let r = 0; r < t.length; r++) {
            const n = ye(t[r])
            n && (e += n + " ")
        }
    else if (Gt(t)) for (const r in t) t[r] && (e += r + " ")
    return e.trim()
}
function l2(t) {
    if (!t) return null
    let { class: e, style: r } = t
    return e && !Ht(e) && (t.class = ye(e)), r && (t.style = ni(r)), t
}
const tt = (t) =>
        Ht(t) ? t : t == null ? "" : $e(t) || (Gt(t) && (t.toString === Mm || !Re(t.toString))) ? JSON.stringify(t, Bm, 2) : String(t),
    Bm = (t, e) =>
        e && e.__v_isRef
            ? Bm(t, e.value)
            : go(e)
            ? { [`Map(${e.size})`]: [...e.entries()].reduce((r, [n, i]) => ((r[`${n} =>`] = i), r), {}) }
            : Om(e)
            ? { [`Set(${e.size})`]: [...e.values()] }
            : Gt(e) && !$e(e) && !Rm(e)
            ? String(e)
            : e,
    lt = {},
    po = [],
    on = () => {},
    c2 = () => !1,
    f2 = /^on[^a-z]/,
    Rc = (t) => f2.test(t),
    Fd = (t) => t.startsWith("onUpdate:"),
    or = Object.assign,
    Vd = (t, e) => {
        const r = t.indexOf(e)
        r > -1 && t.splice(r, 1)
    },
    u2 = Object.prototype.hasOwnProperty,
    Ye = (t, e) => u2.call(t, e),
    $e = Array.isArray,
    go = (t) => Lc(t) === "[object Map]",
    Om = (t) => Lc(t) === "[object Set]",
    Re = (t) => typeof t == "function",
    Ht = (t) => typeof t == "string",
    Ud = (t) => typeof t == "symbol",
    Gt = (t) => t !== null && typeof t == "object",
    Hd = (t) => Gt(t) && Re(t.then) && Re(t.catch),
    Mm = Object.prototype.toString,
    Lc = (t) => Mm.call(t),
    d2 = (t) => Lc(t).slice(8, -1),
    Rm = (t) => Lc(t) === "[object Object]",
    qd = (t) => Ht(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
    Jl = Dd(
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    ),
    Dc = (t) => {
        const e = Object.create(null)
        return (r) => e[r] || (e[r] = t(r))
    },
    h2 = /-(\w)/g,
    Rn = Dc((t) => t.replace(h2, (e, r) => (r ? r.toUpperCase() : ""))),
    p2 = /\B([A-Z])/g,
    Fo = Dc((t) => t.replace(p2, "-$1").toLowerCase()),
    Fc = Dc((t) => t.charAt(0).toUpperCase() + t.slice(1)),
    Hf = Dc((t) => (t ? `on${Fc(t)}` : "")),
    Ra = (t, e) => !Object.is(t, e),
    qf = (t, e) => {
        for (let r = 0; r < t.length; r++) t[r](e)
    },
    hc = (t, e, r) => {
        Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value: r })
    },
    jd = (t) => {
        const e = parseFloat(t)
        return isNaN(e) ? t : e
    }
let ph
const g2 = () =>
    ph ||
    (ph =
        typeof globalThis != "undefined"
            ? globalThis
            : typeof self != "undefined"
            ? self
            : typeof window != "undefined"
            ? window
            : typeof global != "undefined"
            ? global
            : {})
let Gn
class m2 {
    constructor(e = !1) {
        ;(this.active = !0),
            (this.effects = []),
            (this.cleanups = []),
            !e && Gn && ((this.parent = Gn), (this.index = (Gn.scopes || (Gn.scopes = [])).push(this) - 1))
    }
    run(e) {
        if (this.active)
            try {
                return (Gn = this), e()
            } finally {
                Gn = this.parent
            }
    }
    on() {
        Gn = this
    }
    off() {
        Gn = this.parent
    }
    stop(e) {
        if (this.active) {
            let r, n
            for (r = 0, n = this.effects.length; r < n; r++) this.effects[r].stop()
            for (r = 0, n = this.cleanups.length; r < n; r++) this.cleanups[r]()
            if (this.scopes) for (r = 0, n = this.scopes.length; r < n; r++) this.scopes[r].stop(!0)
            if (this.parent && !e) {
                const i = this.parent.scopes.pop()
                i && i !== this && ((this.parent.scopes[this.index] = i), (i.index = this.index))
            }
            this.active = !1
        }
    }
}
function b2(t, e = Gn) {
    e && e.active && e.effects.push(t)
}
const zd = (t) => {
        const e = new Set(t)
        return (e.w = 0), (e.n = 0), e
    },
    Lm = (t) => (t.w & Vi) > 0,
    Dm = (t) => (t.n & Vi) > 0,
    x2 = ({ deps: t }) => {
        if (t.length) for (let e = 0; e < t.length; e++) t[e].w |= Vi
    },
    v2 = (t) => {
        const { deps: e } = t
        if (e.length) {
            let r = 0
            for (let n = 0; n < e.length; n++) {
                const i = e[n]
                Lm(i) && !Dm(i) ? i.delete(t) : (e[r++] = i), (i.w &= ~Vi), (i.n &= ~Vi)
            }
            e.length = r
        }
    },
    Mu = new WeakMap()
let pa = 0,
    Vi = 1
const Ru = 30
let wn
const Cs = Symbol(""),
    Lu = Symbol("")
class Kd {
    constructor(e, r = null, n) {
        ;(this.fn = e), (this.scheduler = r), (this.active = !0), (this.deps = []), (this.parent = void 0), b2(this, n)
    }
    run() {
        if (!this.active) return this.fn()
        let e = wn,
            r = Oi
        for (; e; ) {
            if (e === this) return
            e = e.parent
        }
        try {
            return (this.parent = wn), (wn = this), (Oi = !0), (Vi = 1 << ++pa), pa <= Ru ? x2(this) : gh(this), this.fn()
        } finally {
            pa <= Ru && v2(this), (Vi = 1 << --pa), (wn = this.parent), (Oi = r), (this.parent = void 0)
        }
    }
    stop() {
        this.active && (gh(this), this.onStop && this.onStop(), (this.active = !1))
    }
}
function gh(t) {
    const { deps: e } = t
    if (e.length) {
        for (let r = 0; r < e.length; r++) e[r].delete(t)
        e.length = 0
    }
}
let Oi = !0
const Fm = []
function Vo() {
    Fm.push(Oi), (Oi = !1)
}
function Uo() {
    const t = Fm.pop()
    Oi = t === void 0 ? !0 : t
}
function Mr(t, e, r) {
    if (Oi && wn) {
        let n = Mu.get(t)
        n || Mu.set(t, (n = new Map()))
        let i = n.get(r)
        i || n.set(r, (i = zd())), Vm(i)
    }
}
function Vm(t, e) {
    let r = !1
    pa <= Ru ? Dm(t) || ((t.n |= Vi), (r = !Lm(t))) : (r = !t.has(wn)), r && (t.add(wn), wn.deps.push(t))
}
function ii(t, e, r, n, i, s) {
    const o = Mu.get(t)
    if (!o) return
    let a = []
    if (e === "clear") a = [...o.values()]
    else if (r === "length" && $e(t))
        o.forEach((l, c) => {
            ;(c === "length" || c >= n) && a.push(l)
        })
    else
        switch ((r !== void 0 && a.push(o.get(r)), e)) {
            case "add":
                $e(t) ? qd(r) && a.push(o.get("length")) : (a.push(o.get(Cs)), go(t) && a.push(o.get(Lu)))
                break
            case "delete":
                $e(t) || (a.push(o.get(Cs)), go(t) && a.push(o.get(Lu)))
                break
            case "set":
                go(t) && a.push(o.get(Cs))
                break
        }
    if (a.length === 1) a[0] && Du(a[0])
    else {
        const l = []
        for (const c of a) c && l.push(...c)
        Du(zd(l))
    }
}
function Du(t, e) {
    for (const r of $e(t) ? t : [...t]) (r !== wn || r.allowRecurse) && (r.scheduler ? r.scheduler() : r.run())
}
const y2 = Dd("__proto__,__v_isRef,__isVue"),
    Um = new Set(
        Object.getOwnPropertyNames(Symbol)
            .map((t) => Symbol[t])
            .filter(Ud)
    ),
    _2 = Gd(),
    w2 = Gd(!1, !0),
    E2 = Gd(!0),
    mh = S2()
function S2() {
    const t = {}
    return (
        ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
            t[e] = function (...r) {
                const n = et(this)
                for (let s = 0, o = this.length; s < o; s++) Mr(n, "get", s + "")
                const i = n[e](...r)
                return i === -1 || i === !1 ? n[e](...r.map(et)) : i
            }
        }),
        ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
            t[e] = function (...r) {
                Vo()
                const n = et(this)[e].apply(this, r)
                return Uo(), n
            }
        }),
        t
    )
}
function Gd(t = !1, e = !1) {
    return function (n, i, s) {
        if (i === "__v_isReactive") return !t
        if (i === "__v_isReadonly") return t
        if (i === "__v_isShallow") return e
        if (i === "__v_raw" && s === (t ? (e ? V2 : Km) : e ? zm : jm).get(n)) return n
        const o = $e(n)
        if (!t && o && Ye(mh, i)) return Reflect.get(mh, i, s)
        const a = Reflect.get(n, i, s)
        return (Ud(i) ? Um.has(i) : y2(i)) || (t || Mr(n, "get", i), e)
            ? a
            : nr(a)
            ? !o || !qd(i)
                ? a.value
                : a
            : Gt(a)
            ? t
                ? Gm(a)
                : Ln(a)
            : a
    }
}
const A2 = Hm(),
    T2 = Hm(!0)
function Hm(t = !1) {
    return function (r, n, i, s) {
        let o = r[n]
        if (La(o) && nr(o) && !nr(i)) return !1
        if (!t && !La(i) && (Wm(i) || ((i = et(i)), (o = et(o))), !$e(r) && nr(o) && !nr(i))) return (o.value = i), !0
        const a = $e(r) && qd(n) ? Number(n) < r.length : Ye(r, n),
            l = Reflect.set(r, n, i, s)
        return r === et(s) && (a ? Ra(i, o) && ii(r, "set", n, i) : ii(r, "add", n, i)), l
    }
}
function C2(t, e) {
    const r = Ye(t, e)
    t[e]
    const n = Reflect.deleteProperty(t, e)
    return n && r && ii(t, "delete", e, void 0), n
}
function k2(t, e) {
    const r = Reflect.has(t, e)
    return (!Ud(e) || !Um.has(e)) && Mr(t, "has", e), r
}
function N2(t) {
    return Mr(t, "iterate", $e(t) ? "length" : Cs), Reflect.ownKeys(t)
}
const qm = { get: _2, set: A2, deleteProperty: C2, has: k2, ownKeys: N2 },
    P2 = {
        get: E2,
        set(t, e) {
            return !0
        },
        deleteProperty(t, e) {
            return !0
        },
    },
    I2 = or({}, qm, { get: w2, set: T2 }),
    Wd = (t) => t,
    Vc = (t) => Reflect.getPrototypeOf(t)
function Sl(t, e, r = !1, n = !1) {
    t = t.__v_raw
    const i = et(t),
        s = et(e)
    e !== s && !r && Mr(i, "get", e), !r && Mr(i, "get", s)
    const { has: o } = Vc(i),
        a = n ? Wd : r ? Yd : Da
    if (o.call(i, e)) return a(t.get(e))
    if (o.call(i, s)) return a(t.get(s))
    t !== i && t.get(e)
}
function Al(t, e = !1) {
    const r = this.__v_raw,
        n = et(r),
        i = et(t)
    return t !== i && !e && Mr(n, "has", t), !e && Mr(n, "has", i), t === i ? r.has(t) : r.has(t) || r.has(i)
}
function Tl(t, e = !1) {
    return (t = t.__v_raw), !e && Mr(et(t), "iterate", Cs), Reflect.get(t, "size", t)
}
function bh(t) {
    t = et(t)
    const e = et(this)
    return Vc(e).has.call(e, t) || (e.add(t), ii(e, "add", t, t)), this
}
function xh(t, e) {
    e = et(e)
    const r = et(this),
        { has: n, get: i } = Vc(r)
    let s = n.call(r, t)
    s || ((t = et(t)), (s = n.call(r, t)))
    const o = i.call(r, t)
    return r.set(t, e), s ? Ra(e, o) && ii(r, "set", t, e) : ii(r, "add", t, e), this
}
function vh(t) {
    const e = et(this),
        { has: r, get: n } = Vc(e)
    let i = r.call(e, t)
    i || ((t = et(t)), (i = r.call(e, t))), n && n.call(e, t)
    const s = e.delete(t)
    return i && ii(e, "delete", t, void 0), s
}
function yh() {
    const t = et(this),
        e = t.size !== 0,
        r = t.clear()
    return e && ii(t, "clear", void 0, void 0), r
}
function Cl(t, e) {
    return function (n, i) {
        const s = this,
            o = s.__v_raw,
            a = et(o),
            l = e ? Wd : t ? Yd : Da
        return !t && Mr(a, "iterate", Cs), o.forEach((c, f) => n.call(i, l(c), l(f), s))
    }
}
function kl(t, e, r) {
    return function (...n) {
        const i = this.__v_raw,
            s = et(i),
            o = go(s),
            a = t === "entries" || (t === Symbol.iterator && o),
            l = t === "keys" && o,
            c = i[t](...n),
            f = r ? Wd : e ? Yd : Da
        return (
            !e && Mr(s, "iterate", l ? Lu : Cs),
            {
                next() {
                    const { value: u, done: p } = c.next()
                    return p ? { value: u, done: p } : { value: a ? [f(u[0]), f(u[1])] : f(u), done: p }
                },
                [Symbol.iterator]() {
                    return this
                },
            }
        )
    }
}
function yi(t) {
    return function (...e) {
        return t === "delete" ? !1 : this
    }
}
function $2() {
    const t = {
            get(s) {
                return Sl(this, s)
            },
            get size() {
                return Tl(this)
            },
            has: Al,
            add: bh,
            set: xh,
            delete: vh,
            clear: yh,
            forEach: Cl(!1, !1),
        },
        e = {
            get(s) {
                return Sl(this, s, !1, !0)
            },
            get size() {
                return Tl(this)
            },
            has: Al,
            add: bh,
            set: xh,
            delete: vh,
            clear: yh,
            forEach: Cl(!1, !0),
        },
        r = {
            get(s) {
                return Sl(this, s, !0)
            },
            get size() {
                return Tl(this, !0)
            },
            has(s) {
                return Al.call(this, s, !0)
            },
            add: yi("add"),
            set: yi("set"),
            delete: yi("delete"),
            clear: yi("clear"),
            forEach: Cl(!0, !1),
        },
        n = {
            get(s) {
                return Sl(this, s, !0, !0)
            },
            get size() {
                return Tl(this, !0)
            },
            has(s) {
                return Al.call(this, s, !0)
            },
            add: yi("add"),
            set: yi("set"),
            delete: yi("delete"),
            clear: yi("clear"),
            forEach: Cl(!0, !0),
        }
    return (
        ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
            ;(t[s] = kl(s, !1, !1)), (r[s] = kl(s, !0, !1)), (e[s] = kl(s, !1, !0)), (n[s] = kl(s, !0, !0))
        }),
        [t, r, e, n]
    )
}
const [B2, O2, M2, R2] = $2()
function Jd(t, e) {
    const r = e ? (t ? R2 : M2) : t ? O2 : B2
    return (n, i, s) =>
        i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? n : Reflect.get(Ye(r, i) && i in n ? r : n, i, s)
}
const L2 = { get: Jd(!1, !1) },
    D2 = { get: Jd(!1, !0) },
    F2 = { get: Jd(!0, !1) },
    jm = new WeakMap(),
    zm = new WeakMap(),
    Km = new WeakMap(),
    V2 = new WeakMap()
function U2(t) {
    switch (t) {
        case "Object":
        case "Array":
            return 1
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2
        default:
            return 0
    }
}
function H2(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : U2(d2(t))
}
function Ln(t) {
    return La(t) ? t : Xd(t, !1, qm, L2, jm)
}
function q2(t) {
    return Xd(t, !1, I2, D2, zm)
}
function Gm(t) {
    return Xd(t, !0, P2, F2, Km)
}
function Xd(t, e, r, n, i) {
    if (!Gt(t) || (t.__v_raw && !(e && t.__v_isReactive))) return t
    const s = i.get(t)
    if (s) return s
    const o = H2(t)
    if (o === 0) return t
    const a = new Proxy(t, o === 2 ? n : r)
    return i.set(t, a), a
}
function ks(t) {
    return La(t) ? ks(t.__v_raw) : !!(t && t.__v_isReactive)
}
function La(t) {
    return !!(t && t.__v_isReadonly)
}
function Wm(t) {
    return !!(t && t.__v_isShallow)
}
function Jm(t) {
    return ks(t) || La(t)
}
function et(t) {
    const e = t && t.__v_raw
    return e ? et(e) : t
}
function Xm(t) {
    return hc(t, "__v_skip", !0), t
}
const Da = (t) => (Gt(t) ? Ln(t) : t),
    Yd = (t) => (Gt(t) ? Gm(t) : t)
function Ym(t) {
    Oi && wn && ((t = et(t)), Vm(t.dep || (t.dep = zd())))
}
function Zm(t, e) {
    ;(t = et(t)), t.dep && Du(t.dep)
}
function nr(t) {
    return !!(t && t.__v_isRef === !0)
}
function Ue(t) {
    return Qm(t, !1)
}
function j2(t) {
    return Qm(t, !0)
}
function Qm(t, e) {
    return nr(t) ? t : new z2(t, e)
}
class z2 {
    constructor(e, r) {
        ;(this.__v_isShallow = r), (this.dep = void 0), (this.__v_isRef = !0), (this._rawValue = r ? e : et(e)), (this._value = r ? e : Da(e))
    }
    get value() {
        return Ym(this), this._value
    }
    set value(e) {
        ;(e = this.__v_isShallow ? e : et(e)),
            Ra(e, this._rawValue) && ((this._rawValue = e), (this._value = this.__v_isShallow ? e : Da(e)), Zm(this))
    }
}
function ya(t) {
    return nr(t) ? t.value : t
}
const K2 = {
    get: (t, e, r) => ya(Reflect.get(t, e, r)),
    set: (t, e, r, n) => {
        const i = t[e]
        return nr(i) && !nr(r) ? ((i.value = r), !0) : Reflect.set(t, e, r, n)
    },
}
function eb(t) {
    return ks(t) ? t : new Proxy(t, K2)
}
class G2 {
    constructor(e, r, n, i) {
        ;(this._setter = r),
            (this.dep = void 0),
            (this.__v_isRef = !0),
            (this._dirty = !0),
            (this.effect = new Kd(e, () => {
                this._dirty || ((this._dirty = !0), Zm(this))
            })),
            (this.effect.computed = this),
            (this.effect.active = this._cacheable = !i),
            (this.__v_isReadonly = n)
    }
    get value() {
        const e = et(this)
        return Ym(e), (e._dirty || !e._cacheable) && ((e._dirty = !1), (e._value = e.effect.run())), e._value
    }
    set value(e) {
        this._setter(e)
    }
}
function W2(t, e, r = !1) {
    let n, i
    const s = Re(t)
    return s ? ((n = t), (i = on)) : ((n = t.get), (i = t.set)), new G2(n, i, s || !i, r)
}
Promise.resolve()
function Mi(t, e, r, n) {
    let i
    try {
        i = n ? t(...n) : t()
    } catch (s) {
        sl(s, e, r)
    }
    return i
}
function jr(t, e, r, n) {
    if (Re(t)) {
        const s = Mi(t, e, r, n)
        return (
            s &&
                Hd(s) &&
                s.catch((o) => {
                    sl(o, e, r)
                }),
            s
        )
    }
    const i = []
    for (let s = 0; s < t.length; s++) i.push(jr(t[s], e, r, n))
    return i
}
function sl(t, e, r, n = !0) {
    const i = e ? e.vnode : null
    if (e) {
        let s = e.parent
        const o = e.proxy,
            a = r
        for (; s; ) {
            const c = s.ec
            if (c) {
                for (let f = 0; f < c.length; f++) if (c[f](t, o, a) === !1) return
            }
            s = s.parent
        }
        const l = e.appContext.config.errorHandler
        if (l) {
            Mi(l, null, 10, [t, o, a])
            return
        }
    }
    J2(t, r, i, n)
}
function J2(t, e, r, n = !0) {
    console.error(t)
}
let pc = !1,
    Fu = !1
const Pr = []
let Xn = 0
const _a = []
let ga = null,
    to = 0
const wa = []
let Ci = null,
    ro = 0
const tb = Promise.resolve()
let Zd = null,
    Vu = null
function kn(t) {
    const e = Zd || tb
    return t ? e.then(this ? t.bind(this) : t) : e
}
function X2(t) {
    let e = Xn + 1,
        r = Pr.length
    for (; e < r; ) {
        const n = (e + r) >>> 1
        Fa(Pr[n]) < t ? (e = n + 1) : (r = n)
    }
    return e
}
function rb(t) {
    ;(!Pr.length || !Pr.includes(t, pc && t.allowRecurse ? Xn + 1 : Xn)) &&
        t !== Vu &&
        (t.id == null ? Pr.push(t) : Pr.splice(X2(t.id), 0, t), nb())
}
function nb() {
    !pc && !Fu && ((Fu = !0), (Zd = tb.then(ab)))
}
function Y2(t) {
    const e = Pr.indexOf(t)
    e > Xn && Pr.splice(e, 1)
}
function ib(t, e, r, n) {
    $e(t) ? r.push(...t) : (!e || !e.includes(t, t.allowRecurse ? n + 1 : n)) && r.push(t), nb()
}
function Z2(t) {
    ib(t, ga, _a, to)
}
function sb(t) {
    ib(t, Ci, wa, ro)
}
function Qd(t, e = null) {
    if (_a.length) {
        for (Vu = e, ga = [...new Set(_a)], _a.length = 0, to = 0; to < ga.length; to++) ga[to]()
        ;(ga = null), (to = 0), (Vu = null), Qd(t, e)
    }
}
function ob(t) {
    if (wa.length) {
        const e = [...new Set(wa)]
        if (((wa.length = 0), Ci)) {
            Ci.push(...e)
            return
        }
        for (Ci = e, Ci.sort((r, n) => Fa(r) - Fa(n)), ro = 0; ro < Ci.length; ro++) Ci[ro]()
        ;(Ci = null), (ro = 0)
    }
}
const Fa = (t) => (t.id == null ? 1 / 0 : t.id)
function ab(t) {
    ;(Fu = !1), (pc = !0), Qd(t), Pr.sort((r, n) => Fa(r) - Fa(n))
    const e = on
    try {
        for (Xn = 0; Xn < Pr.length; Xn++) {
            const r = Pr[Xn]
            r && r.active !== !1 && Mi(r, null, 14)
        }
    } finally {
        ;(Xn = 0), (Pr.length = 0), ob(), (pc = !1), (Zd = null), (Pr.length || _a.length || wa.length) && ab(t)
    }
}
function Q2(t, e, ...r) {
    const n = t.vnode.props || lt
    let i = r
    const s = e.startsWith("update:"),
        o = s && e.slice(7)
    if (o && o in n) {
        const f = `${o === "modelValue" ? "model" : o}Modifiers`,
            { number: u, trim: p } = n[f] || lt
        p ? (i = r.map((m) => m.trim())) : u && (i = r.map(jd))
    }
    let a,
        l = n[(a = Hf(e))] || n[(a = Hf(Rn(e)))]
    !l && s && (l = n[(a = Hf(Fo(e)))]), l && jr(l, t, 6, i)
    const c = n[a + "Once"]
    if (c) {
        if (!t.emitted) t.emitted = {}
        else if (t.emitted[a]) return
        ;(t.emitted[a] = !0), jr(c, t, 6, i)
    }
}
function lb(t, e, r = !1) {
    const n = e.emitsCache,
        i = n.get(t)
    if (i !== void 0) return i
    const s = t.emits
    let o = {},
        a = !1
    if (!Re(t)) {
        const l = (c) => {
            const f = lb(c, e, !0)
            f && ((a = !0), or(o, f))
        }
        !r && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l)
    }
    return !s && !a ? (n.set(t, null), null) : ($e(s) ? s.forEach((l) => (o[l] = null)) : or(o, s), n.set(t, o), o)
}
function e0(t, e) {
    return !t || !Rc(e) ? !1 : ((e = e.slice(2).replace(/Once$/, "")), Ye(t, e[0].toLowerCase() + e.slice(1)) || Ye(t, Fo(e)) || Ye(t, e))
}
let Or = null,
    cb = null
function gc(t) {
    const e = Or
    return (Or = t), (cb = (t && t.type.__scopeId) || null), e
}
function Te(t, e = Or, r) {
    if (!e || t._n) return t
    const n = (...i) => {
        n._d && Bh(-1)
        const s = gc(e),
            o = t(...i)
        return gc(s), n._d && Bh(1), o
    }
    return (n._n = !0), (n._c = !0), (n._d = !0), n
}
function jf(t) {
    const {
        type: e,
        vnode: r,
        proxy: n,
        withProxy: i,
        props: s,
        propsOptions: [o],
        slots: a,
        attrs: l,
        emit: c,
        render: f,
        renderCache: u,
        data: p,
        setupState: m,
        ctx: y,
        inheritAttrs: v,
    } = t
    let _, C
    const B = gc(t)
    try {
        if (r.shapeFlag & 4) {
            const U = i || n
            ;(_ = tn(f.call(U, U, u, s, m, p, y))), (C = l)
        } else {
            const U = e
            ;(_ = tn(U.length > 1 ? U(s, { attrs: l, slots: a, emit: c }) : U(s, null))), (C = e.props ? l : t_(l))
        }
    } catch (U) {
        ;(Sa.length = 0), sl(U, t, 1), (_ = jt(Tr))
    }
    let R = _
    if (C && v !== !1) {
        const U = Object.keys(C),
            { shapeFlag: D } = R
        U.length && D & 7 && (o && U.some(Fd) && (C = r_(C, o)), (R = Eo(R, C)))
    }
    return r.dirs && (R.dirs = R.dirs ? R.dirs.concat(r.dirs) : r.dirs), r.transition && (R.transition = r.transition), (_ = R), gc(B), _
}
function e_(t) {
    let e
    for (let r = 0; r < t.length; r++) {
        const n = t[r]
        if (Ha(n)) {
            if (n.type !== Tr || n.children === "v-if") {
                if (e) return
                e = n
            }
        } else return
    }
    return e
}
const t_ = (t) => {
        let e
        for (const r in t) (r === "class" || r === "style" || Rc(r)) && ((e || (e = {}))[r] = t[r])
        return e
    },
    r_ = (t, e) => {
        const r = {}
        for (const n in t) (!Fd(n) || !(n.slice(9) in e)) && (r[n] = t[n])
        return r
    }
function n_(t, e, r) {
    const { props: n, children: i, component: s } = t,
        { props: o, children: a, patchFlag: l } = e,
        c = s.emitsOptions
    if (e.dirs || e.transition) return !0
    if (r && l >= 0) {
        if (l & 1024) return !0
        if (l & 16) return n ? _h(n, o, c) : !!o
        if (l & 8) {
            const f = e.dynamicProps
            for (let u = 0; u < f.length; u++) {
                const p = f[u]
                if (o[p] !== n[p] && !e0(c, p)) return !0
            }
        }
    } else return (i || a) && (!a || !a.$stable) ? !0 : n === o ? !1 : n ? (o ? _h(n, o, c) : !0) : !!o
    return !1
}
function _h(t, e, r) {
    const n = Object.keys(e)
    if (n.length !== Object.keys(t).length) return !0
    for (let i = 0; i < n.length; i++) {
        const s = n[i]
        if (e[s] !== t[s] && !e0(r, s)) return !0
    }
    return !1
}
function t0({ vnode: t, parent: e }, r) {
    for (; e && e.subTree === t; ) ((t = e.vnode).el = r), (e = e.parent)
}
const i_ = (t) => t.__isSuspense,
    s_ = {
        name: "Suspense",
        __isSuspense: !0,
        process(t, e, r, n, i, s, o, a, l, c) {
            t == null ? o_(e, r, n, i, s, o, a, l, c) : a_(t, e, r, n, i, o, a, l, c)
        },
        hydrate: l_,
        create: r0,
        normalize: c_,
    },
    FB = s_
function Va(t, e) {
    const r = t.props && t.props[e]
    Re(r) && r()
}
function o_(t, e, r, n, i, s, o, a, l) {
    const {
            p: c,
            o: { createElement: f },
        } = l,
        u = f("div"),
        p = (t.suspense = r0(t, i, n, e, u, r, s, o, a, l))
    c(null, (p.pendingBranch = t.ssContent), u, null, n, p, s, o),
        p.deps > 0 ? (Va(t, "onPending"), Va(t, "onFallback"), c(null, t.ssFallback, e, r, n, null, s, o), mo(p, t.ssFallback)) : p.resolve()
}
function a_(t, e, r, n, i, s, o, a, { p: l, um: c, o: { createElement: f } }) {
    const u = (e.suspense = t.suspense)
    ;(u.vnode = e), (e.el = t.el)
    const p = e.ssContent,
        m = e.ssFallback,
        { activeBranch: y, pendingBranch: v, isInFallback: _, isHydrating: C } = u
    if (v)
        (u.pendingBranch = p),
            yn(p, v)
                ? (l(v, p, u.hiddenContainer, null, i, u, s, o, a), u.deps <= 0 ? u.resolve() : _ && (l(y, m, r, n, i, null, s, o, a), mo(u, m)))
                : (u.pendingId++,
                  C ? ((u.isHydrating = !1), (u.activeBranch = v)) : c(v, i, u),
                  (u.deps = 0),
                  (u.effects.length = 0),
                  (u.hiddenContainer = f("div")),
                  _
                      ? (l(null, p, u.hiddenContainer, null, i, u, s, o, a),
                        u.deps <= 0 ? u.resolve() : (l(y, m, r, n, i, null, s, o, a), mo(u, m)))
                      : y && yn(p, y)
                      ? (l(y, p, r, n, i, u, s, o, a), u.resolve(!0))
                      : (l(null, p, u.hiddenContainer, null, i, u, s, o, a), u.deps <= 0 && u.resolve()))
    else if (y && yn(p, y)) l(y, p, r, n, i, u, s, o, a), mo(u, p)
    else if ((Va(e, "onPending"), (u.pendingBranch = p), u.pendingId++, l(null, p, u.hiddenContainer, null, i, u, s, o, a), u.deps <= 0))
        u.resolve()
    else {
        const { timeout: B, pendingId: R } = u
        B > 0
            ? setTimeout(() => {
                  u.pendingId === R && u.fallback(m)
              }, B)
            : B === 0 && u.fallback(m)
    }
}
function r0(t, e, r, n, i, s, o, a, l, c, f = !1) {
    const {
            p: u,
            m: p,
            um: m,
            n: y,
            o: { parentNode: v, remove: _ },
        } = c,
        C = jd(t.props && t.props.timeout),
        B = {
            vnode: t,
            parent: e,
            parentComponent: r,
            isSVG: o,
            container: n,
            hiddenContainer: i,
            anchor: s,
            deps: 0,
            pendingId: 0,
            timeout: typeof C == "number" ? C : -1,
            activeBranch: null,
            pendingBranch: null,
            isInFallback: !0,
            isHydrating: f,
            isUnmounted: !1,
            effects: [],
            resolve(R = !1) {
                const { vnode: U, activeBranch: D, pendingBranch: Y, pendingId: J, effects: te, parentComponent: G, container: de } = B
                if (B.isHydrating) B.isHydrating = !1
                else if (!R) {
                    const b = D && Y.transition && Y.transition.mode === "out-in"
                    b &&
                        (D.transition.afterLeave = () => {
                            J === B.pendingId && p(Y, de, w, 0)
                        })
                    let { anchor: w } = B
                    D && ((w = y(D)), m(D, G, B, !0)), b || p(Y, de, w, 0)
                }
                mo(B, Y), (B.pendingBranch = null), (B.isInFallback = !1)
                let k = B.parent,
                    d = !1
                for (; k; ) {
                    if (k.pendingBranch) {
                        k.effects.push(...te), (d = !0)
                        break
                    }
                    k = k.parent
                }
                d || sb(te), (B.effects = []), Va(U, "onResolve")
            },
            fallback(R) {
                if (!B.pendingBranch) return
                const { vnode: U, activeBranch: D, parentComponent: Y, container: J, isSVG: te } = B
                Va(U, "onFallback")
                const G = y(D),
                    de = () => {
                        !B.isInFallback || (u(null, R, J, G, Y, null, te, a, l), mo(B, R))
                    },
                    k = R.transition && R.transition.mode === "out-in"
                k && (D.transition.afterLeave = de), (B.isInFallback = !0), m(D, Y, null, !0), k || de()
            },
            move(R, U, D) {
                B.activeBranch && p(B.activeBranch, R, U, D), (B.container = R)
            },
            next() {
                return B.activeBranch && y(B.activeBranch)
            },
            registerDep(R, U) {
                const D = !!B.pendingBranch
                D && B.deps++
                const Y = R.vnode.el
                R.asyncDep
                    .catch((J) => {
                        sl(J, R, 0)
                    })
                    .then((J) => {
                        if (R.isUnmounted || B.isUnmounted || B.pendingId !== R.suspenseId) return
                        R.asyncResolved = !0
                        const { vnode: te } = R
                        Xu(R, J, !1), Y && (te.el = Y)
                        const G = !Y && R.subTree.el
                        U(R, te, v(Y || R.subTree.el), Y ? null : y(R.subTree), B, o, l),
                            G && _(G),
                            t0(R, te.el),
                            D && --B.deps === 0 && B.resolve()
                    })
            },
            unmount(R, U) {
                ;(B.isUnmounted = !0), B.activeBranch && m(B.activeBranch, r, R, U), B.pendingBranch && m(B.pendingBranch, r, R, U)
            },
        }
    return B
}
function l_(t, e, r, n, i, s, o, a, l) {
    const c = (e.suspense = r0(e, n, r, t.parentNode, document.createElement("div"), null, i, s, o, a, !0)),
        f = l(t, (c.pendingBranch = e.ssContent), r, c, s, o)
    return c.deps === 0 && c.resolve(), f
}
function c_(t) {
    const { shapeFlag: e, children: r } = t,
        n = e & 32
    ;(t.ssContent = wh(n ? r.default : r)), (t.ssFallback = n ? wh(r.fallback) : jt(Tr))
}
function wh(t) {
    let e
    if (Re(t)) {
        const r = Ua && t._c
        r && ((t._d = !1), K()), (t = t()), r && ((t._d = !0), (e = Ri), Ab())
    }
    return $e(t) && (t = e_(t)), (t = tn(t)), e && !t.dynamicChildren && (t.dynamicChildren = e.filter((r) => r !== t)), t
}
function f_(t, e) {
    e && e.pendingBranch ? ($e(t) ? e.effects.push(...t) : e.effects.push(t)) : sb(t)
}
function mo(t, e) {
    t.activeBranch = e
    const { vnode: r, parentComponent: n } = t,
        i = (r.el = e.el)
    n && n.subTree === r && ((n.vnode.el = i), t0(n, i))
}
function Nn(t, e) {
    if (Xt) {
        let r = Xt.provides
        const n = Xt.parent && Xt.parent.provides
        n === r && (r = Xt.provides = Object.create(n)), (r[t] = e)
    }
}
function sr(t, e, r = !1) {
    const n = Xt || Or
    if (n) {
        const i = n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides
        if (i && t in i) return i[t]
        if (arguments.length > 1) return r && Re(e) ? e.call(n.proxy) : e
    }
}
const Eh = {}
function It(t, e, r) {
    return fb(t, e, r)
}
function fb(t, e, { immediate: r, deep: n, flush: i, onTrack: s, onTrigger: o } = lt) {
    const a = Xt
    let l,
        c = !1,
        f = !1
    if (
        (nr(t)
            ? ((l = () => t.value), (c = Wm(t)))
            : ks(t)
            ? ((l = () => t), (n = !0))
            : $e(t)
            ? ((f = !0),
              (c = t.some(ks)),
              (l = () =>
                  t.map((C) => {
                      if (nr(C)) return C.value
                      if (ks(C)) return As(C)
                      if (Re(C)) return Mi(C, a, 2)
                  })))
            : Re(t)
            ? e
                ? (l = () => Mi(t, a, 2))
                : (l = () => {
                      if (!(a && a.isUnmounted)) return u && u(), jr(t, a, 3, [p])
                  })
            : (l = on),
        e && n)
    ) {
        const C = l
        l = () => As(C())
    }
    let u,
        p = (C) => {
            u = _.onStop = () => {
                Mi(C, a, 4)
            }
        }
    if (qa) return (p = on), e ? r && jr(e, a, 3, [l(), f ? [] : void 0, p]) : l(), on
    let m = f ? [] : Eh
    const y = () => {
        if (!!_.active)
            if (e) {
                const C = _.run()
                ;(n || c || (f ? C.some((B, R) => Ra(B, m[R])) : Ra(C, m))) && (u && u(), jr(e, a, 3, [C, m === Eh ? void 0 : m, p]), (m = C))
            } else _.run()
    }
    y.allowRecurse = !!e
    let v
    i === "sync"
        ? (v = y)
        : i === "post"
        ? (v = () => vr(y, a && a.suspense))
        : (v = () => {
              !a || a.isMounted ? Z2(y) : y()
          })
    const _ = new Kd(l, v)
    return (
        e ? (r ? y() : (m = _.run())) : i === "post" ? vr(_.run.bind(_), a && a.suspense) : _.run(),
        () => {
            _.stop(), a && a.scope && Vd(a.scope.effects, _)
        }
    )
}
function u_(t, e, r) {
    const n = this.proxy,
        i = Ht(t) ? (t.includes(".") ? ub(n, t) : () => n[t]) : t.bind(n, n)
    let s
    Re(e) ? (s = e) : ((s = e.handler), (r = e))
    const o = Xt
    Ui(this)
    const a = fb(i, s.bind(n), r)
    return o ? Ui(o) : Li(), a
}
function ub(t, e) {
    const r = e.split(".")
    return () => {
        let n = t
        for (let i = 0; i < r.length && n; i++) n = n[r[i]]
        return n
    }
}
function As(t, e) {
    if (!Gt(t) || t.__v_skip || ((e = e || new Set()), e.has(t))) return t
    if ((e.add(t), nr(t))) As(t.value, e)
    else if ($e(t)) for (let r = 0; r < t.length; r++) As(t[r], e)
    else if (Om(t) || go(t))
        t.forEach((r) => {
            As(r, e)
        })
    else if (Rm(t)) for (const r in t) As(t[r], e)
    return t
}
function d_() {
    const t = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() }
    return (
        Zt(() => {
            t.isMounted = !0
        }),
        qc(() => {
            t.isUnmounting = !0
        }),
        t
    )
}
const Vr = [Function, Array],
    h_ = {
        name: "BaseTransition",
        props: {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: Vr,
            onEnter: Vr,
            onAfterEnter: Vr,
            onEnterCancelled: Vr,
            onBeforeLeave: Vr,
            onLeave: Vr,
            onAfterLeave: Vr,
            onLeaveCancelled: Vr,
            onBeforeAppear: Vr,
            onAppear: Vr,
            onAfterAppear: Vr,
            onAppearCancelled: Vr,
        },
        setup(t, { slots: e }) {
            const r = zc(),
                n = d_()
            let i
            return () => {
                const s = e.default && pb(e.default(), !0)
                if (!s || !s.length) return
                const o = et(t),
                    { mode: a } = o,
                    l = s[0]
                if (n.isLeaving) return zf(l)
                const c = Sh(l)
                if (!c) return zf(l)
                const f = Uu(c, o, n, r)
                Hu(c, f)
                const u = r.subTree,
                    p = u && Sh(u)
                let m = !1
                const { getTransitionKey: y } = c.type
                if (y) {
                    const v = y()
                    i === void 0 ? (i = v) : v !== i && ((i = v), (m = !0))
                }
                if (p && p.type !== Tr && (!yn(c, p) || m)) {
                    const v = Uu(p, o, n, r)
                    if ((Hu(p, v), a === "out-in"))
                        return (
                            (n.isLeaving = !0),
                            (v.afterLeave = () => {
                                ;(n.isLeaving = !1), r.update()
                            }),
                            zf(l)
                        )
                    a === "in-out" &&
                        c.type !== Tr &&
                        (v.delayLeave = (_, C, B) => {
                            const R = hb(n, p)
                            ;(R[String(p.key)] = p),
                                (_._leaveCb = () => {
                                    C(), (_._leaveCb = void 0), delete f.delayedLeave
                                }),
                                (f.delayedLeave = B)
                        })
                }
                return l
            }
        },
    },
    db = h_
function hb(t, e) {
    const { leavingVNodes: r } = t
    let n = r.get(e.type)
    return n || ((n = Object.create(null)), r.set(e.type, n)), n
}
function Uu(t, e, r, n) {
    const {
            appear: i,
            mode: s,
            persisted: o = !1,
            onBeforeEnter: a,
            onEnter: l,
            onAfterEnter: c,
            onEnterCancelled: f,
            onBeforeLeave: u,
            onLeave: p,
            onAfterLeave: m,
            onLeaveCancelled: y,
            onBeforeAppear: v,
            onAppear: _,
            onAfterAppear: C,
            onAppearCancelled: B,
        } = e,
        R = String(t.key),
        U = hb(r, t),
        D = (J, te) => {
            J && jr(J, n, 9, te)
        },
        Y = {
            mode: s,
            persisted: o,
            beforeEnter(J) {
                let te = a
                if (!r.isMounted)
                    if (i) te = v || a
                    else return
                J._leaveCb && J._leaveCb(!0)
                const G = U[R]
                G && yn(t, G) && G.el._leaveCb && G.el._leaveCb(), D(te, [J])
            },
            enter(J) {
                let te = l,
                    G = c,
                    de = f
                if (!r.isMounted)
                    if (i) (te = _ || l), (G = C || c), (de = B || f)
                    else return
                let k = !1
                const d = (J._enterCb = (b) => {
                    k || ((k = !0), b ? D(de, [J]) : D(G, [J]), Y.delayedLeave && Y.delayedLeave(), (J._enterCb = void 0))
                })
                te ? (te(J, d), te.length <= 1 && d()) : d()
            },
            leave(J, te) {
                const G = String(t.key)
                if ((J._enterCb && J._enterCb(!0), r.isUnmounting)) return te()
                D(u, [J])
                let de = !1
                const k = (J._leaveCb = (d) => {
                    de || ((de = !0), te(), d ? D(y, [J]) : D(m, [J]), (J._leaveCb = void 0), U[G] === t && delete U[G])
                })
                ;(U[G] = t), p ? (p(J, k), p.length <= 1 && k()) : k()
            },
            clone(J) {
                return Uu(J, e, r, n)
            },
        }
    return Y
}
function zf(t) {
    if (Uc(t)) return (t = Eo(t)), (t.children = null), t
}
function Sh(t) {
    return Uc(t) ? (t.children ? t.children[0] : void 0) : t
}
function Hu(t, e) {
    t.shapeFlag & 6 && t.component
        ? Hu(t.component.subTree, e)
        : t.shapeFlag & 128
        ? ((t.ssContent.transition = e.clone(t.ssContent)), (t.ssFallback.transition = e.clone(t.ssFallback)))
        : (t.transition = e)
}
function pb(t, e = !1) {
    let r = [],
        n = 0
    for (let i = 0; i < t.length; i++) {
        const s = t[i]
        s.type === Nt ? (s.patchFlag & 128 && n++, (r = r.concat(pb(s.children, e)))) : (e || s.type !== Tr) && r.push(s)
    }
    if (n > 1) for (let i = 0; i < r.length; i++) r[i].patchFlag = -2
    return r
}
function be(t) {
    return Re(t) ? { setup: t, name: t.name } : t
}
const qu = (t) => !!t.type.__asyncLoader,
    Uc = (t) => t.type.__isKeepAlive
function n0(t, e) {
    gb(t, "a", e)
}
function p_(t, e) {
    gb(t, "da", e)
}
function gb(t, e, r = Xt) {
    const n =
        t.__wdc ||
        (t.__wdc = () => {
            let i = r
            for (; i; ) {
                if (i.isDeactivated) return
                i = i.parent
            }
            return t()
        })
    if ((Hc(e, n, r), r)) {
        let i = r.parent
        for (; i && i.parent; ) Uc(i.parent.vnode) && g_(n, e, r, i), (i = i.parent)
    }
}
function g_(t, e, r, n) {
    const i = Hc(e, t, n, !0)
    i0(() => {
        Vd(n[e], i)
    }, r)
}
function Hc(t, e, r = Xt, n = !1) {
    if (r) {
        const i = r[t] || (r[t] = []),
            s =
                e.__weh ||
                (e.__weh = (...o) => {
                    if (r.isUnmounted) return
                    Vo(), Ui(r)
                    const a = jr(e, r, t, o)
                    return Li(), Uo(), a
                })
        return n ? i.unshift(s) : i.push(s), s
    }
}
const fi =
        (t) =>
        (e, r = Xt) =>
            (!qa || t === "sp") && Hc(t, e, r),
    m_ = fi("bm"),
    Zt = fi("m"),
    b_ = fi("bu"),
    x_ = fi("u"),
    qc = fi("bum"),
    i0 = fi("um"),
    v_ = fi("sp"),
    y_ = fi("rtg"),
    __ = fi("rtc")
function w_(t, e = Xt) {
    Hc("ec", t, e)
}
let ju = !0
function E_(t) {
    const e = bb(t),
        r = t.proxy,
        n = t.ctx
    ;(ju = !1), e.beforeCreate && Ah(e.beforeCreate, t, "bc")
    const {
        data: i,
        computed: s,
        methods: o,
        watch: a,
        provide: l,
        inject: c,
        created: f,
        beforeMount: u,
        mounted: p,
        beforeUpdate: m,
        updated: y,
        activated: v,
        deactivated: _,
        beforeDestroy: C,
        beforeUnmount: B,
        destroyed: R,
        unmounted: U,
        render: D,
        renderTracked: Y,
        renderTriggered: J,
        errorCaptured: te,
        serverPrefetch: G,
        expose: de,
        inheritAttrs: k,
        components: d,
        directives: b,
        filters: w,
    } = e
    if ((c && S_(c, n, null, t.appContext.config.unwrapInjectedRef), o))
        for (const A in o) {
            const $ = o[A]
            Re($) && (n[A] = $.bind(r))
        }
    if (i) {
        const A = i.call(r, r)
        Gt(A) && (t.data = Ln(A))
    }
    if (((ju = !0), s))
        for (const A in s) {
            const $ = s[A],
                S = Re($) ? $.bind(r, r) : Re($.get) ? $.get.bind(r, r) : on,
                g = !Re($) && Re($.set) ? $.set.bind(r) : on,
                x = H({ get: S, set: g })
            Object.defineProperty(n, A, { enumerable: !0, configurable: !0, get: () => x.value, set: (O) => (x.value = O) })
        }
    if (a) for (const A in a) mb(a[A], n, r, A)
    if (l) {
        const A = Re(l) ? l.call(r) : l
        Reflect.ownKeys(A).forEach(($) => {
            Nn($, A[$])
        })
    }
    f && Ah(f, t, "c")
    function T(A, $) {
        $e($) ? $.forEach((S) => A(S.bind(r))) : $ && A($.bind(r))
    }
    if ((T(m_, u), T(Zt, p), T(b_, m), T(x_, y), T(n0, v), T(p_, _), T(w_, te), T(__, Y), T(y_, J), T(qc, B), T(i0, U), T(v_, G), $e(de)))
        if (de.length) {
            const A = t.exposed || (t.exposed = {})
            de.forEach(($) => {
                Object.defineProperty(A, $, { get: () => r[$], set: (S) => (r[$] = S) })
            })
        } else t.exposed || (t.exposed = {})
    D && t.render === on && (t.render = D), k != null && (t.inheritAttrs = k), d && (t.components = d), b && (t.directives = b)
}
function S_(t, e, r = on, n = !1) {
    $e(t) && (t = zu(t))
    for (const i in t) {
        const s = t[i]
        let o
        Gt(s) ? ("default" in s ? (o = sr(s.from || i, s.default, !0)) : (o = sr(s.from || i))) : (o = sr(s)),
            nr(o) && n
                ? Object.defineProperty(e, i, { enumerable: !0, configurable: !0, get: () => o.value, set: (a) => (o.value = a) })
                : (e[i] = o)
    }
}
function Ah(t, e, r) {
    jr($e(t) ? t.map((n) => n.bind(e.proxy)) : t.bind(e.proxy), e, r)
}
function mb(t, e, r, n) {
    const i = n.includes(".") ? ub(r, n) : () => r[n]
    if (Ht(t)) {
        const s = e[t]
        Re(s) && It(i, s)
    } else if (Re(t)) It(i, t.bind(r))
    else if (Gt(t))
        if ($e(t)) t.forEach((s) => mb(s, e, r, n))
        else {
            const s = Re(t.handler) ? t.handler.bind(r) : e[t.handler]
            Re(s) && It(i, s, t)
        }
}
function bb(t) {
    const e = t.type,
        { mixins: r, extends: n } = e,
        {
            mixins: i,
            optionsCache: s,
            config: { optionMergeStrategies: o },
        } = t.appContext,
        a = s.get(e)
    let l
    return a ? (l = a) : !i.length && !r && !n ? (l = e) : ((l = {}), i.length && i.forEach((c) => mc(l, c, o, !0)), mc(l, e, o)), s.set(e, l), l
}
function mc(t, e, r, n = !1) {
    const { mixins: i, extends: s } = e
    s && mc(t, s, r, !0), i && i.forEach((o) => mc(t, o, r, !0))
    for (const o in e)
        if (!(n && o === "expose")) {
            const a = A_[o] || (r && r[o])
            t[o] = a ? a(t[o], e[o]) : e[o]
        }
    return t
}
const A_ = {
    data: Th,
    props: ys,
    emits: ys,
    methods: ys,
    computed: ys,
    beforeCreate: dr,
    created: dr,
    beforeMount: dr,
    mounted: dr,
    beforeUpdate: dr,
    updated: dr,
    beforeDestroy: dr,
    beforeUnmount: dr,
    destroyed: dr,
    unmounted: dr,
    activated: dr,
    deactivated: dr,
    errorCaptured: dr,
    serverPrefetch: dr,
    components: ys,
    directives: ys,
    watch: C_,
    provide: Th,
    inject: T_,
}
function Th(t, e) {
    return e
        ? t
            ? function () {
                  return or(Re(t) ? t.call(this, this) : t, Re(e) ? e.call(this, this) : e)
              }
            : e
        : t
}
function T_(t, e) {
    return ys(zu(t), zu(e))
}
function zu(t) {
    if ($e(t)) {
        const e = {}
        for (let r = 0; r < t.length; r++) e[t[r]] = t[r]
        return e
    }
    return t
}
function dr(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}
function ys(t, e) {
    return t ? or(or(Object.create(null), t), e) : e
}
function C_(t, e) {
    if (!t) return e
    if (!e) return t
    const r = or(Object.create(null), t)
    for (const n in e) r[n] = dr(t[n], e[n])
    return r
}
function k_(t, e, r, n = !1) {
    const i = {},
        s = {}
    hc(s, jc, 1), (t.propsDefaults = Object.create(null)), xb(t, e, i, s)
    for (const o in t.propsOptions[0]) o in i || (i[o] = void 0)
    r ? (t.props = n ? i : q2(i)) : t.type.props ? (t.props = i) : (t.props = s), (t.attrs = s)
}
function N_(t, e, r, n) {
    const {
            props: i,
            attrs: s,
            vnode: { patchFlag: o },
        } = t,
        a = et(i),
        [l] = t.propsOptions
    let c = !1
    if ((n || o > 0) && !(o & 16)) {
        if (o & 8) {
            const f = t.vnode.dynamicProps
            for (let u = 0; u < f.length; u++) {
                let p = f[u]
                const m = e[p]
                if (l)
                    if (Ye(s, p)) m !== s[p] && ((s[p] = m), (c = !0))
                    else {
                        const y = Rn(p)
                        i[y] = Ku(l, a, y, m, t, !1)
                    }
                else m !== s[p] && ((s[p] = m), (c = !0))
            }
        }
    } else {
        xb(t, e, i, s) && (c = !0)
        let f
        for (const u in a)
            (!e || (!Ye(e, u) && ((f = Fo(u)) === u || !Ye(e, f)))) &&
                (l ? r && (r[u] !== void 0 || r[f] !== void 0) && (i[u] = Ku(l, a, u, void 0, t, !0)) : delete i[u])
        if (s !== a) for (const u in s) (!e || (!Ye(e, u) && !0)) && (delete s[u], (c = !0))
    }
    c && ii(t, "set", "$attrs")
}
function xb(t, e, r, n) {
    const [i, s] = t.propsOptions
    let o = !1,
        a
    if (e)
        for (let l in e) {
            if (Jl(l)) continue
            const c = e[l]
            let f
            i && Ye(i, (f = Rn(l)))
                ? !s || !s.includes(f)
                    ? (r[f] = c)
                    : ((a || (a = {}))[f] = c)
                : e0(t.emitsOptions, l) || ((!(l in n) || c !== n[l]) && ((n[l] = c), (o = !0)))
        }
    if (s) {
        const l = et(r),
            c = a || lt
        for (let f = 0; f < s.length; f++) {
            const u = s[f]
            r[u] = Ku(i, l, u, c[u], t, !Ye(c, u))
        }
    }
    return o
}
function Ku(t, e, r, n, i, s) {
    const o = t[r]
    if (o != null) {
        const a = Ye(o, "default")
        if (a && n === void 0) {
            const l = o.default
            if (o.type !== Function && Re(l)) {
                const { propsDefaults: c } = i
                r in c ? (n = c[r]) : (Ui(i), (n = c[r] = l.call(null, e)), Li())
            } else n = l
        }
        o[0] && (s && !a ? (n = !1) : o[1] && (n === "" || n === Fo(r)) && (n = !0))
    }
    return n
}
function vb(t, e, r = !1) {
    const n = e.propsCache,
        i = n.get(t)
    if (i) return i
    const s = t.props,
        o = {},
        a = []
    let l = !1
    if (!Re(t)) {
        const f = (u) => {
            l = !0
            const [p, m] = vb(u, e, !0)
            or(o, p), m && a.push(...m)
        }
        !r && e.mixins.length && e.mixins.forEach(f), t.extends && f(t.extends), t.mixins && t.mixins.forEach(f)
    }
    if (!s && !l) return n.set(t, po), po
    if ($e(s))
        for (let f = 0; f < s.length; f++) {
            const u = Rn(s[f])
            Ch(u) && (o[u] = lt)
        }
    else if (s)
        for (const f in s) {
            const u = Rn(f)
            if (Ch(u)) {
                const p = s[f],
                    m = (o[u] = $e(p) || Re(p) ? { type: p } : p)
                if (m) {
                    const y = Ph(Boolean, m.type),
                        v = Ph(String, m.type)
                    ;(m[0] = y > -1), (m[1] = v < 0 || y < v), (y > -1 || Ye(m, "default")) && a.push(u)
                }
            }
        }
    const c = [o, a]
    return n.set(t, c), c
}
function Ch(t) {
    return t[0] !== "$"
}
function kh(t) {
    const e = t && t.toString().match(/^\s*function (\w+)/)
    return e ? e[1] : t === null ? "null" : ""
}
function Nh(t, e) {
    return kh(t) === kh(e)
}
function Ph(t, e) {
    return $e(e) ? e.findIndex((r) => Nh(r, t)) : Re(e) && Nh(e, t) ? 0 : -1
}
const yb = (t) => t[0] === "_" || t === "$stable",
    s0 = (t) => ($e(t) ? t.map(tn) : [tn(t)]),
    P_ = (t, e, r) => {
        const n = Te((...i) => s0(e(...i)), r)
        return (n._c = !1), n
    },
    _b = (t, e, r) => {
        const n = t._ctx
        for (const i in t) {
            if (yb(i)) continue
            const s = t[i]
            if (Re(s)) e[i] = P_(i, s, n)
            else if (s != null) {
                const o = s0(s)
                e[i] = () => o
            }
        }
    },
    wb = (t, e) => {
        const r = s0(e)
        t.slots.default = () => r
    },
    I_ = (t, e) => {
        if (t.vnode.shapeFlag & 32) {
            const r = e._
            r ? ((t.slots = et(e)), hc(e, "_", r)) : _b(e, (t.slots = {}))
        } else (t.slots = {}), e && wb(t, e)
        hc(t.slots, jc, 1)
    },
    $_ = (t, e, r) => {
        const { vnode: n, slots: i } = t
        let s = !0,
            o = lt
        if (n.shapeFlag & 32) {
            const a = e._
            a ? (r && a === 1 ? (s = !1) : (or(i, e), !r && a === 1 && delete i._)) : ((s = !e.$stable), _b(e, i)), (o = e)
        } else e && (wb(t, e), (o = { default: 1 }))
        if (s) for (const a in i) !yb(a) && !(a in o) && delete i[a]
    }
function B_(t, e) {
    const r = Or
    if (r === null) return t
    const n = r.proxy,
        i = t.dirs || (t.dirs = [])
    for (let s = 0; s < e.length; s++) {
        let [o, a, l, c = lt] = e[s]
        Re(o) && (o = { mounted: o, updated: o }),
            o.deep && As(a),
            i.push({ dir: o, instance: n, value: a, oldValue: void 0, arg: l, modifiers: c })
    }
    return t
}
function fs(t, e, r, n) {
    const i = t.dirs,
        s = e && e.dirs
    for (let o = 0; o < i.length; o++) {
        const a = i[o]
        s && (a.oldValue = s[o].value)
        let l = a.dir[n]
        l && (Vo(), jr(l, r, 8, [t.el, a, t, e]), Uo())
    }
}
function Eb() {
    return {
        app: null,
        config: {
            isNativeTag: c2,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {},
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap(),
    }
}
let O_ = 0
function M_(t, e) {
    return function (n, i = null) {
        i != null && !Gt(i) && (i = null)
        const s = Eb(),
            o = new Set()
        let a = !1
        const l = (s.app = {
            _uid: O_++,
            _component: n,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: r3,
            get config() {
                return s.config
            },
            set config(c) {},
            use(c, ...f) {
                return o.has(c) || (c && Re(c.install) ? (o.add(c), c.install(l, ...f)) : Re(c) && (o.add(c), c(l, ...f))), l
            },
            mixin(c) {
                return s.mixins.includes(c) || s.mixins.push(c), l
            },
            component(c, f) {
                return f ? ((s.components[c] = f), l) : s.components[c]
            },
            directive(c, f) {
                return f ? ((s.directives[c] = f), l) : s.directives[c]
            },
            mount(c, f, u) {
                if (!a) {
                    const p = jt(n, i)
                    return (
                        (p.appContext = s),
                        f && e ? e(p, c) : t(p, c, u),
                        (a = !0),
                        (l._container = c),
                        (c.__vue_app__ = l),
                        u0(p.component) || p.component.proxy
                    )
                }
            },
            unmount() {
                a && (t(null, l._container), delete l._container.__vue_app__)
            },
            provide(c, f) {
                return (s.provides[c] = f), l
            },
        })
        return l
    }
}
function Gu(t, e, r, n, i = !1) {
    if ($e(t)) {
        t.forEach((p, m) => Gu(p, e && ($e(e) ? e[m] : e), r, n, i))
        return
    }
    if (qu(n) && !i) return
    const s = n.shapeFlag & 4 ? u0(n.component) || n.component.proxy : n.el,
        o = i ? null : s,
        { i: a, r: l } = t,
        c = e && e.r,
        f = a.refs === lt ? (a.refs = {}) : a.refs,
        u = a.setupState
    if ((c != null && c !== l && (Ht(c) ? ((f[c] = null), Ye(u, c) && (u[c] = null)) : nr(c) && (c.value = null)), Re(l))) Mi(l, a, 12, [o, f])
    else {
        const p = Ht(l),
            m = nr(l)
        if (p || m) {
            const y = () => {
                if (t.f) {
                    const v = p ? f[l] : l.value
                    i ? $e(v) && Vd(v, s) : $e(v) ? v.includes(s) || v.push(s) : p ? (f[l] = [s]) : ((l.value = [s]), t.k && (f[t.k] = l.value))
                } else p ? ((f[l] = o), Ye(u, l) && (u[l] = o)) : nr(l) && ((l.value = o), t.k && (f[t.k] = o))
            }
            o ? ((y.id = -1), vr(y, r)) : y()
        }
    }
}
const vr = f_
function R_(t) {
    return L_(t)
}
function L_(t, e) {
    const r = g2()
    r.__VUE__ = !0
    const {
            insert: n,
            remove: i,
            patchProp: s,
            createElement: o,
            createText: a,
            createComment: l,
            setText: c,
            setElementText: f,
            parentNode: u,
            nextSibling: p,
            setScopeId: m = on,
            cloneNode: y,
            insertStaticContent: v,
        } = t,
        _ = (N, I, q, Q = null, ie = null, Z = null, oe = !1, fe = null, se = !!I.dynamicChildren) => {
            if (N === I) return
            N && !yn(N, I) && ((Q = V(N)), j(N, ie, Z, !0), (N = null)), I.patchFlag === -2 && ((se = !1), (I.dynamicChildren = null))
            const { type: re, ref: Ee, shapeFlag: he } = I
            switch (re) {
                case c0:
                    C(N, I, q, Q)
                    break
                case Tr:
                    B(N, I, q, Q)
                    break
                case Kf:
                    N == null && R(I, q, Q, oe)
                    break
                case Nt:
                    b(N, I, q, Q, ie, Z, oe, fe, se)
                    break
                default:
                    he & 1
                        ? Y(N, I, q, Q, ie, Z, oe, fe, se)
                        : he & 6
                        ? w(N, I, q, Q, ie, Z, oe, fe, se)
                        : (he & 64 || he & 128) && re.process(N, I, q, Q, ie, Z, oe, fe, se, ee)
            }
            Ee != null && ie && Gu(Ee, N && N.ref, Z, I || N, !I)
        },
        C = (N, I, q, Q) => {
            if (N == null) n((I.el = a(I.children)), q, Q)
            else {
                const ie = (I.el = N.el)
                I.children !== N.children && c(ie, I.children)
            }
        },
        B = (N, I, q, Q) => {
            N == null ? n((I.el = l(I.children || "")), q, Q) : (I.el = N.el)
        },
        R = (N, I, q, Q) => {
            ;[N.el, N.anchor] = v(N.children, I, q, Q, N.el, N.anchor)
        },
        U = ({ el: N, anchor: I }, q, Q) => {
            let ie
            for (; N && N !== I; ) (ie = p(N)), n(N, q, Q), (N = ie)
            n(I, q, Q)
        },
        D = ({ el: N, anchor: I }) => {
            let q
            for (; N && N !== I; ) (q = p(N)), i(N), (N = q)
            i(I)
        },
        Y = (N, I, q, Q, ie, Z, oe, fe, se) => {
            ;(oe = oe || I.type === "svg"), N == null ? J(I, q, Q, ie, Z, oe, fe, se) : de(N, I, ie, Z, oe, fe, se)
        },
        J = (N, I, q, Q, ie, Z, oe, fe) => {
            let se, re
            const { type: Ee, props: he, shapeFlag: me, transition: Ce, patchFlag: Se, dirs: Ne } = N
            if (N.el && y !== void 0 && Se === -1) se = N.el = y(N.el)
            else {
                if (
                    ((se = N.el = o(N.type, Z, he && he.is, he)),
                    me & 8 ? f(se, N.children) : me & 16 && G(N.children, se, null, Q, ie, Z && Ee !== "foreignObject", oe, fe),
                    Ne && fs(N, null, Q, "created"),
                    he)
                ) {
                    for (const ke in he) ke !== "value" && !Jl(ke) && s(se, ke, null, he[ke], Z, N.children, Q, ie, M)
                    "value" in he && s(se, "value", null, he.value), (re = he.onVnodeBeforeMount) && dn(re, Q, N)
                }
                te(se, N, N.scopeId, oe, Q)
            }
            Ne && fs(N, null, Q, "beforeMount")
            const Ge = (!ie || (ie && !ie.pendingBranch)) && Ce && !Ce.persisted
            Ge && Ce.beforeEnter(se),
                n(se, I, q),
                ((re = he && he.onVnodeMounted) || Ge || Ne) &&
                    vr(() => {
                        re && dn(re, Q, N), Ge && Ce.enter(se), Ne && fs(N, null, Q, "mounted")
                    }, ie)
        },
        te = (N, I, q, Q, ie) => {
            if ((q && m(N, q), Q)) for (let Z = 0; Z < Q.length; Z++) m(N, Q[Z])
            if (ie) {
                let Z = ie.subTree
                if (I === Z) {
                    const oe = ie.vnode
                    te(N, oe, oe.scopeId, oe.slotScopeIds, ie.parent)
                }
            }
        },
        G = (N, I, q, Q, ie, Z, oe, fe, se = 0) => {
            for (let re = se; re < N.length; re++) {
                const Ee = (N[re] = fe ? ki(N[re]) : tn(N[re]))
                _(null, Ee, I, q, Q, ie, Z, oe, fe)
            }
        },
        de = (N, I, q, Q, ie, Z, oe) => {
            const fe = (I.el = N.el)
            let { patchFlag: se, dynamicChildren: re, dirs: Ee } = I
            se |= N.patchFlag & 16
            const he = N.props || lt,
                me = I.props || lt
            let Ce
            q && us(q, !1), (Ce = me.onVnodeBeforeUpdate) && dn(Ce, q, I, N), Ee && fs(I, N, q, "beforeUpdate"), q && us(q, !0)
            const Se = ie && I.type !== "foreignObject"
            if ((re ? k(N.dynamicChildren, re, fe, q, Q, Se, Z) : oe || S(N, I, fe, null, q, Q, Se, Z, !1), se > 0)) {
                if (se & 16) d(fe, I, he, me, q, Q, ie)
                else if (
                    (se & 2 && he.class !== me.class && s(fe, "class", null, me.class, ie),
                    se & 4 && s(fe, "style", he.style, me.style, ie),
                    se & 8)
                ) {
                    const Ne = I.dynamicProps
                    for (let Ge = 0; Ge < Ne.length; Ge++) {
                        const ke = Ne[Ge],
                            qe = he[ke],
                            br = me[ke]
                        ;(br !== qe || ke === "value") && s(fe, ke, qe, br, ie, N.children, q, Q, M)
                    }
                }
                se & 1 && N.children !== I.children && f(fe, I.children)
            } else !oe && re == null && d(fe, I, he, me, q, Q, ie)
            ;((Ce = me.onVnodeUpdated) || Ee) &&
                vr(() => {
                    Ce && dn(Ce, q, I, N), Ee && fs(I, N, q, "updated")
                }, Q)
        },
        k = (N, I, q, Q, ie, Z, oe) => {
            for (let fe = 0; fe < I.length; fe++) {
                const se = N[fe],
                    re = I[fe],
                    Ee = se.el && (se.type === Nt || !yn(se, re) || se.shapeFlag & 70) ? u(se.el) : q
                _(se, re, Ee, null, Q, ie, Z, oe, !0)
            }
        },
        d = (N, I, q, Q, ie, Z, oe) => {
            if (q !== Q) {
                for (const fe in Q) {
                    if (Jl(fe)) continue
                    const se = Q[fe],
                        re = q[fe]
                    se !== re && fe !== "value" && s(N, fe, re, se, oe, I.children, ie, Z, M)
                }
                if (q !== lt) for (const fe in q) !Jl(fe) && !(fe in Q) && s(N, fe, q[fe], null, oe, I.children, ie, Z, M)
                "value" in Q && s(N, "value", q.value, Q.value)
            }
        },
        b = (N, I, q, Q, ie, Z, oe, fe, se) => {
            const re = (I.el = N ? N.el : a("")),
                Ee = (I.anchor = N ? N.anchor : a(""))
            let { patchFlag: he, dynamicChildren: me, slotScopeIds: Ce } = I
            Ce && (fe = fe ? fe.concat(Ce) : Ce),
                N == null
                    ? (n(re, q, Q), n(Ee, q, Q), G(I.children, q, Ee, ie, Z, oe, fe, se))
                    : he > 0 && he & 64 && me && N.dynamicChildren
                    ? (k(N.dynamicChildren, me, q, ie, Z, oe, fe), (I.key != null || (ie && I === ie.subTree)) && o0(N, I, !0))
                    : S(N, I, q, Ee, ie, Z, oe, fe, se)
        },
        w = (N, I, q, Q, ie, Z, oe, fe, se) => {
            ;(I.slotScopeIds = fe), N == null ? (I.shapeFlag & 512 ? ie.ctx.activate(I, q, Q, oe, se) : E(I, q, Q, ie, Z, oe, se)) : T(N, I, se)
        },
        E = (N, I, q, Q, ie, Z, oe) => {
            const fe = (N.component = J_(N, Q, ie))
            if ((Uc(N) && (fe.ctx.renderer = ee), X_(fe), fe.asyncDep)) {
                if ((ie && ie.registerDep(fe, A), !N.el)) {
                    const se = (fe.subTree = jt(Tr))
                    B(null, se, I, q)
                }
                return
            }
            A(fe, N, I, q, ie, Z, oe)
        },
        T = (N, I, q) => {
            const Q = (I.component = N.component)
            if (n_(N, I, q))
                if (Q.asyncDep && !Q.asyncResolved) {
                    $(Q, I, q)
                    return
                } else (Q.next = I), Y2(Q.update), Q.update()
            else (I.component = N.component), (I.el = N.el), (Q.vnode = I)
        },
        A = (N, I, q, Q, ie, Z, oe) => {
            const fe = () => {
                    if (N.isMounted) {
                        let { next: Ee, bu: he, u: me, parent: Ce, vnode: Se } = N,
                            Ne = Ee,
                            Ge
                        us(N, !1),
                            Ee ? ((Ee.el = Se.el), $(N, Ee, oe)) : (Ee = Se),
                            he && qf(he),
                            (Ge = Ee.props && Ee.props.onVnodeBeforeUpdate) && dn(Ge, Ce, Ee, Se),
                            us(N, !0)
                        const ke = jf(N),
                            qe = N.subTree
                        ;(N.subTree = ke),
                            _(qe, ke, u(qe.el), V(qe), N, ie, Z),
                            (Ee.el = ke.el),
                            Ne === null && t0(N, ke.el),
                            me && vr(me, ie),
                            (Ge = Ee.props && Ee.props.onVnodeUpdated) && vr(() => dn(Ge, Ce, Ee, Se), ie)
                    } else {
                        let Ee
                        const { el: he, props: me } = I,
                            { bm: Ce, m: Se, parent: Ne } = N,
                            Ge = qu(I)
                        if ((us(N, !1), Ce && qf(Ce), !Ge && (Ee = me && me.onVnodeBeforeMount) && dn(Ee, Ne, I), us(N, !0), he && W)) {
                            const ke = () => {
                                ;(N.subTree = jf(N)), W(he, N.subTree, N, ie, null)
                            }
                            Ge ? I.type.__asyncLoader().then(() => !N.isUnmounted && ke()) : ke()
                        } else {
                            const ke = (N.subTree = jf(N))
                            _(null, ke, q, Q, N, ie, Z), (I.el = ke.el)
                        }
                        if ((Se && vr(Se, ie), !Ge && (Ee = me && me.onVnodeMounted))) {
                            const ke = I
                            vr(() => dn(Ee, Ne, ke), ie)
                        }
                        I.shapeFlag & 256 && N.a && vr(N.a, ie), (N.isMounted = !0), (I = q = Q = null)
                    }
                },
                se = (N.effect = new Kd(fe, () => rb(N.update), N.scope)),
                re = (N.update = se.run.bind(se))
            ;(re.id = N.uid), us(N, !0), re()
        },
        $ = (N, I, q) => {
            I.component = N
            const Q = N.vnode.props
            ;(N.vnode = I), (N.next = null), N_(N, I.props, Q, q), $_(N, I.children, q), Vo(), Qd(void 0, N.update), Uo()
        },
        S = (N, I, q, Q, ie, Z, oe, fe, se = !1) => {
            const re = N && N.children,
                Ee = N ? N.shapeFlag : 0,
                he = I.children,
                { patchFlag: me, shapeFlag: Ce } = I
            if (me > 0) {
                if (me & 128) {
                    x(re, he, q, Q, ie, Z, oe, fe, se)
                    return
                } else if (me & 256) {
                    g(re, he, q, Q, ie, Z, oe, fe, se)
                    return
                }
            }
            Ce & 8
                ? (Ee & 16 && M(re, ie, Z), he !== re && f(q, he))
                : Ee & 16
                ? Ce & 16
                    ? x(re, he, q, Q, ie, Z, oe, fe, se)
                    : M(re, ie, Z, !0)
                : (Ee & 8 && f(q, ""), Ce & 16 && G(he, q, Q, ie, Z, oe, fe, se))
        },
        g = (N, I, q, Q, ie, Z, oe, fe, se) => {
            ;(N = N || po), (I = I || po)
            const re = N.length,
                Ee = I.length,
                he = Math.min(re, Ee)
            let me
            for (me = 0; me < he; me++) {
                const Ce = (I[me] = se ? ki(I[me]) : tn(I[me]))
                _(N[me], Ce, q, null, ie, Z, oe, fe, se)
            }
            re > Ee ? M(N, ie, Z, !0, !1, he) : G(I, q, Q, ie, Z, oe, fe, se, he)
        },
        x = (N, I, q, Q, ie, Z, oe, fe, se) => {
            let re = 0
            const Ee = I.length
            let he = N.length - 1,
                me = Ee - 1
            for (; re <= he && re <= me; ) {
                const Ce = N[re],
                    Se = (I[re] = se ? ki(I[re]) : tn(I[re]))
                if (yn(Ce, Se)) _(Ce, Se, q, null, ie, Z, oe, fe, se)
                else break
                re++
            }
            for (; re <= he && re <= me; ) {
                const Ce = N[he],
                    Se = (I[me] = se ? ki(I[me]) : tn(I[me]))
                if (yn(Ce, Se)) _(Ce, Se, q, null, ie, Z, oe, fe, se)
                else break
                he--, me--
            }
            if (re > he) {
                if (re <= me) {
                    const Ce = me + 1,
                        Se = Ce < Ee ? I[Ce].el : Q
                    for (; re <= me; ) _(null, (I[re] = se ? ki(I[re]) : tn(I[re])), q, Se, ie, Z, oe, fe, se), re++
                }
            } else if (re > me) for (; re <= he; ) j(N[re], ie, Z, !0), re++
            else {
                const Ce = re,
                    Se = re,
                    Ne = new Map()
                for (re = Se; re <= me; re++) {
                    const Ve = (I[re] = se ? ki(I[re]) : tn(I[re]))
                    Ve.key != null && Ne.set(Ve.key, re)
                }
                let Ge,
                    ke = 0
                const qe = me - Se + 1
                let br = !1,
                    it = 0
                const Ze = new Array(qe)
                for (re = 0; re < qe; re++) Ze[re] = 0
                for (re = Ce; re <= he; re++) {
                    const Ve = N[re]
                    if (ke >= qe) {
                        j(Ve, ie, Z, !0)
                        continue
                    }
                    let je
                    if (Ve.key != null) je = Ne.get(Ve.key)
                    else
                        for (Ge = Se; Ge <= me; Ge++)
                            if (Ze[Ge - Se] === 0 && yn(Ve, I[Ge])) {
                                je = Ge
                                break
                            }
                    je === void 0
                        ? j(Ve, ie, Z, !0)
                        : ((Ze[je - Se] = re + 1), je >= it ? (it = je) : (br = !0), _(Ve, I[je], q, null, ie, Z, oe, fe, se), ke++)
                }
                const fn = br ? D_(Ze) : po
                for (Ge = fn.length - 1, re = qe - 1; re >= 0; re--) {
                    const Ve = Se + re,
                        je = I[Ve],
                        un = Ve + 1 < Ee ? I[Ve + 1].el : Q
                    Ze[re] === 0 ? _(null, je, q, un, ie, Z, oe, fe, se) : br && (Ge < 0 || re !== fn[Ge] ? O(je, q, un, 2) : Ge--)
                }
            }
        },
        O = (N, I, q, Q, ie = null) => {
            const { el: Z, type: oe, transition: fe, children: se, shapeFlag: re } = N
            if (re & 6) {
                O(N.component.subTree, I, q, Q)
                return
            }
            if (re & 128) {
                N.suspense.move(I, q, Q)
                return
            }
            if (re & 64) {
                oe.move(N, I, q, ee)
                return
            }
            if (oe === Nt) {
                n(Z, I, q)
                for (let he = 0; he < se.length; he++) O(se[he], I, q, Q)
                n(N.anchor, I, q)
                return
            }
            if (oe === Kf) {
                U(N, I, q)
                return
            }
            if (Q !== 2 && re & 1 && fe)
                if (Q === 0) fe.beforeEnter(Z), n(Z, I, q), vr(() => fe.enter(Z), ie)
                else {
                    const { leave: he, delayLeave: me, afterLeave: Ce } = fe,
                        Se = () => n(Z, I, q),
                        Ne = () => {
                            he(Z, () => {
                                Se(), Ce && Ce()
                            })
                        }
                    me ? me(Z, Se, Ne) : Ne()
                }
            else n(Z, I, q)
        },
        j = (N, I, q, Q = !1, ie = !1) => {
            const { type: Z, props: oe, ref: fe, children: se, dynamicChildren: re, shapeFlag: Ee, patchFlag: he, dirs: me } = N
            if ((fe != null && Gu(fe, null, q, N, !0), Ee & 256)) {
                I.ctx.deactivate(N)
                return
            }
            const Ce = Ee & 1 && me,
                Se = !qu(N)
            let Ne
            if ((Se && (Ne = oe && oe.onVnodeBeforeUnmount) && dn(Ne, I, N), Ee & 6)) P(N.component, q, Q)
            else {
                if (Ee & 128) {
                    N.suspense.unmount(q, Q)
                    return
                }
                Ce && fs(N, null, I, "beforeUnmount"),
                    Ee & 64
                        ? N.type.remove(N, I, q, ie, ee, Q)
                        : re && (Z !== Nt || (he > 0 && he & 64))
                        ? M(re, I, q, !1, !0)
                        : ((Z === Nt && he & 384) || (!ie && Ee & 16)) && M(se, I, q),
                    Q && L(N)
            }
            ;((Se && (Ne = oe && oe.onVnodeUnmounted)) || Ce) &&
                vr(() => {
                    Ne && dn(Ne, I, N), Ce && fs(N, null, I, "unmounted")
                }, q)
        },
        L = (N) => {
            const { type: I, el: q, anchor: Q, transition: ie } = N
            if (I === Nt) {
                h(q, Q)
                return
            }
            if (I === Kf) {
                D(N)
                return
            }
            const Z = () => {
                i(q), ie && !ie.persisted && ie.afterLeave && ie.afterLeave()
            }
            if (N.shapeFlag & 1 && ie && !ie.persisted) {
                const { leave: oe, delayLeave: fe } = ie,
                    se = () => oe(q, Z)
                fe ? fe(N.el, Z, se) : se()
            } else Z()
        },
        h = (N, I) => {
            let q
            for (; N !== I; ) (q = p(N)), i(N), (N = q)
            i(I)
        },
        P = (N, I, q) => {
            const { bum: Q, scope: ie, update: Z, subTree: oe, um: fe } = N
            Q && qf(Q),
                ie.stop(),
                Z && ((Z.active = !1), j(oe, N, I, q)),
                fe && vr(fe, I),
                vr(() => {
                    N.isUnmounted = !0
                }, I),
                I &&
                    I.pendingBranch &&
                    !I.isUnmounted &&
                    N.asyncDep &&
                    !N.asyncResolved &&
                    N.suspenseId === I.pendingId &&
                    (I.deps--, I.deps === 0 && I.resolve())
        },
        M = (N, I, q, Q = !1, ie = !1, Z = 0) => {
            for (let oe = Z; oe < N.length; oe++) j(N[oe], I, q, Q, ie)
        },
        V = (N) => (N.shapeFlag & 6 ? V(N.component.subTree) : N.shapeFlag & 128 ? N.suspense.next() : p(N.anchor || N.el)),
        z = (N, I, q) => {
            N == null ? I._vnode && j(I._vnode, null, null, !0) : _(I._vnode || null, N, I, null, null, null, q), ob(), (I._vnode = N)
        },
        ee = { p: _, um: j, m: O, r: L, mt: E, mc: G, pc: S, pbc: k, n: V, o: t }
    let ne, W
    return e && ([ne, W] = e(ee)), { render: z, hydrate: ne, createApp: M_(z, ne) }
}
function us({ effect: t, update: e }, r) {
    t.allowRecurse = e.allowRecurse = r
}
function o0(t, e, r = !1) {
    const n = t.children,
        i = e.children
    if ($e(n) && $e(i))
        for (let s = 0; s < n.length; s++) {
            const o = n[s]
            let a = i[s]
            a.shapeFlag & 1 &&
                !a.dynamicChildren &&
                ((a.patchFlag <= 0 || a.patchFlag === 32) && ((a = i[s] = ki(i[s])), (a.el = o.el)), r || o0(o, a))
        }
}
function D_(t) {
    const e = t.slice(),
        r = [0]
    let n, i, s, o, a
    const l = t.length
    for (n = 0; n < l; n++) {
        const c = t[n]
        if (c !== 0) {
            if (((i = r[r.length - 1]), t[i] < c)) {
                ;(e[n] = i), r.push(n)
                continue
            }
            for (s = 0, o = r.length - 1; s < o; ) (a = (s + o) >> 1), t[r[a]] < c ? (s = a + 1) : (o = a)
            c < t[r[s]] && (s > 0 && (e[n] = r[s - 1]), (r[s] = n))
        }
    }
    for (s = r.length, o = r[s - 1]; s-- > 0; ) (r[s] = o), (o = e[o])
    return r
}
const F_ = (t) => t.__isTeleport,
    Ea = (t) => t && (t.disabled || t.disabled === ""),
    Ih = (t) => typeof SVGElement != "undefined" && t instanceof SVGElement,
    Wu = (t, e) => {
        const r = t && t.to
        return Ht(r) ? (e ? e(r) : null) : r
    },
    V_ = {
        __isTeleport: !0,
        process(t, e, r, n, i, s, o, a, l, c) {
            const {
                    mc: f,
                    pc: u,
                    pbc: p,
                    o: { insert: m, querySelector: y, createText: v, createComment: _ },
                } = c,
                C = Ea(e.props)
            let { shapeFlag: B, children: R, dynamicChildren: U } = e
            if (t == null) {
                const D = (e.el = v("")),
                    Y = (e.anchor = v(""))
                m(D, r, n), m(Y, r, n)
                const J = (e.target = Wu(e.props, y)),
                    te = (e.targetAnchor = v(""))
                J && (m(te, J), (o = o || Ih(J)))
                const G = (de, k) => {
                    B & 16 && f(R, de, k, i, s, o, a, l)
                }
                C ? G(r, Y) : J && G(J, te)
            } else {
                e.el = t.el
                const D = (e.anchor = t.anchor),
                    Y = (e.target = t.target),
                    J = (e.targetAnchor = t.targetAnchor),
                    te = Ea(t.props),
                    G = te ? r : Y,
                    de = te ? D : J
                if (((o = o || Ih(Y)), U ? (p(t.dynamicChildren, U, G, i, s, o, a), o0(t, e, !0)) : l || u(t, e, G, de, i, s, o, a, !1), C))
                    te || Nl(e, r, D, c, 1)
                else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
                    const k = (e.target = Wu(e.props, y))
                    k && Nl(e, k, null, c, 0)
                } else te && Nl(e, Y, J, c, 1)
            }
        },
        remove(t, e, r, n, { um: i, o: { remove: s } }, o) {
            const { shapeFlag: a, children: l, anchor: c, targetAnchor: f, target: u, props: p } = t
            if ((u && s(f), (o || !Ea(p)) && (s(c), a & 16)))
                for (let m = 0; m < l.length; m++) {
                    const y = l[m]
                    i(y, e, r, !0, !!y.dynamicChildren)
                }
        },
        move: Nl,
        hydrate: U_,
    }
function Nl(t, e, r, { o: { insert: n }, m: i }, s = 2) {
    s === 0 && n(t.targetAnchor, e, r)
    const { el: o, anchor: a, shapeFlag: l, children: c, props: f } = t,
        u = s === 2
    if ((u && n(o, e, r), (!u || Ea(f)) && l & 16)) for (let p = 0; p < c.length; p++) i(c[p], e, r, 2)
    u && n(a, e, r)
}
function U_(t, e, r, n, i, s, { o: { nextSibling: o, parentNode: a, querySelector: l } }, c) {
    const f = (e.target = Wu(e.props, l))
    if (f) {
        const u = f._lpa || f.firstChild
        e.shapeFlag & 16 &&
            (Ea(e.props)
                ? ((e.anchor = c(o(t), e, a(t), r, n, i, s)), (e.targetAnchor = u))
                : ((e.anchor = o(t)), (e.targetAnchor = c(u, e, f, r, n, i, s))),
            (f._lpa = e.targetAnchor && o(e.targetAnchor)))
    }
    return e.anchor && o(e.anchor)
}
const H_ = V_,
    a0 = "components",
    q_ = "directives"
function Qt(t, e) {
    return l0(a0, t, !0, e) || t
}
const Sb = Symbol()
function Ie(t) {
    return Ht(t) ? l0(a0, t, !1) || t : t || Sb
}
function j_(t) {
    return l0(q_, t)
}
function l0(t, e, r = !0, n = !1) {
    const i = Or || Xt
    if (i) {
        const s = i.type
        if (t === a0) {
            const a = Q_(s)
            if (a && (a === e || a === Rn(e) || a === Fc(Rn(e)))) return s
        }
        const o = $h(i[t] || s[t], e) || $h(i.appContext[t], e)
        return !o && n ? s : o
    }
}
function $h(t, e) {
    return t && (t[e] || t[Rn(e)] || t[Fc(Rn(e))])
}
const Nt = Symbol(void 0),
    c0 = Symbol(void 0),
    Tr = Symbol(void 0),
    Kf = Symbol(void 0),
    Sa = []
let Ri = null
function K(t = !1) {
    Sa.push((Ri = t ? null : []))
}
function Ab() {
    Sa.pop(), (Ri = Sa[Sa.length - 1] || null)
}
let Ua = 1
function Bh(t) {
    Ua += t
}
function Tb(t) {
    return (t.dynamicChildren = Ua > 0 ? Ri || po : null), Ab(), Ua > 0 && Ri && Ri.push(t), t
}
function ue(t, e, r, n, i, s) {
    return Tb(He(t, e, r, n, i, s, !0))
}
function we(t, e, r, n, i) {
    return Tb(jt(t, e, r, n, i, !0))
}
function Ha(t) {
    return t ? t.__v_isVNode === !0 : !1
}
function yn(t, e) {
    return t.type === e.type && t.key === e.key
}
const jc = "__vInternal",
    Cb = ({ key: t }) => (t != null ? t : null),
    Xl = ({ ref: t, ref_key: e, ref_for: r }) => (t != null ? (Ht(t) || nr(t) || Re(t) ? { i: Or, r: t, k: e, f: !!r } : t) : null)
function He(t, e = null, r = null, n = 0, i = null, s = t === Nt ? 0 : 1, o = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && Cb(e),
        ref: e && Xl(e),
        scopeId: cb,
        slotScopeIds: null,
        children: r,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: n,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
    }
    return (
        a ? (f0(l, r), s & 128 && t.normalize(l)) : r && (l.shapeFlag |= Ht(r) ? 8 : 16),
        Ua > 0 && !o && Ri && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && Ri.push(l),
        l
    )
}
const jt = z_
function z_(t, e = null, r = null, n = 0, i = null, s = !1) {
    if (((!t || t === Sb) && (t = Tr), Ha(t))) {
        const a = Eo(t, e, !0)
        return r && f0(a, r), a
    }
    if ((e3(t) && (t = t.__vccOpts), e)) {
        e = kb(e)
        let { class: a, style: l } = e
        a && !Ht(a) && (e.class = ye(a)), Gt(l) && (Jm(l) && !$e(l) && (l = or({}, l)), (e.style = ni(l)))
    }
    const o = Ht(t) ? 1 : i_(t) ? 128 : F_(t) ? 64 : Gt(t) ? 4 : Re(t) ? 2 : 0
    return He(t, e, r, n, i, o, s, !0)
}
function kb(t) {
    return t ? (Jm(t) || jc in t ? or({}, t) : t) : null
}
function Eo(t, e, r = !1) {
    const { props: n, ref: i, patchFlag: s, children: o } = t,
        a = e ? Je(n || {}, e) : n
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t.type,
        props: a,
        key: a && Cb(a),
        ref: e && e.ref ? (r && i ? ($e(i) ? i.concat(Xl(e)) : [i, Xl(e)]) : Xl(e)) : i,
        scopeId: t.scopeId,
        slotScopeIds: t.slotScopeIds,
        children: o,
        target: t.target,
        targetAnchor: t.targetAnchor,
        staticCount: t.staticCount,
        shapeFlag: t.shapeFlag,
        patchFlag: e && t.type !== Nt ? (s === -1 ? 16 : s | 16) : s,
        dynamicProps: t.dynamicProps,
        dynamicChildren: t.dynamicChildren,
        appContext: t.appContext,
        dirs: t.dirs,
        transition: t.transition,
        component: t.component,
        suspense: t.suspense,
        ssContent: t.ssContent && Eo(t.ssContent),
        ssFallback: t.ssFallback && Eo(t.ssFallback),
        el: t.el,
        anchor: t.anchor,
    }
}
function Ut(t = " ", e = 0) {
    return jt(c0, null, t, e)
}
function Be(t = "", e = !1) {
    return e ? (K(), we(Tr, null, t)) : jt(Tr, null, t)
}
function tn(t) {
    return t == null || typeof t == "boolean" ? jt(Tr) : $e(t) ? jt(Nt, null, t.slice()) : typeof t == "object" ? ki(t) : jt(c0, null, String(t))
}
function ki(t) {
    return t.el === null || t.memo ? t : Eo(t)
}
function f0(t, e) {
    let r = 0
    const { shapeFlag: n } = t
    if (e == null) e = null
    else if ($e(e)) r = 16
    else if (typeof e == "object")
        if (n & 65) {
            const i = e.default
            i && (i._c && (i._d = !1), f0(t, i()), i._c && (i._d = !0))
            return
        } else {
            r = 32
            const i = e._
            !i && !(jc in e) ? (e._ctx = Or) : i === 3 && Or && (Or.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (t.patchFlag |= 1024)))
        }
    else Re(e) ? ((e = { default: e, _ctx: Or }), (r = 32)) : ((e = String(e)), n & 64 ? ((r = 16), (e = [Ut(e)])) : (r = 8))
    ;(t.children = e), (t.shapeFlag |= r)
}
function Je(...t) {
    const e = {}
    for (let r = 0; r < t.length; r++) {
        const n = t[r]
        for (const i in n)
            if (i === "class") e.class !== n.class && (e.class = ye([e.class, n.class]))
            else if (i === "style") e.style = ni([e.style, n.style])
            else if (Rc(i)) {
                const s = e[i],
                    o = n[i]
                o && s !== o && !($e(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o)
            } else i !== "" && (e[i] = n[i])
    }
    return e
}
function dn(t, e, r, n = null) {
    jr(t, e, 7, [r, n])
}
function Pn(t, e, r, n) {
    let i
    const s = r && r[n]
    if ($e(t) || Ht(t)) {
        i = new Array(t.length)
        for (let o = 0, a = t.length; o < a; o++) i[o] = e(t[o], o, void 0, s && s[o])
    } else if (typeof t == "number") {
        i = new Array(t)
        for (let o = 0; o < t; o++) i[o] = e(o + 1, o, void 0, s && s[o])
    } else if (Gt(t))
        if (t[Symbol.iterator]) i = Array.from(t, (o, a) => e(o, a, void 0, s && s[a]))
        else {
            const o = Object.keys(t)
            i = new Array(o.length)
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a]
                i[a] = e(t[c], c, a, s && s[a])
            }
        }
    else i = []
    return r && (r[n] = i), i
}
function ge(t, e, r = {}, n, i) {
    if (Or.isCE) return jt("slot", e === "default" ? null : { name: e }, n && n())
    let s = t[e]
    s && s._c && (s._d = !1), K()
    const o = s && Nb(s(r)),
        a = we(Nt, { key: r.key || `_${e}` }, o || (n ? n() : []), o && t._ === 1 ? 64 : -2)
    return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a
}
function Nb(t) {
    return t.some((e) => (Ha(e) ? !(e.type === Tr || (e.type === Nt && !Nb(e.children))) : !0)) ? t : null
}
const Ju = (t) => (t ? (Pb(t) ? u0(t) || t.proxy : Ju(t.parent)) : null),
    bc = or(Object.create(null), {
        $: (t) => t,
        $el: (t) => t.vnode.el,
        $data: (t) => t.data,
        $props: (t) => t.props,
        $attrs: (t) => t.attrs,
        $slots: (t) => t.slots,
        $refs: (t) => t.refs,
        $parent: (t) => Ju(t.parent),
        $root: (t) => Ju(t.root),
        $emit: (t) => t.emit,
        $options: (t) => bb(t),
        $forceUpdate: (t) => () => rb(t.update),
        $nextTick: (t) => kn.bind(t.proxy),
        $watch: (t) => u_.bind(t),
    }),
    K_ = {
        get({ _: t }, e) {
            const { ctx: r, setupState: n, data: i, props: s, accessCache: o, type: a, appContext: l } = t
            let c
            if (e[0] !== "$") {
                const m = o[e]
                if (m !== void 0)
                    switch (m) {
                        case 1:
                            return n[e]
                        case 2:
                            return i[e]
                        case 4:
                            return r[e]
                        case 3:
                            return s[e]
                    }
                else {
                    if (n !== lt && Ye(n, e)) return (o[e] = 1), n[e]
                    if (i !== lt && Ye(i, e)) return (o[e] = 2), i[e]
                    if ((c = t.propsOptions[0]) && Ye(c, e)) return (o[e] = 3), s[e]
                    if (r !== lt && Ye(r, e)) return (o[e] = 4), r[e]
                    ju && (o[e] = 0)
                }
            }
            const f = bc[e]
            let u, p
            if (f) return e === "$attrs" && Mr(t, "get", e), f(t)
            if ((u = a.__cssModules) && (u = u[e])) return u
            if (r !== lt && Ye(r, e)) return (o[e] = 4), r[e]
            if (((p = l.config.globalProperties), Ye(p, e))) return p[e]
        },
        set({ _: t }, e, r) {
            const { data: n, setupState: i, ctx: s } = t
            if (i !== lt && Ye(i, e)) i[e] = r
            else if (n !== lt && Ye(n, e)) n[e] = r
            else if (Ye(t.props, e)) return !1
            return e[0] === "$" && e.slice(1) in t ? !1 : ((s[e] = r), !0)
        },
        has({ _: { data: t, setupState: e, accessCache: r, ctx: n, appContext: i, propsOptions: s } }, o) {
            let a
            return (
                !!r[o] ||
                (t !== lt && Ye(t, o)) ||
                (e !== lt && Ye(e, o)) ||
                ((a = s[0]) && Ye(a, o)) ||
                Ye(n, o) ||
                Ye(bc, o) ||
                Ye(i.config.globalProperties, o)
            )
        },
    },
    G_ = Eb()
let W_ = 0
function J_(t, e, r) {
    const n = t.type,
        i = (e ? e.appContext : t.appContext) || G_,
        s = {
            uid: W_++,
            vnode: t,
            type: n,
            parent: e,
            appContext: i,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new m2(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(i.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: vb(n, i),
            emitsOptions: lb(n, i),
            emit: null,
            emitted: null,
            propsDefaults: lt,
            inheritAttrs: n.inheritAttrs,
            ctx: lt,
            data: lt,
            props: lt,
            attrs: lt,
            slots: lt,
            refs: lt,
            setupState: lt,
            setupContext: null,
            suspense: r,
            suspenseId: r ? r.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null,
        }
    return (s.ctx = { _: s }), (s.root = e ? e.root : s), (s.emit = Q2.bind(null, s)), t.ce && t.ce(s), s
}
let Xt = null
const zc = () => Xt || Or,
    Ui = (t) => {
        ;(Xt = t), t.scope.on()
    },
    Li = () => {
        Xt && Xt.scope.off(), (Xt = null)
    }
function Pb(t) {
    return t.vnode.shapeFlag & 4
}
let qa = !1
function X_(t, e = !1) {
    qa = e
    const { props: r, children: n } = t.vnode,
        i = Pb(t)
    k_(t, r, i, e), I_(t, n)
    const s = i ? Y_(t, e) : void 0
    return (qa = !1), s
}
function Y_(t, e) {
    const r = t.type
    ;(t.accessCache = Object.create(null)), (t.proxy = Xm(new Proxy(t.ctx, K_)))
    const { setup: n } = r
    if (n) {
        const i = (t.setupContext = n.length > 1 ? $b(t) : null)
        Ui(t), Vo()
        const s = Mi(n, t, 0, [t.props, i])
        if ((Uo(), Li(), Hd(s))) {
            if ((s.then(Li, Li), e))
                return s
                    .then((o) => {
                        Xu(t, o, e)
                    })
                    .catch((o) => {
                        sl(o, t, 0)
                    })
            t.asyncDep = s
        } else Xu(t, s, e)
    } else Ib(t, e)
}
function Xu(t, e, r) {
    Re(e) ? (t.type.__ssrInlineRender ? (t.ssrRender = e) : (t.render = e)) : Gt(e) && (t.setupState = eb(e)), Ib(t, r)
}
let Oh
function Ib(t, e, r) {
    const n = t.type
    if (!t.render) {
        if (!e && Oh && !n.render) {
            const i = n.template
            if (i) {
                const { isCustomElement: s, compilerOptions: o } = t.appContext.config,
                    { delimiters: a, compilerOptions: l } = n,
                    c = or(or({ isCustomElement: s, delimiters: a }, o), l)
                n.render = Oh(i, c)
            }
        }
        t.render = n.render || on
    }
    Ui(t), Vo(), E_(t), Uo(), Li()
}
function Z_(t) {
    return new Proxy(t.attrs, {
        get(e, r) {
            return Mr(t, "get", "$attrs"), e[r]
        },
    })
}
function $b(t) {
    const e = (n) => {
        t.exposed = n || {}
    }
    let r
    return {
        get attrs() {
            return r || (r = Z_(t))
        },
        slots: t.slots,
        emit: t.emit,
        expose: e,
    }
}
function u0(t) {
    if (t.exposed)
        return (
            t.exposeProxy ||
            (t.exposeProxy = new Proxy(eb(Xm(t.exposed)), {
                get(e, r) {
                    if (r in e) return e[r]
                    if (r in bc) return bc[r](t)
                },
            }))
        )
}
function Q_(t) {
    return (Re(t) && t.displayName) || t.name
}
function e3(t) {
    return Re(t) && "__vccOpts" in t
}
const H = (t, e) => W2(t, e, qa)
function VB() {
    return t3().slots
}
function t3() {
    const t = zc()
    return t.setupContext || (t.setupContext = $b(t))
}
function UB(t) {
    const e = zc()
    let r = t()
    return (
        Li(),
        Hd(r) &&
            (r = r.catch((n) => {
                throw (Ui(e), n)
            })),
        [r, () => Ui(e)]
    )
}
function Ae(t, e, r) {
    const n = arguments.length
    return n === 2
        ? Gt(e) && !$e(e)
            ? Ha(e)
                ? jt(t, null, [e])
                : jt(t, e)
            : jt(t, null, e)
        : (n > 3 ? (r = Array.prototype.slice.call(arguments, 2)) : n === 3 && Ha(r) && (r = [r]), jt(t, e, r))
}
const r3 = "3.2.30",
    n3 = "http://www.w3.org/2000/svg",
    Es = typeof document != "undefined" ? document : null,
    Mh = Es && Es.createElement("template"),
    i3 = {
        insert: (t, e, r) => {
            e.insertBefore(t, r || null)
        },
        remove: (t) => {
            const e = t.parentNode
            e && e.removeChild(t)
        },
        createElement: (t, e, r, n) => {
            const i = e ? Es.createElementNS(n3, t) : Es.createElement(t, r ? { is: r } : void 0)
            return t === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i
        },
        createText: (t) => Es.createTextNode(t),
        createComment: (t) => Es.createComment(t),
        setText: (t, e) => {
            t.nodeValue = e
        },
        setElementText: (t, e) => {
            t.textContent = e
        },
        parentNode: (t) => t.parentNode,
        nextSibling: (t) => t.nextSibling,
        querySelector: (t) => Es.querySelector(t),
        setScopeId(t, e) {
            t.setAttribute(e, "")
        },
        cloneNode(t) {
            const e = t.cloneNode(!0)
            return "_value" in t && (e._value = t._value), e
        },
        insertStaticContent(t, e, r, n, i, s) {
            const o = r ? r.previousSibling : e.lastChild
            if (i && (i === s || i.nextSibling)) for (; e.insertBefore(i.cloneNode(!0), r), !(i === s || !(i = i.nextSibling)); );
            else {
                Mh.innerHTML = n ? `<svg>${t}</svg>` : t
                const a = Mh.content
                if (n) {
                    const l = a.firstChild
                    for (; l.firstChild; ) a.appendChild(l.firstChild)
                    a.removeChild(l)
                }
                e.insertBefore(a, r)
            }
            return [o ? o.nextSibling : e.firstChild, r ? r.previousSibling : e.lastChild]
        },
    }
function s3(t, e, r) {
    const n = t._vtc
    n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? t.removeAttribute("class") : r ? t.setAttribute("class", e) : (t.className = e)
}
function o3(t, e, r) {
    const n = t.style,
        i = Ht(r)
    if (r && !i) {
        for (const s in r) Yu(n, s, r[s])
        if (e && !Ht(e)) for (const s in e) r[s] == null && Yu(n, s, "")
    } else {
        const s = n.display
        i ? e !== r && (n.cssText = r) : e && t.removeAttribute("style"), "_vod" in t && (n.display = s)
    }
}
const Rh = /\s*!important$/
function Yu(t, e, r) {
    if ($e(r)) r.forEach((n) => Yu(t, e, n))
    else if (e.startsWith("--")) t.setProperty(e, r)
    else {
        const n = a3(t, e)
        Rh.test(r) ? t.setProperty(Fo(n), r.replace(Rh, ""), "important") : (t[n] = r)
    }
}
const Lh = ["Webkit", "Moz", "ms"],
    Gf = {}
function a3(t, e) {
    const r = Gf[e]
    if (r) return r
    let n = Rn(e)
    if (n !== "filter" && n in t) return (Gf[e] = n)
    n = Fc(n)
    for (let i = 0; i < Lh.length; i++) {
        const s = Lh[i] + n
        if (s in t) return (Gf[e] = s)
    }
    return e
}
const Dh = "http://www.w3.org/1999/xlink"
function l3(t, e, r, n, i) {
    if (n && e.startsWith("xlink:")) r == null ? t.removeAttributeNS(Dh, e.slice(6, e.length)) : t.setAttributeNS(Dh, e, r)
    else {
        const s = i2(e)
        r == null || (s && !$m(r)) ? t.removeAttribute(e) : t.setAttribute(e, s ? "" : r)
    }
}
function c3(t, e, r, n, i, s, o) {
    if (e === "innerHTML" || e === "textContent") {
        n && o(n, i, s), (t[e] = r == null ? "" : r)
        return
    }
    if (e === "value" && t.tagName !== "PROGRESS" && !t.tagName.includes("-")) {
        t._value = r
        const a = r == null ? "" : r
        ;(t.value !== a || t.tagName === "OPTION") && (t.value = a), r == null && t.removeAttribute(e)
        return
    }
    if (r === "" || r == null) {
        const a = typeof t[e]
        if (a === "boolean") {
            t[e] = $m(r)
            return
        } else if (r == null && a === "string") {
            ;(t[e] = ""), t.removeAttribute(e)
            return
        } else if (a === "number") {
            try {
                t[e] = 0
            } catch {}
            t.removeAttribute(e)
            return
        }
    }
    try {
        t[e] = r
    } catch {}
}
let xc = Date.now,
    Bb = !1
if (typeof window != "undefined") {
    xc() > document.createEvent("Event").timeStamp && (xc = () => performance.now())
    const t = navigator.userAgent.match(/firefox\/(\d+)/i)
    Bb = !!(t && Number(t[1]) <= 53)
}
let Zu = 0
const f3 = Promise.resolve(),
    u3 = () => {
        Zu = 0
    },
    d3 = () => Zu || (f3.then(u3), (Zu = xc()))
function h3(t, e, r, n) {
    t.addEventListener(e, r, n)
}
function p3(t, e, r, n) {
    t.removeEventListener(e, r, n)
}
function g3(t, e, r, n, i = null) {
    const s = t._vei || (t._vei = {}),
        o = s[e]
    if (n && o) o.value = n
    else {
        const [a, l] = m3(e)
        if (n) {
            const c = (s[e] = b3(n, i))
            h3(t, a, c, l)
        } else o && (p3(t, a, o, l), (s[e] = void 0))
    }
}
const Fh = /(?:Once|Passive|Capture)$/
function m3(t) {
    let e
    if (Fh.test(t)) {
        e = {}
        let r
        for (; (r = t.match(Fh)); ) (t = t.slice(0, t.length - r[0].length)), (e[r[0].toLowerCase()] = !0)
    }
    return [Fo(t.slice(2)), e]
}
function b3(t, e) {
    const r = (n) => {
        const i = n.timeStamp || xc()
        ;(Bb || i >= r.attached - 1) && jr(x3(n, r.value), e, 5, [n])
    }
    return (r.value = t), (r.attached = d3()), r
}
function x3(t, e) {
    if ($e(e)) {
        const r = t.stopImmediatePropagation
        return (
            (t.stopImmediatePropagation = () => {
                r.call(t), (t._stopped = !0)
            }),
            e.map((n) => (i) => !i._stopped && n && n(i))
        )
    } else return e
}
const Vh = /^on[a-z]/,
    v3 = (t, e, r, n, i = !1, s, o, a, l) => {
        e === "class"
            ? s3(t, n, i)
            : e === "style"
            ? o3(t, r, n)
            : Rc(e)
            ? Fd(e) || g3(t, e, r, n, o)
            : (e[0] === "." ? ((e = e.slice(1)), !0) : e[0] === "^" ? ((e = e.slice(1)), !1) : y3(t, e, n, i))
            ? c3(t, e, n, s, o, a, l)
            : (e === "true-value" ? (t._trueValue = n) : e === "false-value" && (t._falseValue = n), l3(t, e, n, i))
    }
function y3(t, e, r, n) {
    return n
        ? !!(e === "innerHTML" || e === "textContent" || (e in t && Vh.test(e) && Re(r)))
        : e === "spellcheck" ||
          e === "draggable" ||
          e === "form" ||
          (e === "list" && t.tagName === "INPUT") ||
          (e === "type" && t.tagName === "TEXTAREA") ||
          (Vh.test(e) && Ht(r))
        ? !1
        : e in t
}
const _i = "transition",
    Qo = "animation",
    d0 = (t, { slots: e }) => Ae(db, _3(t), e)
d0.displayName = "Transition"
const Ob = {
    name: String,
    type: String,
    css: { type: Boolean, default: !0 },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String,
}
d0.props = or({}, db.props, Ob)
const ds = (t, e = []) => {
        $e(t) ? t.forEach((r) => r(...e)) : t && t(...e)
    },
    Uh = (t) => (t ? ($e(t) ? t.some((e) => e.length > 1) : t.length > 1) : !1)
function _3(t) {
    const e = {}
    for (const d in t) d in Ob || (e[d] = t[d])
    if (t.css === !1) return e
    const {
            name: r = "v",
            type: n,
            duration: i,
            enterFromClass: s = `${r}-enter-from`,
            enterActiveClass: o = `${r}-enter-active`,
            enterToClass: a = `${r}-enter-to`,
            appearFromClass: l = s,
            appearActiveClass: c = o,
            appearToClass: f = a,
            leaveFromClass: u = `${r}-leave-from`,
            leaveActiveClass: p = `${r}-leave-active`,
            leaveToClass: m = `${r}-leave-to`,
        } = t,
        y = w3(i),
        v = y && y[0],
        _ = y && y[1],
        {
            onBeforeEnter: C,
            onEnter: B,
            onEnterCancelled: R,
            onLeave: U,
            onLeaveCancelled: D,
            onBeforeAppear: Y = C,
            onAppear: J = B,
            onAppearCancelled: te = R,
        } = e,
        G = (d, b, w) => {
            Gs(d, b ? f : a), Gs(d, b ? c : o), w && w()
        },
        de = (d, b) => {
            Gs(d, m), Gs(d, p), b && b()
        },
        k = (d) => (b, w) => {
            const E = d ? J : B,
                T = () => G(b, d, w)
            ds(E, [b, T]),
                Hh(() => {
                    Gs(b, d ? l : s), wi(b, d ? f : a), Uh(E) || qh(b, n, v, T)
                })
        }
    return or(e, {
        onBeforeEnter(d) {
            ds(C, [d]), wi(d, s), wi(d, o)
        },
        onBeforeAppear(d) {
            ds(Y, [d]), wi(d, l), wi(d, c)
        },
        onEnter: k(!1),
        onAppear: k(!0),
        onLeave(d, b) {
            const w = () => de(d, b)
            wi(d, u),
                A3(),
                wi(d, p),
                Hh(() => {
                    Gs(d, u), wi(d, m), Uh(U) || qh(d, n, _, w)
                }),
                ds(U, [d, w])
        },
        onEnterCancelled(d) {
            G(d, !1), ds(R, [d])
        },
        onAppearCancelled(d) {
            G(d, !0), ds(te, [d])
        },
        onLeaveCancelled(d) {
            de(d), ds(D, [d])
        },
    })
}
function w3(t) {
    if (t == null) return null
    if (Gt(t)) return [Wf(t.enter), Wf(t.leave)]
    {
        const e = Wf(t)
        return [e, e]
    }
}
function Wf(t) {
    return jd(t)
}
function wi(t, e) {
    e.split(/\s+/).forEach((r) => r && t.classList.add(r)), (t._vtc || (t._vtc = new Set())).add(e)
}
function Gs(t, e) {
    e.split(/\s+/).forEach((n) => n && t.classList.remove(n))
    const { _vtc: r } = t
    r && (r.delete(e), r.size || (t._vtc = void 0))
}
function Hh(t) {
    requestAnimationFrame(() => {
        requestAnimationFrame(t)
    })
}
let E3 = 0
function qh(t, e, r, n) {
    const i = (t._endId = ++E3),
        s = () => {
            i === t._endId && n()
        }
    if (r) return setTimeout(s, r)
    const { type: o, timeout: a, propCount: l } = S3(t, e)
    if (!o) return n()
    const c = o + "end"
    let f = 0
    const u = () => {
            t.removeEventListener(c, p), s()
        },
        p = (m) => {
            m.target === t && ++f >= l && u()
        }
    setTimeout(() => {
        f < l && u()
    }, a + 1),
        t.addEventListener(c, p)
}
function S3(t, e) {
    const r = window.getComputedStyle(t),
        n = (y) => (r[y] || "").split(", "),
        i = n(_i + "Delay"),
        s = n(_i + "Duration"),
        o = jh(i, s),
        a = n(Qo + "Delay"),
        l = n(Qo + "Duration"),
        c = jh(a, l)
    let f = null,
        u = 0,
        p = 0
    e === _i
        ? o > 0 && ((f = _i), (u = o), (p = s.length))
        : e === Qo
        ? c > 0 && ((f = Qo), (u = c), (p = l.length))
        : ((u = Math.max(o, c)), (f = u > 0 ? (o > c ? _i : Qo) : null), (p = f ? (f === _i ? s.length : l.length) : 0))
    const m = f === _i && /\b(transform|all)(,|$)/.test(r[_i + "Property"])
    return { type: f, timeout: u, propCount: p, hasTransform: m }
}
function jh(t, e) {
    for (; t.length < e.length; ) t = t.concat(t)
    return Math.max(...e.map((r, n) => zh(r) + zh(t[n])))
}
function zh(t) {
    return Number(t.slice(0, -1).replace(",", ".")) * 1e3
}
function A3() {
    return document.body.offsetHeight
}
const T3 = ["ctrl", "shift", "alt", "meta"],
    C3 = {
        stop: (t) => t.stopPropagation(),
        prevent: (t) => t.preventDefault(),
        self: (t) => t.target !== t.currentTarget,
        ctrl: (t) => !t.ctrlKey,
        shift: (t) => !t.shiftKey,
        alt: (t) => !t.altKey,
        meta: (t) => !t.metaKey,
        left: (t) => "button" in t && t.button !== 0,
        middle: (t) => "button" in t && t.button !== 1,
        right: (t) => "button" in t && t.button !== 2,
        exact: (t, e) => T3.some((r) => t[`${r}Key`] && !e.includes(r)),
    },
    Kc =
        (t, e) =>
        (r, ...n) => {
            for (let i = 0; i < e.length; i++) {
                const s = C3[e[i]]
                if (s && s(r, e)) return
            }
            return t(r, ...n)
        },
    k3 = or({ patchProp: v3 }, i3)
let Kh
function N3() {
    return Kh || (Kh = R_(k3))
}
const HB = (...t) => {
    const e = N3().createApp(...t),
        { mount: r } = e
    return (
        (e.mount = (n) => {
            const i = P3(n)
            if (!i) return
            const s = e._component
            !Re(s) && !s.render && !s.template && (s.template = i.innerHTML), (i.innerHTML = "")
            const o = r(i, !1, i instanceof SVGElement)
            return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o
        }),
        e
    )
}
function P3(t) {
    return Ht(t) ? document.querySelector(t) : t
}
/*!
 * vue-router v4.0.12
 * (c) 2021 Eduardo San Martin Morote
 * @license MIT
 */ const Mb = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol",
    Ho = (t) => (Mb ? Symbol(t) : "_vr_" + t),
    I3 = Ho("rvlm"),
    Gh = Ho("rvd"),
    h0 = Ho("r"),
    p0 = Ho("rl"),
    Qu = Ho("rvl"),
    no = typeof window != "undefined"
function $3(t) {
    return t.__esModule || (Mb && t[Symbol.toStringTag] === "Module")
}
const at = Object.assign
function Jf(t, e) {
    const r = {}
    for (const n in e) {
        const i = e[n]
        r[n] = Array.isArray(i) ? i.map(t) : t(i)
    }
    return r
}
const Aa = () => {},
    B3 = /\/$/,
    O3 = (t) => t.replace(B3, "")
function Xf(t, e, r = "/") {
    let n,
        i = {},
        s = "",
        o = ""
    const a = e.indexOf("?"),
        l = e.indexOf("#", a > -1 ? a : 0)
    return (
        a > -1 && ((n = e.slice(0, a)), (s = e.slice(a + 1, l > -1 ? l : e.length)), (i = t(s))),
        l > -1 && ((n = n || e.slice(0, l)), (o = e.slice(l, e.length))),
        (n = D3(n != null ? n : e, r)),
        { fullPath: n + (s && "?") + s + o, path: n, query: i, hash: o }
    )
}
function M3(t, e) {
    const r = e.query ? t(e.query) : ""
    return e.path + (r && "?") + r + (e.hash || "")
}
function Wh(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/"
}
function R3(t, e, r) {
    const n = e.matched.length - 1,
        i = r.matched.length - 1
    return n > -1 && n === i && So(e.matched[n], r.matched[i]) && Rb(e.params, r.params) && t(e.query) === t(r.query) && e.hash === r.hash
}
function So(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e)
}
function Rb(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length) return !1
    for (const r in t) if (!L3(t[r], e[r])) return !1
    return !0
}
function L3(t, e) {
    return Array.isArray(t) ? Jh(t, e) : Array.isArray(e) ? Jh(e, t) : t === e
}
function Jh(t, e) {
    return Array.isArray(e) ? t.length === e.length && t.every((r, n) => r === e[n]) : t.length === 1 && t[0] === e
}
function D3(t, e) {
    if (t.startsWith("/")) return t
    if (!t) return e
    const r = e.split("/"),
        n = t.split("/")
    let i = r.length - 1,
        s,
        o
    for (s = 0; s < n.length; s++)
        if (((o = n[s]), !(i === 1 || o === ".")))
            if (o === "..") i--
            else break
    return r.slice(0, i).join("/") + "/" + n.slice(s - (s === n.length ? 1 : 0)).join("/")
}
var ja
;(function (t) {
    ;(t.pop = "pop"), (t.push = "push")
})(ja || (ja = {}))
var Ta
;(function (t) {
    ;(t.back = "back"), (t.forward = "forward"), (t.unknown = "")
})(Ta || (Ta = {}))
function F3(t) {
    if (!t)
        if (no) {
            const e = document.querySelector("base")
            ;(t = (e && e.getAttribute("href")) || "/"), (t = t.replace(/^\w+:\/\/[^\/]+/, ""))
        } else t = "/"
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), O3(t)
}
const V3 = /^[^#]+#/
function U3(t, e) {
    return t.replace(V3, "#") + e
}
function H3(t, e) {
    const r = document.documentElement.getBoundingClientRect(),
        n = t.getBoundingClientRect()
    return { behavior: e.behavior, left: n.left - r.left - (e.left || 0), top: n.top - r.top - (e.top || 0) }
}
const Gc = () => ({ left: window.pageXOffset, top: window.pageYOffset })
function q3(t) {
    let e
    if ("el" in t) {
        const r = t.el,
            n = typeof r == "string" && r.startsWith("#"),
            i = typeof r == "string" ? (n ? document.getElementById(r.slice(1)) : document.querySelector(r)) : r
        if (!i) return
        e = H3(i, t)
    } else e = t
    "scrollBehavior" in document.documentElement.style
        ? window.scrollTo(e)
        : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset)
}
function Xh(t, e) {
    return (history.state ? history.state.position - e : -1) + t
}
const ed = new Map()
function j3(t, e) {
    ed.set(t, e)
}
function z3(t) {
    const e = ed.get(t)
    return ed.delete(t), e
}
let K3 = () => location.protocol + "//" + location.host
function Lb(t, e) {
    const { pathname: r, search: n, hash: i } = e,
        s = t.indexOf("#")
    if (s > -1) {
        let a = i.includes(t.slice(s)) ? t.slice(s).length : 1,
            l = i.slice(a)
        return l[0] !== "/" && (l = "/" + l), Wh(l, "")
    }
    return Wh(r, t) + n + i
}
function G3(t, e, r, n) {
    let i = [],
        s = [],
        o = null
    const a = ({ state: p }) => {
        const m = Lb(t, location),
            y = r.value,
            v = e.value
        let _ = 0
        if (p) {
            if (((r.value = m), (e.value = p), o && o === y)) {
                o = null
                return
            }
            _ = v ? p.position - v.position : 0
        } else n(m)
        i.forEach((C) => {
            C(r.value, y, { delta: _, type: ja.pop, direction: _ ? (_ > 0 ? Ta.forward : Ta.back) : Ta.unknown })
        })
    }
    function l() {
        o = r.value
    }
    function c(p) {
        i.push(p)
        const m = () => {
            const y = i.indexOf(p)
            y > -1 && i.splice(y, 1)
        }
        return s.push(m), m
    }
    function f() {
        const { history: p } = window
        !p.state || p.replaceState(at({}, p.state, { scroll: Gc() }), "")
    }
    function u() {
        for (const p of s) p()
        ;(s = []), window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", f)
    }
    return window.addEventListener("popstate", a), window.addEventListener("beforeunload", f), { pauseListeners: l, listen: c, destroy: u }
}
function Yh(t, e, r, n = !1, i = !1) {
    return { back: t, current: e, forward: r, replaced: n, position: window.history.length, scroll: i ? Gc() : null }
}
function W3(t) {
    const { history: e, location: r } = window,
        n = { value: Lb(t, r) },
        i = { value: e.state }
    i.value || s(n.value, { back: null, current: n.value, forward: null, position: e.length - 1, replaced: !0, scroll: null }, !0)
    function s(l, c, f) {
        const u = t.indexOf("#"),
            p = u > -1 ? (r.host && document.querySelector("base") ? t : t.slice(u)) + l : K3() + t + l
        try {
            e[f ? "replaceState" : "pushState"](c, "", p), (i.value = c)
        } catch (m) {
            console.error(m), r[f ? "replace" : "assign"](p)
        }
    }
    function o(l, c) {
        const f = at({}, e.state, Yh(i.value.back, l, i.value.forward, !0), c, { position: i.value.position })
        s(l, f, !0), (n.value = l)
    }
    function a(l, c) {
        const f = at({}, i.value, e.state, { forward: l, scroll: Gc() })
        s(f.current, f, !0)
        const u = at({}, Yh(n.value, l, null), { position: f.position + 1 }, c)
        s(l, u, !1), (n.value = l)
    }
    return { location: n, state: i, push: a, replace: o }
}
function J3(t) {
    t = F3(t)
    const e = W3(t),
        r = G3(t, e.state, e.location, e.replace)
    function n(s, o = !0) {
        o || r.pauseListeners(), history.go(s)
    }
    const i = at({ location: "", base: t, go: n, createHref: U3.bind(null, t) }, e, r)
    return (
        Object.defineProperty(i, "location", { enumerable: !0, get: () => e.location.value }),
        Object.defineProperty(i, "state", { enumerable: !0, get: () => e.state.value }),
        i
    )
}
function qB(t) {
    return (t = location.host ? t || location.pathname + location.search : ""), t.includes("#") || (t += "#"), J3(t)
}
function X3(t) {
    return typeof t == "string" || (t && typeof t == "object")
}
function Db(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const Ei = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 },
    Fb = Ho("nf")
var Zh
;(function (t) {
    ;(t[(t.aborted = 4)] = "aborted"), (t[(t.cancelled = 8)] = "cancelled"), (t[(t.duplicated = 16)] = "duplicated")
})(Zh || (Zh = {}))
function Ao(t, e) {
    return at(new Error(), { type: t, [Fb]: !0 }, e)
}
function hs(t, e) {
    return t instanceof Error && Fb in t && (e == null || !!(t.type & e))
}
const Qh = "[^/]+?",
    Y3 = { sensitive: !1, strict: !1, start: !0, end: !0 },
    Z3 = /[.+*?^${}()[\]/\\]/g
function Q3(t, e) {
    const r = at({}, Y3, e),
        n = []
    let i = r.start ? "^" : ""
    const s = []
    for (const c of t) {
        const f = c.length ? [] : [90]
        r.strict && !c.length && (i += "/")
        for (let u = 0; u < c.length; u++) {
            const p = c[u]
            let m = 40 + (r.sensitive ? 0.25 : 0)
            if (p.type === 0) u || (i += "/"), (i += p.value.replace(Z3, "\\$&")), (m += 40)
            else if (p.type === 1) {
                const { value: y, repeatable: v, optional: _, regexp: C } = p
                s.push({ name: y, repeatable: v, optional: _ })
                const B = C || Qh
                if (B !== Qh) {
                    m += 10
                    try {
                        new RegExp(`(${B})`)
                    } catch (U) {
                        throw new Error(`Invalid custom RegExp for param "${y}" (${B}): ` + U.message)
                    }
                }
                let R = v ? `((?:${B})(?:/(?:${B}))*)` : `(${B})`
                u || (R = _ && c.length < 2 ? `(?:/${R})` : "/" + R),
                    _ && (R += "?"),
                    (i += R),
                    (m += 20),
                    _ && (m += -8),
                    v && (m += -20),
                    B === ".*" && (m += -50)
            }
            f.push(m)
        }
        n.push(f)
    }
    if (r.strict && r.end) {
        const c = n.length - 1
        n[c][n[c].length - 1] += 0.7000000000000001
    }
    r.strict || (i += "/?"), r.end ? (i += "$") : r.strict && (i += "(?:/|$)")
    const o = new RegExp(i, r.sensitive ? "" : "i")
    function a(c) {
        const f = c.match(o),
            u = {}
        if (!f) return null
        for (let p = 1; p < f.length; p++) {
            const m = f[p] || "",
                y = s[p - 1]
            u[y.name] = m && y.repeatable ? m.split("/") : m
        }
        return u
    }
    function l(c) {
        let f = "",
            u = !1
        for (const p of t) {
            ;(!u || !f.endsWith("/")) && (f += "/"), (u = !1)
            for (const m of p)
                if (m.type === 0) f += m.value
                else if (m.type === 1) {
                    const { value: y, repeatable: v, optional: _ } = m,
                        C = y in c ? c[y] : ""
                    if (Array.isArray(C) && !v) throw new Error(`Provided param "${y}" is an array but it is not repeatable (* or + modifiers)`)
                    const B = Array.isArray(C) ? C.join("/") : C
                    if (!B)
                        if (_) p.length < 2 && (f.endsWith("/") ? (f = f.slice(0, -1)) : (u = !0))
                        else throw new Error(`Missing required param "${y}"`)
                    f += B
                }
        }
        return f
    }
    return { re: o, score: n, keys: s, parse: a, stringify: l }
}
function ew(t, e) {
    let r = 0
    for (; r < t.length && r < e.length; ) {
        const n = e[r] - t[r]
        if (n) return n
        r++
    }
    return t.length < e.length
        ? t.length === 1 && t[0] === 40 + 40
            ? -1
            : 1
        : t.length > e.length
        ? e.length === 1 && e[0] === 40 + 40
            ? 1
            : -1
        : 0
}
function tw(t, e) {
    let r = 0
    const n = t.score,
        i = e.score
    for (; r < n.length && r < i.length; ) {
        const s = ew(n[r], i[r])
        if (s) return s
        r++
    }
    return i.length - n.length
}
const rw = { type: 0, value: "" },
    nw = /[a-zA-Z0-9_]/
function iw(t) {
    if (!t) return [[]]
    if (t === "/") return [[rw]]
    if (!t.startsWith("/")) throw new Error(`Invalid path "${t}"`)
    function e(m) {
        throw new Error(`ERR (${r})/"${c}": ${m}`)
    }
    let r = 0,
        n = r
    const i = []
    let s
    function o() {
        s && i.push(s), (s = [])
    }
    let a = 0,
        l,
        c = "",
        f = ""
    function u() {
        !c ||
            (r === 0
                ? s.push({ type: 0, value: c })
                : r === 1 || r === 2 || r === 3
                ? (s.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
                  s.push({ type: 1, value: c, regexp: f, repeatable: l === "*" || l === "+", optional: l === "*" || l === "?" }))
                : e("Invalid state to consume buffer"),
            (c = ""))
    }
    function p() {
        c += l
    }
    for (; a < t.length; ) {
        if (((l = t[a++]), l === "\\" && r !== 2)) {
            ;(n = r), (r = 4)
            continue
        }
        switch (r) {
            case 0:
                l === "/" ? (c && u(), o()) : l === ":" ? (u(), (r = 1)) : p()
                break
            case 4:
                p(), (r = n)
                break
            case 1:
                l === "(" ? (r = 2) : nw.test(l) ? p() : (u(), (r = 0), l !== "*" && l !== "?" && l !== "+" && a--)
                break
            case 2:
                l === ")" ? (f[f.length - 1] == "\\" ? (f = f.slice(0, -1) + l) : (r = 3)) : (f += l)
                break
            case 3:
                u(), (r = 0), l !== "*" && l !== "?" && l !== "+" && a--, (f = "")
                break
            default:
                e("Unknown state")
                break
        }
    }
    return r === 2 && e(`Unfinished custom RegExp for param "${c}"`), u(), o(), i
}
function sw(t, e, r) {
    const n = Q3(iw(t.path), r),
        i = at(n, { record: t, parent: e, children: [], alias: [] })
    return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i), i
}
function ow(t, e) {
    const r = [],
        n = new Map()
    e = tp({ strict: !1, end: !0, sensitive: !1 }, e)
    function i(f) {
        return n.get(f)
    }
    function s(f, u, p) {
        const m = !p,
            y = lw(f)
        y.aliasOf = p && p.record
        const v = tp(e, f),
            _ = [y]
        if ("alias" in f) {
            const R = typeof f.alias == "string" ? [f.alias] : f.alias
            for (const U of R) _.push(at({}, y, { components: p ? p.record.components : y.components, path: U, aliasOf: p ? p.record : y }))
        }
        let C, B
        for (const R of _) {
            const { path: U } = R
            if (u && U[0] !== "/") {
                const D = u.record.path,
                    Y = D[D.length - 1] === "/" ? "" : "/"
                R.path = u.record.path + (U && Y + U)
            }
            if (
                ((C = sw(R, u, v)),
                p ? p.alias.push(C) : ((B = B || C), B !== C && B.alias.push(C), m && f.name && !ep(C) && o(f.name)),
                "children" in y)
            ) {
                const D = y.children
                for (let Y = 0; Y < D.length; Y++) s(D[Y], C, p && p.children[Y])
            }
            ;(p = p || C), l(C)
        }
        return B
            ? () => {
                  o(B)
              }
            : Aa
    }
    function o(f) {
        if (Db(f)) {
            const u = n.get(f)
            u && (n.delete(f), r.splice(r.indexOf(u), 1), u.children.forEach(o), u.alias.forEach(o))
        } else {
            const u = r.indexOf(f)
            u > -1 && (r.splice(u, 1), f.record.name && n.delete(f.record.name), f.children.forEach(o), f.alias.forEach(o))
        }
    }
    function a() {
        return r
    }
    function l(f) {
        let u = 0
        for (; u < r.length && tw(f, r[u]) >= 0; ) u++
        r.splice(u, 0, f), f.record.name && !ep(f) && n.set(f.record.name, f)
    }
    function c(f, u) {
        let p,
            m = {},
            y,
            v
        if ("name" in f && f.name) {
            if (((p = n.get(f.name)), !p)) throw Ao(1, { location: f })
            ;(v = p.record.name),
                (m = at(
                    aw(
                        u.params,
                        p.keys.filter((B) => !B.optional).map((B) => B.name)
                    ),
                    f.params
                )),
                (y = p.stringify(m))
        } else if ("path" in f) (y = f.path), (p = r.find((B) => B.re.test(y))), p && ((m = p.parse(y)), (v = p.record.name))
        else {
            if (((p = u.name ? n.get(u.name) : r.find((B) => B.re.test(u.path))), !p)) throw Ao(1, { location: f, currentLocation: u })
            ;(v = p.record.name), (m = at({}, u.params, f.params)), (y = p.stringify(m))
        }
        const _ = []
        let C = p
        for (; C; ) _.unshift(C.record), (C = C.parent)
        return { name: v, path: y, params: m, matched: _, meta: fw(_) }
    }
    return t.forEach((f) => s(f)), { addRoute: s, resolve: c, removeRoute: o, getRoutes: a, getRecordMatcher: i }
}
function aw(t, e) {
    const r = {}
    for (const n of e) n in t && (r[n] = t[n])
    return r
}
function lw(t) {
    return {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: void 0,
        beforeEnter: t.beforeEnter,
        props: cw(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set(),
        updateGuards: new Set(),
        enterCallbacks: {},
        components: "components" in t ? t.components || {} : { default: t.component },
    }
}
function cw(t) {
    const e = {},
        r = t.props || !1
    if ("component" in t) e.default = r
    else for (const n in t.components) e[n] = typeof r == "boolean" ? r : r[n]
    return e
}
function ep(t) {
    for (; t; ) {
        if (t.record.aliasOf) return !0
        t = t.parent
    }
    return !1
}
function fw(t) {
    return t.reduce((e, r) => at(e, r.meta), {})
}
function tp(t, e) {
    const r = {}
    for (const n in t) r[n] = n in e ? e[n] : t[n]
    return r
}
const Vb = /#/g,
    uw = /&/g,
    dw = /\//g,
    hw = /=/g,
    pw = /\?/g,
    Ub = /\+/g,
    gw = /%5B/g,
    mw = /%5D/g,
    Hb = /%5E/g,
    bw = /%60/g,
    qb = /%7B/g,
    xw = /%7C/g,
    jb = /%7D/g,
    vw = /%20/g
function g0(t) {
    return encodeURI("" + t)
        .replace(xw, "|")
        .replace(gw, "[")
        .replace(mw, "]")
}
function yw(t) {
    return g0(t).replace(qb, "{").replace(jb, "}").replace(Hb, "^")
}
function td(t) {
    return g0(t)
        .replace(Ub, "%2B")
        .replace(vw, "+")
        .replace(Vb, "%23")
        .replace(uw, "%26")
        .replace(bw, "`")
        .replace(qb, "{")
        .replace(jb, "}")
        .replace(Hb, "^")
}
function _w(t) {
    return td(t).replace(hw, "%3D")
}
function ww(t) {
    return g0(t).replace(Vb, "%23").replace(pw, "%3F")
}
function Ew(t) {
    return t == null ? "" : ww(t).replace(dw, "%2F")
}
function vc(t) {
    try {
        return decodeURIComponent("" + t)
    } catch {}
    return "" + t
}
function Sw(t) {
    const e = {}
    if (t === "" || t === "?") return e
    const n = (t[0] === "?" ? t.slice(1) : t).split("&")
    for (let i = 0; i < n.length; ++i) {
        const s = n[i].replace(Ub, " "),
            o = s.indexOf("="),
            a = vc(o < 0 ? s : s.slice(0, o)),
            l = o < 0 ? null : vc(s.slice(o + 1))
        if (a in e) {
            let c = e[a]
            Array.isArray(c) || (c = e[a] = [c]), c.push(l)
        } else e[a] = l
    }
    return e
}
function rp(t) {
    let e = ""
    for (let r in t) {
        const n = t[r]
        if (((r = _w(r)), n == null)) {
            n !== void 0 && (e += (e.length ? "&" : "") + r)
            continue
        }
        ;(Array.isArray(n) ? n.map((s) => s && td(s)) : [n && td(n)]).forEach((s) => {
            s !== void 0 && ((e += (e.length ? "&" : "") + r), s != null && (e += "=" + s))
        })
    }
    return e
}
function Aw(t) {
    const e = {}
    for (const r in t) {
        const n = t[r]
        n !== void 0 && (e[r] = Array.isArray(n) ? n.map((i) => (i == null ? null : "" + i)) : n == null ? n : "" + n)
    }
    return e
}
function ea() {
    let t = []
    function e(n) {
        return (
            t.push(n),
            () => {
                const i = t.indexOf(n)
                i > -1 && t.splice(i, 1)
            }
        )
    }
    function r() {
        t = []
    }
    return { add: e, list: () => t, reset: r }
}
function Ni(t, e, r, n, i) {
    const s = n && (n.enterCallbacks[i] = n.enterCallbacks[i] || [])
    return () =>
        new Promise((o, a) => {
            const l = (u) => {
                    u === !1
                        ? a(Ao(4, { from: r, to: e }))
                        : u instanceof Error
                        ? a(u)
                        : X3(u)
                        ? a(Ao(2, { from: e, to: u }))
                        : (s && n.enterCallbacks[i] === s && typeof u == "function" && s.push(u), o())
                },
                c = t.call(n && n.instances[i], e, r, l)
            let f = Promise.resolve(c)
            t.length < 3 && (f = f.then(l)), f.catch((u) => a(u))
        })
}
function Yf(t, e, r, n) {
    const i = []
    for (const s of t)
        for (const o in s.components) {
            let a = s.components[o]
            if (!(e !== "beforeRouteEnter" && !s.instances[o]))
                if (Tw(a)) {
                    const c = (a.__vccOpts || a)[e]
                    c && i.push(Ni(c, r, n, s, o))
                } else {
                    let l = a()
                    i.push(() =>
                        l.then((c) => {
                            if (!c) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`))
                            const f = $3(c) ? c.default : c
                            s.components[o] = f
                            const p = (f.__vccOpts || f)[e]
                            return p && Ni(p, r, n, s, o)()
                        })
                    )
                }
        }
    return i
}
function Tw(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t
}
function np(t) {
    const e = sr(h0),
        r = sr(p0),
        n = H(() => e.resolve(ya(t.to))),
        i = H(() => {
            const { matched: l } = n.value,
                { length: c } = l,
                f = l[c - 1],
                u = r.matched
            if (!f || !u.length) return -1
            const p = u.findIndex(So.bind(null, f))
            if (p > -1) return p
            const m = ip(l[c - 2])
            return c > 1 && ip(f) === m && u[u.length - 1].path !== m ? u.findIndex(So.bind(null, l[c - 2])) : p
        }),
        s = H(() => i.value > -1 && Pw(r.params, n.value.params)),
        o = H(() => i.value > -1 && i.value === r.matched.length - 1 && Rb(r.params, n.value.params))
    function a(l = {}) {
        return Nw(l) ? e[ya(t.replace) ? "replace" : "push"](ya(t.to)).catch(Aa) : Promise.resolve()
    }
    return { route: n, href: H(() => n.value.href), isActive: s, isExactActive: o, navigate: a }
}
const Cw = be({
        name: "RouterLink",
        props: {
            to: { type: [String, Object], required: !0 },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: { type: String, default: "page" },
        },
        useLink: np,
        setup(t, { slots: e }) {
            const r = Ln(np(t)),
                { options: n } = sr(h0),
                i = H(() => ({
                    [sp(t.activeClass, n.linkActiveClass, "router-link-active")]: r.isActive,
                    [sp(t.exactActiveClass, n.linkExactActiveClass, "router-link-exact-active")]: r.isExactActive,
                }))
            return () => {
                const s = e.default && e.default(r)
                return t.custom
                    ? s
                    : Ae(
                          "a",
                          { "aria-current": r.isExactActive ? t.ariaCurrentValue : null, href: r.href, onClick: r.navigate, class: i.value },
                          s
                      )
            }
        },
    }),
    kw = Cw
function Nw(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target")
            if (/\b_blank\b/i.test(e)) return
        }
        return t.preventDefault && t.preventDefault(), !0
    }
}
function Pw(t, e) {
    for (const r in e) {
        const n = e[r],
            i = t[r]
        if (typeof n == "string") {
            if (n !== i) return !1
        } else if (!Array.isArray(i) || i.length !== n.length || n.some((s, o) => s !== i[o])) return !1
    }
    return !0
}
function ip(t) {
    return t ? (t.aliasOf ? t.aliasOf.path : t.path) : ""
}
const sp = (t, e, r) => (t != null ? t : e != null ? e : r),
    Iw = be({
        name: "RouterView",
        inheritAttrs: !1,
        props: { name: { type: String, default: "default" }, route: Object },
        setup(t, { attrs: e, slots: r }) {
            const n = sr(Qu),
                i = H(() => t.route || n.value),
                s = sr(Gh, 0),
                o = H(() => i.value.matched[s])
            Nn(Gh, s + 1), Nn(I3, o), Nn(Qu, i)
            const a = Ue()
            return (
                It(
                    () => [a.value, o.value, t.name],
                    ([l, c, f], [u, p, m]) => {
                        c &&
                            ((c.instances[f] = l),
                            p &&
                                p !== c &&
                                l &&
                                l === u &&
                                (c.leaveGuards.size || (c.leaveGuards = p.leaveGuards),
                                c.updateGuards.size || (c.updateGuards = p.updateGuards))),
                            l && c && (!p || !So(c, p) || !u) && (c.enterCallbacks[f] || []).forEach((y) => y(l))
                    },
                    { flush: "post" }
                ),
                () => {
                    const l = i.value,
                        c = o.value,
                        f = c && c.components[t.name],
                        u = t.name
                    if (!f) return op(r.default, { Component: f, route: l })
                    const p = c.props[t.name],
                        m = p ? (p === !0 ? l.params : typeof p == "function" ? p(l) : p) : null,
                        v = Ae(
                            f,
                            at({}, m, e, {
                                onVnodeUnmounted: (_) => {
                                    _.component.isUnmounted && (c.instances[u] = null)
                                },
                                ref: a,
                            })
                        )
                    return op(r.default, { Component: v, route: l }) || v
                }
            )
        },
    })
function op(t, e) {
    if (!t) return null
    const r = t(e)
    return r.length === 1 ? r[0] : r
}
const $w = Iw
function jB(t) {
    const e = ow(t.routes, t),
        r = t.parseQuery || Sw,
        n = t.stringifyQuery || rp,
        i = t.history,
        s = ea(),
        o = ea(),
        a = ea(),
        l = j2(Ei)
    let c = Ei
    no && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual")
    const f = Jf.bind(null, (h) => "" + h),
        u = Jf.bind(null, Ew),
        p = Jf.bind(null, vc)
    function m(h, P) {
        let M, V
        return Db(h) ? ((M = e.getRecordMatcher(h)), (V = P)) : (V = h), e.addRoute(V, M)
    }
    function y(h) {
        const P = e.getRecordMatcher(h)
        P && e.removeRoute(P)
    }
    function v() {
        return e.getRoutes().map((h) => h.record)
    }
    function _(h) {
        return !!e.getRecordMatcher(h)
    }
    function C(h, P) {
        if (((P = at({}, P || l.value)), typeof h == "string")) {
            const W = Xf(r, h, P.path),
                N = e.resolve({ path: W.path }, P),
                I = i.createHref(W.fullPath)
            return at(W, N, { params: p(N.params), hash: vc(W.hash), redirectedFrom: void 0, href: I })
        }
        let M
        if ("path" in h) M = at({}, h, { path: Xf(r, h.path, P.path).path })
        else {
            const W = at({}, h.params)
            for (const N in W) W[N] == null && delete W[N]
            ;(M = at({}, h, { params: u(h.params) })), (P.params = u(P.params))
        }
        const V = e.resolve(M, P),
            z = h.hash || ""
        V.params = f(p(V.params))
        const ee = M3(n, at({}, h, { hash: yw(z), path: V.path })),
            ne = i.createHref(ee)
        return at({ fullPath: ee, hash: z, query: n === rp ? Aw(h.query) : h.query || {} }, V, { redirectedFrom: void 0, href: ne })
    }
    function B(h) {
        return typeof h == "string" ? Xf(r, h, l.value.path) : at({}, h)
    }
    function R(h, P) {
        if (c !== h) return Ao(8, { from: P, to: h })
    }
    function U(h) {
        return J(h)
    }
    function D(h) {
        return U(at(B(h), { replace: !0 }))
    }
    function Y(h) {
        const P = h.matched[h.matched.length - 1]
        if (P && P.redirect) {
            const { redirect: M } = P
            let V = typeof M == "function" ? M(h) : M
            return (
                typeof V == "string" && ((V = V.includes("?") || V.includes("#") ? (V = B(V)) : { path: V }), (V.params = {})),
                at({ query: h.query, hash: h.hash, params: h.params }, V)
            )
        }
    }
    function J(h, P) {
        const M = (c = C(h)),
            V = l.value,
            z = h.state,
            ee = h.force,
            ne = h.replace === !0,
            W = Y(M)
        if (W) return J(at(B(W), { state: z, force: ee, replace: ne }), P || M)
        const N = M
        N.redirectedFrom = P
        let I
        return (
            !ee && R3(n, V, M) && ((I = Ao(16, { to: N, from: V })), g(V, V, !0, !1)),
            (I ? Promise.resolve(I) : G(N, V))
                .catch((q) => (hs(q) ? q : A(q, N, V)))
                .then((q) => {
                    if (q) {
                        if (hs(q, 2)) return J(at(B(q.to), { state: z, force: ee, replace: ne }), P || N)
                    } else q = k(N, V, !0, ne, z)
                    return de(N, V, q), q
                })
        )
    }
    function te(h, P) {
        const M = R(h, P)
        return M ? Promise.reject(M) : Promise.resolve()
    }
    function G(h, P) {
        let M
        const [V, z, ee] = Bw(h, P)
        M = Yf(V.reverse(), "beforeRouteLeave", h, P)
        for (const W of V)
            W.leaveGuards.forEach((N) => {
                M.push(Ni(N, h, P))
            })
        const ne = te.bind(null, h, P)
        return (
            M.push(ne),
            Ws(M)
                .then(() => {
                    M = []
                    for (const W of s.list()) M.push(Ni(W, h, P))
                    return M.push(ne), Ws(M)
                })
                .then(() => {
                    M = Yf(z, "beforeRouteUpdate", h, P)
                    for (const W of z)
                        W.updateGuards.forEach((N) => {
                            M.push(Ni(N, h, P))
                        })
                    return M.push(ne), Ws(M)
                })
                .then(() => {
                    M = []
                    for (const W of h.matched)
                        if (W.beforeEnter && !P.matched.includes(W))
                            if (Array.isArray(W.beforeEnter)) for (const N of W.beforeEnter) M.push(Ni(N, h, P))
                            else M.push(Ni(W.beforeEnter, h, P))
                    return M.push(ne), Ws(M)
                })
                .then(() => (h.matched.forEach((W) => (W.enterCallbacks = {})), (M = Yf(ee, "beforeRouteEnter", h, P)), M.push(ne), Ws(M)))
                .then(() => {
                    M = []
                    for (const W of o.list()) M.push(Ni(W, h, P))
                    return M.push(ne), Ws(M)
                })
                .catch((W) => (hs(W, 8) ? W : Promise.reject(W)))
        )
    }
    function de(h, P, M) {
        for (const V of a.list()) V(h, P, M)
    }
    function k(h, P, M, V, z) {
        const ee = R(h, P)
        if (ee) return ee
        const ne = P === Ei,
            W = no ? history.state : {}
        M && (V || ne ? i.replace(h.fullPath, at({ scroll: ne && W && W.scroll }, z)) : i.push(h.fullPath, z)),
            (l.value = h),
            g(h, P, M, ne),
            S()
    }
    let d
    function b() {
        d = i.listen((h, P, M) => {
            const V = C(h),
                z = Y(V)
            if (z) {
                J(at(z, { replace: !0 }), V).catch(Aa)
                return
            }
            c = V
            const ee = l.value
            no && j3(Xh(ee.fullPath, M.delta), Gc()),
                G(V, ee)
                    .catch((ne) =>
                        hs(ne, 12)
                            ? ne
                            : hs(ne, 2)
                            ? (J(ne.to, V)
                                  .then((W) => {
                                      hs(W, 20) && !M.delta && M.type === ja.pop && i.go(-1, !1)
                                  })
                                  .catch(Aa),
                              Promise.reject())
                            : (M.delta && i.go(-M.delta, !1), A(ne, V, ee))
                    )
                    .then((ne) => {
                        ;(ne = ne || k(V, ee, !1)),
                            ne && (M.delta ? i.go(-M.delta, !1) : M.type === ja.pop && hs(ne, 20) && i.go(-1, !1)),
                            de(V, ee, ne)
                    })
                    .catch(Aa)
        })
    }
    let w = ea(),
        E = ea(),
        T
    function A(h, P, M) {
        S(h)
        const V = E.list()
        return V.length ? V.forEach((z) => z(h, P, M)) : console.error(h), Promise.reject(h)
    }
    function $() {
        return T && l.value !== Ei
            ? Promise.resolve()
            : new Promise((h, P) => {
                  w.add([h, P])
              })
    }
    function S(h) {
        T || ((T = !0), b(), w.list().forEach(([P, M]) => (h ? M(h) : P())), w.reset())
    }
    function g(h, P, M, V) {
        const { scrollBehavior: z } = t
        if (!no || !z) return Promise.resolve()
        const ee = (!M && z3(Xh(h.fullPath, 0))) || ((V || !M) && history.state && history.state.scroll) || null
        return kn()
            .then(() => z(h, P, ee))
            .then((ne) => ne && q3(ne))
            .catch((ne) => A(ne, h, P))
    }
    const x = (h) => i.go(h)
    let O
    const j = new Set()
    return {
        currentRoute: l,
        addRoute: m,
        removeRoute: y,
        hasRoute: _,
        getRoutes: v,
        resolve: C,
        options: t,
        push: U,
        replace: D,
        go: x,
        back: () => x(-1),
        forward: () => x(1),
        beforeEach: s.add,
        beforeResolve: o.add,
        afterEach: a.add,
        onError: E.add,
        isReady: $,
        install(h) {
            const P = this
            h.component("RouterLink", kw),
                h.component("RouterView", $w),
                (h.config.globalProperties.$router = P),
                Object.defineProperty(h.config.globalProperties, "$route", { enumerable: !0, get: () => ya(l) }),
                no && !O && l.value === Ei && ((O = !0), U(i.location).catch((z) => {}))
            const M = {}
            for (const z in Ei) M[z] = H(() => l.value[z])
            h.provide(h0, P), h.provide(p0, Ln(M)), h.provide(Qu, l)
            const V = h.unmount
            j.add(h),
                (h.unmount = function () {
                    j.delete(h), j.size < 1 && ((c = Ei), d && d(), (l.value = Ei), (O = !1), (T = !1)), V()
                })
        },
    }
}
function Ws(t) {
    return t.reduce((e, r) => e.then(() => r()), Promise.resolve())
}
function Bw(t, e) {
    const r = [],
        n = [],
        i = [],
        s = Math.max(e.matched.length, t.matched.length)
    for (let o = 0; o < s; o++) {
        const a = e.matched[o]
        a && (t.matched.find((c) => So(c, a)) ? n.push(a) : r.push(a))
        const l = t.matched[o]
        l && (e.matched.find((c) => So(c, l)) || i.push(l))
    }
    return [r, n, i]
}
function zB() {
    return sr(p0)
}
var Vt =
    typeof globalThis != "undefined"
        ? globalThis
        : typeof window != "undefined"
        ? window
        : typeof global != "undefined"
        ? global
        : typeof self != "undefined"
        ? self
        : {}
function Ow(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
function Mw(t) {
    if (t.__esModule) return t
    var e = Object.defineProperty({}, "__esModule", { value: !0 })
    return (
        Object.keys(t).forEach(function (r) {
            var n = Object.getOwnPropertyDescriptor(t, r)
            Object.defineProperty(
                e,
                r,
                n.get
                    ? n
                    : {
                          enumerable: !0,
                          get: function () {
                              return t[r]
                          },
                      }
            )
        }),
        e
    )
}
var zb = { exports: {} }
;(function (t) {
    ;(function (e, r) {
        function n(k, d) {
            if (!k) throw new Error(d || "Assertion failed")
        }
        function i(k, d) {
            k.super_ = d
            var b = function () {}
            ;(b.prototype = d.prototype), (k.prototype = new b()), (k.prototype.constructor = k)
        }
        function s(k, d, b) {
            if (s.isBN(k)) return k
            ;(this.negative = 0),
                (this.words = null),
                (this.length = 0),
                (this.red = null),
                k !== null && ((d === "le" || d === "be") && ((b = d), (d = 10)), this._init(k || 0, d || 10, b || "be"))
        }
        typeof e == "object" ? (e.exports = s) : (r.BN = s), (s.BN = s), (s.wordSize = 26)
        var o
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? (o = window.Buffer) : (o = require("buffer").Buffer)
        } catch {}
        ;(s.isBN = function (d) {
            return d instanceof s ? !0 : d !== null && typeof d == "object" && d.constructor.wordSize === s.wordSize && Array.isArray(d.words)
        }),
            (s.max = function (d, b) {
                return d.cmp(b) > 0 ? d : b
            }),
            (s.min = function (d, b) {
                return d.cmp(b) < 0 ? d : b
            }),
            (s.prototype._init = function (d, b, w) {
                if (typeof d == "number") return this._initNumber(d, b, w)
                if (typeof d == "object") return this._initArray(d, b, w)
                b === "hex" && (b = 16), n(b === (b | 0) && b >= 2 && b <= 36), (d = d.toString().replace(/\s+/g, ""))
                var E = 0
                d[0] === "-" && (E++, (this.negative = 1)),
                    E < d.length &&
                        (b === 16 ? this._parseHex(d, E, w) : (this._parseBase(d, b, E), w === "le" && this._initArray(this.toArray(), b, w)))
            }),
            (s.prototype._initNumber = function (d, b, w) {
                d < 0 && ((this.negative = 1), (d = -d)),
                    d < 67108864
                        ? ((this.words = [d & 67108863]), (this.length = 1))
                        : d < 4503599627370496
                        ? ((this.words = [d & 67108863, (d / 67108864) & 67108863]), (this.length = 2))
                        : (n(d < 9007199254740992), (this.words = [d & 67108863, (d / 67108864) & 67108863, 1]), (this.length = 3)),
                    w === "le" && this._initArray(this.toArray(), b, w)
            }),
            (s.prototype._initArray = function (d, b, w) {
                if ((n(typeof d.length == "number"), d.length <= 0)) return (this.words = [0]), (this.length = 1), this
                ;(this.length = Math.ceil(d.length / 3)), (this.words = new Array(this.length))
                for (var E = 0; E < this.length; E++) this.words[E] = 0
                var T,
                    A,
                    $ = 0
                if (w === "be")
                    for (E = d.length - 1, T = 0; E >= 0; E -= 3)
                        (A = d[E] | (d[E - 1] << 8) | (d[E - 2] << 16)),
                            (this.words[T] |= (A << $) & 67108863),
                            (this.words[T + 1] = (A >>> (26 - $)) & 67108863),
                            ($ += 24),
                            $ >= 26 && (($ -= 26), T++)
                else if (w === "le")
                    for (E = 0, T = 0; E < d.length; E += 3)
                        (A = d[E] | (d[E + 1] << 8) | (d[E + 2] << 16)),
                            (this.words[T] |= (A << $) & 67108863),
                            (this.words[T + 1] = (A >>> (26 - $)) & 67108863),
                            ($ += 24),
                            $ >= 26 && (($ -= 26), T++)
                return this.strip()
            })
        function a(k, d) {
            var b = k.charCodeAt(d)
            return b >= 65 && b <= 70 ? b - 55 : b >= 97 && b <= 102 ? b - 87 : (b - 48) & 15
        }
        function l(k, d, b) {
            var w = a(k, b)
            return b - 1 >= d && (w |= a(k, b - 1) << 4), w
        }
        s.prototype._parseHex = function (d, b, w) {
            ;(this.length = Math.ceil((d.length - b) / 6)), (this.words = new Array(this.length))
            for (var E = 0; E < this.length; E++) this.words[E] = 0
            var T = 0,
                A = 0,
                $
            if (w === "be")
                for (E = d.length - 1; E >= b; E -= 2)
                    ($ = l(d, b, E) << T),
                        (this.words[A] |= $ & 67108863),
                        T >= 18 ? ((T -= 18), (A += 1), (this.words[A] |= $ >>> 26)) : (T += 8)
            else {
                var S = d.length - b
                for (E = S % 2 === 0 ? b + 1 : b; E < d.length; E += 2)
                    ($ = l(d, b, E) << T),
                        (this.words[A] |= $ & 67108863),
                        T >= 18 ? ((T -= 18), (A += 1), (this.words[A] |= $ >>> 26)) : (T += 8)
            }
            this.strip()
        }
        function c(k, d, b, w) {
            for (var E = 0, T = Math.min(k.length, b), A = d; A < T; A++) {
                var $ = k.charCodeAt(A) - 48
                ;(E *= w), $ >= 49 ? (E += $ - 49 + 10) : $ >= 17 ? (E += $ - 17 + 10) : (E += $)
            }
            return E
        }
        ;(s.prototype._parseBase = function (d, b, w) {
            ;(this.words = [0]), (this.length = 1)
            for (var E = 0, T = 1; T <= 67108863; T *= b) E++
            E--, (T = (T / b) | 0)
            for (var A = d.length - w, $ = A % E, S = Math.min(A, A - $) + w, g = 0, x = w; x < S; x += E)
                (g = c(d, x, x + E, b)), this.imuln(T), this.words[0] + g < 67108864 ? (this.words[0] += g) : this._iaddn(g)
            if ($ !== 0) {
                var O = 1
                for (g = c(d, x, d.length, b), x = 0; x < $; x++) O *= b
                this.imuln(O), this.words[0] + g < 67108864 ? (this.words[0] += g) : this._iaddn(g)
            }
            this.strip()
        }),
            (s.prototype.copy = function (d) {
                d.words = new Array(this.length)
                for (var b = 0; b < this.length; b++) d.words[b] = this.words[b]
                ;(d.length = this.length), (d.negative = this.negative), (d.red = this.red)
            }),
            (s.prototype.clone = function () {
                var d = new s(null)
                return this.copy(d), d
            }),
            (s.prototype._expand = function (d) {
                for (; this.length < d; ) this.words[this.length++] = 0
                return this
            }),
            (s.prototype.strip = function () {
                for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
                return this._normSign()
            }),
            (s.prototype._normSign = function () {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }),
            (s.prototype.inspect = function () {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            })
        var f = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000",
            ],
            u = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            p = [
                0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
                11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
                17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ]
        ;(s.prototype.toString = function (d, b) {
            ;(d = d || 10), (b = b | 0 || 1)
            var w
            if (d === 16 || d === "hex") {
                w = ""
                for (var E = 0, T = 0, A = 0; A < this.length; A++) {
                    var $ = this.words[A],
                        S = ((($ << E) | T) & 16777215).toString(16)
                    ;(T = ($ >>> (24 - E)) & 16777215),
                        T !== 0 || A !== this.length - 1 ? (w = f[6 - S.length] + S + w) : (w = S + w),
                        (E += 2),
                        E >= 26 && ((E -= 26), A--)
                }
                for (T !== 0 && (w = T.toString(16) + w); w.length % b !== 0; ) w = "0" + w
                return this.negative !== 0 && (w = "-" + w), w
            }
            if (d === (d | 0) && d >= 2 && d <= 36) {
                var g = u[d],
                    x = p[d]
                w = ""
                var O = this.clone()
                for (O.negative = 0; !O.isZero(); ) {
                    var j = O.modn(x).toString(d)
                    ;(O = O.idivn(x)), O.isZero() ? (w = j + w) : (w = f[g - j.length] + j + w)
                }
                for (this.isZero() && (w = "0" + w); w.length % b !== 0; ) w = "0" + w
                return this.negative !== 0 && (w = "-" + w), w
            }
            n(!1, "Base should be between 2 and 36")
        }),
            (s.prototype.toNumber = function () {
                var d = this.words[0]
                return (
                    this.length === 2
                        ? (d += this.words[1] * 67108864)
                        : this.length === 3 && this.words[2] === 1
                        ? (d += 4503599627370496 + this.words[1] * 67108864)
                        : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"),
                    this.negative !== 0 ? -d : d
                )
            }),
            (s.prototype.toJSON = function () {
                return this.toString(16)
            }),
            (s.prototype.toBuffer = function (d, b) {
                return n(typeof o != "undefined"), this.toArrayLike(o, d, b)
            }),
            (s.prototype.toArray = function (d, b) {
                return this.toArrayLike(Array, d, b)
            }),
            (s.prototype.toArrayLike = function (d, b, w) {
                var E = this.byteLength(),
                    T = w || Math.max(1, E)
                n(E <= T, "byte array longer than desired length"), n(T > 0, "Requested array length <= 0"), this.strip()
                var A = b === "le",
                    $ = new d(T),
                    S,
                    g,
                    x = this.clone()
                if (A) {
                    for (g = 0; !x.isZero(); g++) (S = x.andln(255)), x.iushrn(8), ($[g] = S)
                    for (; g < T; g++) $[g] = 0
                } else {
                    for (g = 0; g < T - E; g++) $[g] = 0
                    for (g = 0; !x.isZero(); g++) (S = x.andln(255)), x.iushrn(8), ($[T - g - 1] = S)
                }
                return $
            }),
            Math.clz32
                ? (s.prototype._countBits = function (d) {
                      return 32 - Math.clz32(d)
                  })
                : (s.prototype._countBits = function (d) {
                      var b = d,
                          w = 0
                      return (
                          b >= 4096 && ((w += 13), (b >>>= 13)),
                          b >= 64 && ((w += 7), (b >>>= 7)),
                          b >= 8 && ((w += 4), (b >>>= 4)),
                          b >= 2 && ((w += 2), (b >>>= 2)),
                          w + b
                      )
                  }),
            (s.prototype._zeroBits = function (d) {
                if (d === 0) return 26
                var b = d,
                    w = 0
                return (
                    (b & 8191) === 0 && ((w += 13), (b >>>= 13)),
                    (b & 127) === 0 && ((w += 7), (b >>>= 7)),
                    (b & 15) === 0 && ((w += 4), (b >>>= 4)),
                    (b & 3) === 0 && ((w += 2), (b >>>= 2)),
                    (b & 1) === 0 && w++,
                    w
                )
            }),
            (s.prototype.bitLength = function () {
                var d = this.words[this.length - 1],
                    b = this._countBits(d)
                return (this.length - 1) * 26 + b
            })
        function m(k) {
            for (var d = new Array(k.bitLength()), b = 0; b < d.length; b++) {
                var w = (b / 26) | 0,
                    E = b % 26
                d[b] = (k.words[w] & (1 << E)) >>> E
            }
            return d
        }
        ;(s.prototype.zeroBits = function () {
            if (this.isZero()) return 0
            for (var d = 0, b = 0; b < this.length; b++) {
                var w = this._zeroBits(this.words[b])
                if (((d += w), w !== 26)) break
            }
            return d
        }),
            (s.prototype.byteLength = function () {
                return Math.ceil(this.bitLength() / 8)
            }),
            (s.prototype.toTwos = function (d) {
                return this.negative !== 0 ? this.abs().inotn(d).iaddn(1) : this.clone()
            }),
            (s.prototype.fromTwos = function (d) {
                return this.testn(d - 1) ? this.notn(d).iaddn(1).ineg() : this.clone()
            }),
            (s.prototype.isNeg = function () {
                return this.negative !== 0
            }),
            (s.prototype.neg = function () {
                return this.clone().ineg()
            }),
            (s.prototype.ineg = function () {
                return this.isZero() || (this.negative ^= 1), this
            }),
            (s.prototype.iuor = function (d) {
                for (; this.length < d.length; ) this.words[this.length++] = 0
                for (var b = 0; b < d.length; b++) this.words[b] = this.words[b] | d.words[b]
                return this.strip()
            }),
            (s.prototype.ior = function (d) {
                return n((this.negative | d.negative) === 0), this.iuor(d)
            }),
            (s.prototype.or = function (d) {
                return this.length > d.length ? this.clone().ior(d) : d.clone().ior(this)
            }),
            (s.prototype.uor = function (d) {
                return this.length > d.length ? this.clone().iuor(d) : d.clone().iuor(this)
            }),
            (s.prototype.iuand = function (d) {
                var b
                this.length > d.length ? (b = d) : (b = this)
                for (var w = 0; w < b.length; w++) this.words[w] = this.words[w] & d.words[w]
                return (this.length = b.length), this.strip()
            }),
            (s.prototype.iand = function (d) {
                return n((this.negative | d.negative) === 0), this.iuand(d)
            }),
            (s.prototype.and = function (d) {
                return this.length > d.length ? this.clone().iand(d) : d.clone().iand(this)
            }),
            (s.prototype.uand = function (d) {
                return this.length > d.length ? this.clone().iuand(d) : d.clone().iuand(this)
            }),
            (s.prototype.iuxor = function (d) {
                var b, w
                this.length > d.length ? ((b = this), (w = d)) : ((b = d), (w = this))
                for (var E = 0; E < w.length; E++) this.words[E] = b.words[E] ^ w.words[E]
                if (this !== b) for (; E < b.length; E++) this.words[E] = b.words[E]
                return (this.length = b.length), this.strip()
            }),
            (s.prototype.ixor = function (d) {
                return n((this.negative | d.negative) === 0), this.iuxor(d)
            }),
            (s.prototype.xor = function (d) {
                return this.length > d.length ? this.clone().ixor(d) : d.clone().ixor(this)
            }),
            (s.prototype.uxor = function (d) {
                return this.length > d.length ? this.clone().iuxor(d) : d.clone().iuxor(this)
            }),
            (s.prototype.inotn = function (d) {
                n(typeof d == "number" && d >= 0)
                var b = Math.ceil(d / 26) | 0,
                    w = d % 26
                this._expand(b), w > 0 && b--
                for (var E = 0; E < b; E++) this.words[E] = ~this.words[E] & 67108863
                return w > 0 && (this.words[E] = ~this.words[E] & (67108863 >> (26 - w))), this.strip()
            }),
            (s.prototype.notn = function (d) {
                return this.clone().inotn(d)
            }),
            (s.prototype.setn = function (d, b) {
                n(typeof d == "number" && d >= 0)
                var w = (d / 26) | 0,
                    E = d % 26
                return (
                    this._expand(w + 1),
                    b ? (this.words[w] = this.words[w] | (1 << E)) : (this.words[w] = this.words[w] & ~(1 << E)),
                    this.strip()
                )
            }),
            (s.prototype.iadd = function (d) {
                var b
                if (this.negative !== 0 && d.negative === 0)
                    return (this.negative = 0), (b = this.isub(d)), (this.negative ^= 1), this._normSign()
                if (this.negative === 0 && d.negative !== 0) return (d.negative = 0), (b = this.isub(d)), (d.negative = 1), b._normSign()
                var w, E
                this.length > d.length ? ((w = this), (E = d)) : ((w = d), (E = this))
                for (var T = 0, A = 0; A < E.length; A++)
                    (b = (w.words[A] | 0) + (E.words[A] | 0) + T), (this.words[A] = b & 67108863), (T = b >>> 26)
                for (; T !== 0 && A < w.length; A++) (b = (w.words[A] | 0) + T), (this.words[A] = b & 67108863), (T = b >>> 26)
                if (((this.length = w.length), T !== 0)) (this.words[this.length] = T), this.length++
                else if (w !== this) for (; A < w.length; A++) this.words[A] = w.words[A]
                return this
            }),
            (s.prototype.add = function (d) {
                var b
                return d.negative !== 0 && this.negative === 0
                    ? ((d.negative = 0), (b = this.sub(d)), (d.negative ^= 1), b)
                    : d.negative === 0 && this.negative !== 0
                    ? ((this.negative = 0), (b = d.sub(this)), (this.negative = 1), b)
                    : this.length > d.length
                    ? this.clone().iadd(d)
                    : d.clone().iadd(this)
            }),
            (s.prototype.isub = function (d) {
                if (d.negative !== 0) {
                    d.negative = 0
                    var b = this.iadd(d)
                    return (d.negative = 1), b._normSign()
                } else if (this.negative !== 0) return (this.negative = 0), this.iadd(d), (this.negative = 1), this._normSign()
                var w = this.cmp(d)
                if (w === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
                var E, T
                w > 0 ? ((E = this), (T = d)) : ((E = d), (T = this))
                for (var A = 0, $ = 0; $ < T.length; $++)
                    (b = (E.words[$] | 0) - (T.words[$] | 0) + A), (A = b >> 26), (this.words[$] = b & 67108863)
                for (; A !== 0 && $ < E.length; $++) (b = (E.words[$] | 0) + A), (A = b >> 26), (this.words[$] = b & 67108863)
                if (A === 0 && $ < E.length && E !== this) for (; $ < E.length; $++) this.words[$] = E.words[$]
                return (this.length = Math.max(this.length, $)), E !== this && (this.negative = 1), this.strip()
            }),
            (s.prototype.sub = function (d) {
                return this.clone().isub(d)
            })
        function y(k, d, b) {
            b.negative = d.negative ^ k.negative
            var w = (k.length + d.length) | 0
            ;(b.length = w), (w = (w - 1) | 0)
            var E = k.words[0] | 0,
                T = d.words[0] | 0,
                A = E * T,
                $ = A & 67108863,
                S = (A / 67108864) | 0
            b.words[0] = $
            for (var g = 1; g < w; g++) {
                for (var x = S >>> 26, O = S & 67108863, j = Math.min(g, d.length - 1), L = Math.max(0, g - k.length + 1); L <= j; L++) {
                    var h = (g - L) | 0
                    ;(E = k.words[h] | 0), (T = d.words[L] | 0), (A = E * T + O), (x += (A / 67108864) | 0), (O = A & 67108863)
                }
                ;(b.words[g] = O | 0), (S = x | 0)
            }
            return S !== 0 ? (b.words[g] = S | 0) : b.length--, b.strip()
        }
        var v = function (d, b, w) {
            var E = d.words,
                T = b.words,
                A = w.words,
                $ = 0,
                S,
                g,
                x,
                O = E[0] | 0,
                j = O & 8191,
                L = O >>> 13,
                h = E[1] | 0,
                P = h & 8191,
                M = h >>> 13,
                V = E[2] | 0,
                z = V & 8191,
                ee = V >>> 13,
                ne = E[3] | 0,
                W = ne & 8191,
                N = ne >>> 13,
                I = E[4] | 0,
                q = I & 8191,
                Q = I >>> 13,
                ie = E[5] | 0,
                Z = ie & 8191,
                oe = ie >>> 13,
                fe = E[6] | 0,
                se = fe & 8191,
                re = fe >>> 13,
                Ee = E[7] | 0,
                he = Ee & 8191,
                me = Ee >>> 13,
                Ce = E[8] | 0,
                Se = Ce & 8191,
                Ne = Ce >>> 13,
                Ge = E[9] | 0,
                ke = Ge & 8191,
                qe = Ge >>> 13,
                br = T[0] | 0,
                it = br & 8191,
                Ze = br >>> 13,
                fn = T[1] | 0,
                Ve = fn & 8191,
                je = fn >>> 13,
                un = T[2] | 0,
                dt = un & 8191,
                ht = un >>> 13,
                ns = T[3] | 0,
                pt = ns & 8191,
                gt = ns >>> 13,
                is = T[4] | 0,
                mt = is & 8191,
                bt = is >>> 13,
                ss = T[5] | 0,
                xt = ss & 8191,
                vt = ss >>> 13,
                os = T[6] | 0,
                yt = os & 8191,
                _t = os >>> 13,
                as = T[7] | 0,
                wt = as & 8191,
                Et = as >>> 13,
                ls = T[8] | 0,
                St = ls & 8191,
                At = ls >>> 13,
                cs = T[9] | 0,
                Tt = cs & 8191,
                Ct = cs >>> 13
            ;(w.negative = d.negative ^ b.negative),
                (w.length = 19),
                (S = Math.imul(j, it)),
                (g = Math.imul(j, Ze)),
                (g = (g + Math.imul(L, it)) | 0),
                (x = Math.imul(L, Ze))
            var hi = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (hi >>> 26)) | 0),
                (hi &= 67108863),
                (S = Math.imul(P, it)),
                (g = Math.imul(P, Ze)),
                (g = (g + Math.imul(M, it)) | 0),
                (x = Math.imul(M, Ze)),
                (S = (S + Math.imul(j, Ve)) | 0),
                (g = (g + Math.imul(j, je)) | 0),
                (g = (g + Math.imul(L, Ve)) | 0),
                (x = (x + Math.imul(L, je)) | 0)
            var pi = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (pi >>> 26)) | 0),
                (pi &= 67108863),
                (S = Math.imul(z, it)),
                (g = Math.imul(z, Ze)),
                (g = (g + Math.imul(ee, it)) | 0),
                (x = Math.imul(ee, Ze)),
                (S = (S + Math.imul(P, Ve)) | 0),
                (g = (g + Math.imul(P, je)) | 0),
                (g = (g + Math.imul(M, Ve)) | 0),
                (x = (x + Math.imul(M, je)) | 0),
                (S = (S + Math.imul(j, dt)) | 0),
                (g = (g + Math.imul(j, ht)) | 0),
                (g = (g + Math.imul(L, dt)) | 0),
                (x = (x + Math.imul(L, ht)) | 0)
            var gi = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (gi >>> 26)) | 0),
                (gi &= 67108863),
                (S = Math.imul(W, it)),
                (g = Math.imul(W, Ze)),
                (g = (g + Math.imul(N, it)) | 0),
                (x = Math.imul(N, Ze)),
                (S = (S + Math.imul(z, Ve)) | 0),
                (g = (g + Math.imul(z, je)) | 0),
                (g = (g + Math.imul(ee, Ve)) | 0),
                (x = (x + Math.imul(ee, je)) | 0),
                (S = (S + Math.imul(P, dt)) | 0),
                (g = (g + Math.imul(P, ht)) | 0),
                (g = (g + Math.imul(M, dt)) | 0),
                (x = (x + Math.imul(M, ht)) | 0),
                (S = (S + Math.imul(j, pt)) | 0),
                (g = (g + Math.imul(j, gt)) | 0),
                (g = (g + Math.imul(L, pt)) | 0),
                (x = (x + Math.imul(L, gt)) | 0)
            var mi = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (mi >>> 26)) | 0),
                (mi &= 67108863),
                (S = Math.imul(q, it)),
                (g = Math.imul(q, Ze)),
                (g = (g + Math.imul(Q, it)) | 0),
                (x = Math.imul(Q, Ze)),
                (S = (S + Math.imul(W, Ve)) | 0),
                (g = (g + Math.imul(W, je)) | 0),
                (g = (g + Math.imul(N, Ve)) | 0),
                (x = (x + Math.imul(N, je)) | 0),
                (S = (S + Math.imul(z, dt)) | 0),
                (g = (g + Math.imul(z, ht)) | 0),
                (g = (g + Math.imul(ee, dt)) | 0),
                (x = (x + Math.imul(ee, ht)) | 0),
                (S = (S + Math.imul(P, pt)) | 0),
                (g = (g + Math.imul(P, gt)) | 0),
                (g = (g + Math.imul(M, pt)) | 0),
                (x = (x + Math.imul(M, gt)) | 0),
                (S = (S + Math.imul(j, mt)) | 0),
                (g = (g + Math.imul(j, bt)) | 0),
                (g = (g + Math.imul(L, mt)) | 0),
                (x = (x + Math.imul(L, bt)) | 0)
            var bi = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (bi >>> 26)) | 0),
                (bi &= 67108863),
                (S = Math.imul(Z, it)),
                (g = Math.imul(Z, Ze)),
                (g = (g + Math.imul(oe, it)) | 0),
                (x = Math.imul(oe, Ze)),
                (S = (S + Math.imul(q, Ve)) | 0),
                (g = (g + Math.imul(q, je)) | 0),
                (g = (g + Math.imul(Q, Ve)) | 0),
                (x = (x + Math.imul(Q, je)) | 0),
                (S = (S + Math.imul(W, dt)) | 0),
                (g = (g + Math.imul(W, ht)) | 0),
                (g = (g + Math.imul(N, dt)) | 0),
                (x = (x + Math.imul(N, ht)) | 0),
                (S = (S + Math.imul(z, pt)) | 0),
                (g = (g + Math.imul(z, gt)) | 0),
                (g = (g + Math.imul(ee, pt)) | 0),
                (x = (x + Math.imul(ee, gt)) | 0),
                (S = (S + Math.imul(P, mt)) | 0),
                (g = (g + Math.imul(P, bt)) | 0),
                (g = (g + Math.imul(M, mt)) | 0),
                (x = (x + Math.imul(M, bt)) | 0),
                (S = (S + Math.imul(j, xt)) | 0),
                (g = (g + Math.imul(j, vt)) | 0),
                (g = (g + Math.imul(L, xt)) | 0),
                (x = (x + Math.imul(L, vt)) | 0)
            var xi = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (xi >>> 26)) | 0),
                (xi &= 67108863),
                (S = Math.imul(se, it)),
                (g = Math.imul(se, Ze)),
                (g = (g + Math.imul(re, it)) | 0),
                (x = Math.imul(re, Ze)),
                (S = (S + Math.imul(Z, Ve)) | 0),
                (g = (g + Math.imul(Z, je)) | 0),
                (g = (g + Math.imul(oe, Ve)) | 0),
                (x = (x + Math.imul(oe, je)) | 0),
                (S = (S + Math.imul(q, dt)) | 0),
                (g = (g + Math.imul(q, ht)) | 0),
                (g = (g + Math.imul(Q, dt)) | 0),
                (x = (x + Math.imul(Q, ht)) | 0),
                (S = (S + Math.imul(W, pt)) | 0),
                (g = (g + Math.imul(W, gt)) | 0),
                (g = (g + Math.imul(N, pt)) | 0),
                (x = (x + Math.imul(N, gt)) | 0),
                (S = (S + Math.imul(z, mt)) | 0),
                (g = (g + Math.imul(z, bt)) | 0),
                (g = (g + Math.imul(ee, mt)) | 0),
                (x = (x + Math.imul(ee, bt)) | 0),
                (S = (S + Math.imul(P, xt)) | 0),
                (g = (g + Math.imul(P, vt)) | 0),
                (g = (g + Math.imul(M, xt)) | 0),
                (x = (x + Math.imul(M, vt)) | 0),
                (S = (S + Math.imul(j, yt)) | 0),
                (g = (g + Math.imul(j, _t)) | 0),
                (g = (g + Math.imul(L, yt)) | 0),
                (x = (x + Math.imul(L, _t)) | 0)
            var vi = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (vi >>> 26)) | 0),
                (vi &= 67108863),
                (S = Math.imul(he, it)),
                (g = Math.imul(he, Ze)),
                (g = (g + Math.imul(me, it)) | 0),
                (x = Math.imul(me, Ze)),
                (S = (S + Math.imul(se, Ve)) | 0),
                (g = (g + Math.imul(se, je)) | 0),
                (g = (g + Math.imul(re, Ve)) | 0),
                (x = (x + Math.imul(re, je)) | 0),
                (S = (S + Math.imul(Z, dt)) | 0),
                (g = (g + Math.imul(Z, ht)) | 0),
                (g = (g + Math.imul(oe, dt)) | 0),
                (x = (x + Math.imul(oe, ht)) | 0),
                (S = (S + Math.imul(q, pt)) | 0),
                (g = (g + Math.imul(q, gt)) | 0),
                (g = (g + Math.imul(Q, pt)) | 0),
                (x = (x + Math.imul(Q, gt)) | 0),
                (S = (S + Math.imul(W, mt)) | 0),
                (g = (g + Math.imul(W, bt)) | 0),
                (g = (g + Math.imul(N, mt)) | 0),
                (x = (x + Math.imul(N, bt)) | 0),
                (S = (S + Math.imul(z, xt)) | 0),
                (g = (g + Math.imul(z, vt)) | 0),
                (g = (g + Math.imul(ee, xt)) | 0),
                (x = (x + Math.imul(ee, vt)) | 0),
                (S = (S + Math.imul(P, yt)) | 0),
                (g = (g + Math.imul(P, _t)) | 0),
                (g = (g + Math.imul(M, yt)) | 0),
                (x = (x + Math.imul(M, _t)) | 0),
                (S = (S + Math.imul(j, wt)) | 0),
                (g = (g + Math.imul(j, Et)) | 0),
                (g = (g + Math.imul(L, wt)) | 0),
                (x = (x + Math.imul(L, Et)) | 0)
            var Pf = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (Pf >>> 26)) | 0),
                (Pf &= 67108863),
                (S = Math.imul(Se, it)),
                (g = Math.imul(Se, Ze)),
                (g = (g + Math.imul(Ne, it)) | 0),
                (x = Math.imul(Ne, Ze)),
                (S = (S + Math.imul(he, Ve)) | 0),
                (g = (g + Math.imul(he, je)) | 0),
                (g = (g + Math.imul(me, Ve)) | 0),
                (x = (x + Math.imul(me, je)) | 0),
                (S = (S + Math.imul(se, dt)) | 0),
                (g = (g + Math.imul(se, ht)) | 0),
                (g = (g + Math.imul(re, dt)) | 0),
                (x = (x + Math.imul(re, ht)) | 0),
                (S = (S + Math.imul(Z, pt)) | 0),
                (g = (g + Math.imul(Z, gt)) | 0),
                (g = (g + Math.imul(oe, pt)) | 0),
                (x = (x + Math.imul(oe, gt)) | 0),
                (S = (S + Math.imul(q, mt)) | 0),
                (g = (g + Math.imul(q, bt)) | 0),
                (g = (g + Math.imul(Q, mt)) | 0),
                (x = (x + Math.imul(Q, bt)) | 0),
                (S = (S + Math.imul(W, xt)) | 0),
                (g = (g + Math.imul(W, vt)) | 0),
                (g = (g + Math.imul(N, xt)) | 0),
                (x = (x + Math.imul(N, vt)) | 0),
                (S = (S + Math.imul(z, yt)) | 0),
                (g = (g + Math.imul(z, _t)) | 0),
                (g = (g + Math.imul(ee, yt)) | 0),
                (x = (x + Math.imul(ee, _t)) | 0),
                (S = (S + Math.imul(P, wt)) | 0),
                (g = (g + Math.imul(P, Et)) | 0),
                (g = (g + Math.imul(M, wt)) | 0),
                (x = (x + Math.imul(M, Et)) | 0),
                (S = (S + Math.imul(j, St)) | 0),
                (g = (g + Math.imul(j, At)) | 0),
                (g = (g + Math.imul(L, St)) | 0),
                (x = (x + Math.imul(L, At)) | 0)
            var If = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (If >>> 26)) | 0),
                (If &= 67108863),
                (S = Math.imul(ke, it)),
                (g = Math.imul(ke, Ze)),
                (g = (g + Math.imul(qe, it)) | 0),
                (x = Math.imul(qe, Ze)),
                (S = (S + Math.imul(Se, Ve)) | 0),
                (g = (g + Math.imul(Se, je)) | 0),
                (g = (g + Math.imul(Ne, Ve)) | 0),
                (x = (x + Math.imul(Ne, je)) | 0),
                (S = (S + Math.imul(he, dt)) | 0),
                (g = (g + Math.imul(he, ht)) | 0),
                (g = (g + Math.imul(me, dt)) | 0),
                (x = (x + Math.imul(me, ht)) | 0),
                (S = (S + Math.imul(se, pt)) | 0),
                (g = (g + Math.imul(se, gt)) | 0),
                (g = (g + Math.imul(re, pt)) | 0),
                (x = (x + Math.imul(re, gt)) | 0),
                (S = (S + Math.imul(Z, mt)) | 0),
                (g = (g + Math.imul(Z, bt)) | 0),
                (g = (g + Math.imul(oe, mt)) | 0),
                (x = (x + Math.imul(oe, bt)) | 0),
                (S = (S + Math.imul(q, xt)) | 0),
                (g = (g + Math.imul(q, vt)) | 0),
                (g = (g + Math.imul(Q, xt)) | 0),
                (x = (x + Math.imul(Q, vt)) | 0),
                (S = (S + Math.imul(W, yt)) | 0),
                (g = (g + Math.imul(W, _t)) | 0),
                (g = (g + Math.imul(N, yt)) | 0),
                (x = (x + Math.imul(N, _t)) | 0),
                (S = (S + Math.imul(z, wt)) | 0),
                (g = (g + Math.imul(z, Et)) | 0),
                (g = (g + Math.imul(ee, wt)) | 0),
                (x = (x + Math.imul(ee, Et)) | 0),
                (S = (S + Math.imul(P, St)) | 0),
                (g = (g + Math.imul(P, At)) | 0),
                (g = (g + Math.imul(M, St)) | 0),
                (x = (x + Math.imul(M, At)) | 0),
                (S = (S + Math.imul(j, Tt)) | 0),
                (g = (g + Math.imul(j, Ct)) | 0),
                (g = (g + Math.imul(L, Tt)) | 0),
                (x = (x + Math.imul(L, Ct)) | 0)
            var $f = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + ($f >>> 26)) | 0),
                ($f &= 67108863),
                (S = Math.imul(ke, Ve)),
                (g = Math.imul(ke, je)),
                (g = (g + Math.imul(qe, Ve)) | 0),
                (x = Math.imul(qe, je)),
                (S = (S + Math.imul(Se, dt)) | 0),
                (g = (g + Math.imul(Se, ht)) | 0),
                (g = (g + Math.imul(Ne, dt)) | 0),
                (x = (x + Math.imul(Ne, ht)) | 0),
                (S = (S + Math.imul(he, pt)) | 0),
                (g = (g + Math.imul(he, gt)) | 0),
                (g = (g + Math.imul(me, pt)) | 0),
                (x = (x + Math.imul(me, gt)) | 0),
                (S = (S + Math.imul(se, mt)) | 0),
                (g = (g + Math.imul(se, bt)) | 0),
                (g = (g + Math.imul(re, mt)) | 0),
                (x = (x + Math.imul(re, bt)) | 0),
                (S = (S + Math.imul(Z, xt)) | 0),
                (g = (g + Math.imul(Z, vt)) | 0),
                (g = (g + Math.imul(oe, xt)) | 0),
                (x = (x + Math.imul(oe, vt)) | 0),
                (S = (S + Math.imul(q, yt)) | 0),
                (g = (g + Math.imul(q, _t)) | 0),
                (g = (g + Math.imul(Q, yt)) | 0),
                (x = (x + Math.imul(Q, _t)) | 0),
                (S = (S + Math.imul(W, wt)) | 0),
                (g = (g + Math.imul(W, Et)) | 0),
                (g = (g + Math.imul(N, wt)) | 0),
                (x = (x + Math.imul(N, Et)) | 0),
                (S = (S + Math.imul(z, St)) | 0),
                (g = (g + Math.imul(z, At)) | 0),
                (g = (g + Math.imul(ee, St)) | 0),
                (x = (x + Math.imul(ee, At)) | 0),
                (S = (S + Math.imul(P, Tt)) | 0),
                (g = (g + Math.imul(P, Ct)) | 0),
                (g = (g + Math.imul(M, Tt)) | 0),
                (x = (x + Math.imul(M, Ct)) | 0)
            var Bf = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (Bf >>> 26)) | 0),
                (Bf &= 67108863),
                (S = Math.imul(ke, dt)),
                (g = Math.imul(ke, ht)),
                (g = (g + Math.imul(qe, dt)) | 0),
                (x = Math.imul(qe, ht)),
                (S = (S + Math.imul(Se, pt)) | 0),
                (g = (g + Math.imul(Se, gt)) | 0),
                (g = (g + Math.imul(Ne, pt)) | 0),
                (x = (x + Math.imul(Ne, gt)) | 0),
                (S = (S + Math.imul(he, mt)) | 0),
                (g = (g + Math.imul(he, bt)) | 0),
                (g = (g + Math.imul(me, mt)) | 0),
                (x = (x + Math.imul(me, bt)) | 0),
                (S = (S + Math.imul(se, xt)) | 0),
                (g = (g + Math.imul(se, vt)) | 0),
                (g = (g + Math.imul(re, xt)) | 0),
                (x = (x + Math.imul(re, vt)) | 0),
                (S = (S + Math.imul(Z, yt)) | 0),
                (g = (g + Math.imul(Z, _t)) | 0),
                (g = (g + Math.imul(oe, yt)) | 0),
                (x = (x + Math.imul(oe, _t)) | 0),
                (S = (S + Math.imul(q, wt)) | 0),
                (g = (g + Math.imul(q, Et)) | 0),
                (g = (g + Math.imul(Q, wt)) | 0),
                (x = (x + Math.imul(Q, Et)) | 0),
                (S = (S + Math.imul(W, St)) | 0),
                (g = (g + Math.imul(W, At)) | 0),
                (g = (g + Math.imul(N, St)) | 0),
                (x = (x + Math.imul(N, At)) | 0),
                (S = (S + Math.imul(z, Tt)) | 0),
                (g = (g + Math.imul(z, Ct)) | 0),
                (g = (g + Math.imul(ee, Tt)) | 0),
                (x = (x + Math.imul(ee, Ct)) | 0)
            var Of = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (Of >>> 26)) | 0),
                (Of &= 67108863),
                (S = Math.imul(ke, pt)),
                (g = Math.imul(ke, gt)),
                (g = (g + Math.imul(qe, pt)) | 0),
                (x = Math.imul(qe, gt)),
                (S = (S + Math.imul(Se, mt)) | 0),
                (g = (g + Math.imul(Se, bt)) | 0),
                (g = (g + Math.imul(Ne, mt)) | 0),
                (x = (x + Math.imul(Ne, bt)) | 0),
                (S = (S + Math.imul(he, xt)) | 0),
                (g = (g + Math.imul(he, vt)) | 0),
                (g = (g + Math.imul(me, xt)) | 0),
                (x = (x + Math.imul(me, vt)) | 0),
                (S = (S + Math.imul(se, yt)) | 0),
                (g = (g + Math.imul(se, _t)) | 0),
                (g = (g + Math.imul(re, yt)) | 0),
                (x = (x + Math.imul(re, _t)) | 0),
                (S = (S + Math.imul(Z, wt)) | 0),
                (g = (g + Math.imul(Z, Et)) | 0),
                (g = (g + Math.imul(oe, wt)) | 0),
                (x = (x + Math.imul(oe, Et)) | 0),
                (S = (S + Math.imul(q, St)) | 0),
                (g = (g + Math.imul(q, At)) | 0),
                (g = (g + Math.imul(Q, St)) | 0),
                (x = (x + Math.imul(Q, At)) | 0),
                (S = (S + Math.imul(W, Tt)) | 0),
                (g = (g + Math.imul(W, Ct)) | 0),
                (g = (g + Math.imul(N, Tt)) | 0),
                (x = (x + Math.imul(N, Ct)) | 0)
            var Mf = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (Mf >>> 26)) | 0),
                (Mf &= 67108863),
                (S = Math.imul(ke, mt)),
                (g = Math.imul(ke, bt)),
                (g = (g + Math.imul(qe, mt)) | 0),
                (x = Math.imul(qe, bt)),
                (S = (S + Math.imul(Se, xt)) | 0),
                (g = (g + Math.imul(Se, vt)) | 0),
                (g = (g + Math.imul(Ne, xt)) | 0),
                (x = (x + Math.imul(Ne, vt)) | 0),
                (S = (S + Math.imul(he, yt)) | 0),
                (g = (g + Math.imul(he, _t)) | 0),
                (g = (g + Math.imul(me, yt)) | 0),
                (x = (x + Math.imul(me, _t)) | 0),
                (S = (S + Math.imul(se, wt)) | 0),
                (g = (g + Math.imul(se, Et)) | 0),
                (g = (g + Math.imul(re, wt)) | 0),
                (x = (x + Math.imul(re, Et)) | 0),
                (S = (S + Math.imul(Z, St)) | 0),
                (g = (g + Math.imul(Z, At)) | 0),
                (g = (g + Math.imul(oe, St)) | 0),
                (x = (x + Math.imul(oe, At)) | 0),
                (S = (S + Math.imul(q, Tt)) | 0),
                (g = (g + Math.imul(q, Ct)) | 0),
                (g = (g + Math.imul(Q, Tt)) | 0),
                (x = (x + Math.imul(Q, Ct)) | 0)
            var Rf = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (Rf >>> 26)) | 0),
                (Rf &= 67108863),
                (S = Math.imul(ke, xt)),
                (g = Math.imul(ke, vt)),
                (g = (g + Math.imul(qe, xt)) | 0),
                (x = Math.imul(qe, vt)),
                (S = (S + Math.imul(Se, yt)) | 0),
                (g = (g + Math.imul(Se, _t)) | 0),
                (g = (g + Math.imul(Ne, yt)) | 0),
                (x = (x + Math.imul(Ne, _t)) | 0),
                (S = (S + Math.imul(he, wt)) | 0),
                (g = (g + Math.imul(he, Et)) | 0),
                (g = (g + Math.imul(me, wt)) | 0),
                (x = (x + Math.imul(me, Et)) | 0),
                (S = (S + Math.imul(se, St)) | 0),
                (g = (g + Math.imul(se, At)) | 0),
                (g = (g + Math.imul(re, St)) | 0),
                (x = (x + Math.imul(re, At)) | 0),
                (S = (S + Math.imul(Z, Tt)) | 0),
                (g = (g + Math.imul(Z, Ct)) | 0),
                (g = (g + Math.imul(oe, Tt)) | 0),
                (x = (x + Math.imul(oe, Ct)) | 0)
            var Lf = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (Lf >>> 26)) | 0),
                (Lf &= 67108863),
                (S = Math.imul(ke, yt)),
                (g = Math.imul(ke, _t)),
                (g = (g + Math.imul(qe, yt)) | 0),
                (x = Math.imul(qe, _t)),
                (S = (S + Math.imul(Se, wt)) | 0),
                (g = (g + Math.imul(Se, Et)) | 0),
                (g = (g + Math.imul(Ne, wt)) | 0),
                (x = (x + Math.imul(Ne, Et)) | 0),
                (S = (S + Math.imul(he, St)) | 0),
                (g = (g + Math.imul(he, At)) | 0),
                (g = (g + Math.imul(me, St)) | 0),
                (x = (x + Math.imul(me, At)) | 0),
                (S = (S + Math.imul(se, Tt)) | 0),
                (g = (g + Math.imul(se, Ct)) | 0),
                (g = (g + Math.imul(re, Tt)) | 0),
                (x = (x + Math.imul(re, Ct)) | 0)
            var Df = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (Df >>> 26)) | 0),
                (Df &= 67108863),
                (S = Math.imul(ke, wt)),
                (g = Math.imul(ke, Et)),
                (g = (g + Math.imul(qe, wt)) | 0),
                (x = Math.imul(qe, Et)),
                (S = (S + Math.imul(Se, St)) | 0),
                (g = (g + Math.imul(Se, At)) | 0),
                (g = (g + Math.imul(Ne, St)) | 0),
                (x = (x + Math.imul(Ne, At)) | 0),
                (S = (S + Math.imul(he, Tt)) | 0),
                (g = (g + Math.imul(he, Ct)) | 0),
                (g = (g + Math.imul(me, Tt)) | 0),
                (x = (x + Math.imul(me, Ct)) | 0)
            var Ff = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (Ff >>> 26)) | 0),
                (Ff &= 67108863),
                (S = Math.imul(ke, St)),
                (g = Math.imul(ke, At)),
                (g = (g + Math.imul(qe, St)) | 0),
                (x = Math.imul(qe, At)),
                (S = (S + Math.imul(Se, Tt)) | 0),
                (g = (g + Math.imul(Se, Ct)) | 0),
                (g = (g + Math.imul(Ne, Tt)) | 0),
                (x = (x + Math.imul(Ne, Ct)) | 0)
            var Vf = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            ;($ = (((x + (g >>> 13)) | 0) + (Vf >>> 26)) | 0),
                (Vf &= 67108863),
                (S = Math.imul(ke, Tt)),
                (g = Math.imul(ke, Ct)),
                (g = (g + Math.imul(qe, Tt)) | 0),
                (x = Math.imul(qe, Ct))
            var Uf = ((($ + S) | 0) + ((g & 8191) << 13)) | 0
            return (
                ($ = (((x + (g >>> 13)) | 0) + (Uf >>> 26)) | 0),
                (Uf &= 67108863),
                (A[0] = hi),
                (A[1] = pi),
                (A[2] = gi),
                (A[3] = mi),
                (A[4] = bi),
                (A[5] = xi),
                (A[6] = vi),
                (A[7] = Pf),
                (A[8] = If),
                (A[9] = $f),
                (A[10] = Bf),
                (A[11] = Of),
                (A[12] = Mf),
                (A[13] = Rf),
                (A[14] = Lf),
                (A[15] = Df),
                (A[16] = Ff),
                (A[17] = Vf),
                (A[18] = Uf),
                $ !== 0 && ((A[19] = $), w.length++),
                w
            )
        }
        Math.imul || (v = y)
        function _(k, d, b) {
            ;(b.negative = d.negative ^ k.negative), (b.length = k.length + d.length)
            for (var w = 0, E = 0, T = 0; T < b.length - 1; T++) {
                var A = E
                E = 0
                for (var $ = w & 67108863, S = Math.min(T, d.length - 1), g = Math.max(0, T - k.length + 1); g <= S; g++) {
                    var x = T - g,
                        O = k.words[x] | 0,
                        j = d.words[g] | 0,
                        L = O * j,
                        h = L & 67108863
                    ;(A = (A + ((L / 67108864) | 0)) | 0),
                        (h = (h + $) | 0),
                        ($ = h & 67108863),
                        (A = (A + (h >>> 26)) | 0),
                        (E += A >>> 26),
                        (A &= 67108863)
                }
                ;(b.words[T] = $), (w = A), (A = E)
            }
            return w !== 0 ? (b.words[T] = w) : b.length--, b.strip()
        }
        function C(k, d, b) {
            var w = new B()
            return w.mulp(k, d, b)
        }
        s.prototype.mulTo = function (d, b) {
            var w,
                E = this.length + d.length
            return (
                this.length === 10 && d.length === 10
                    ? (w = v(this, d, b))
                    : E < 63
                    ? (w = y(this, d, b))
                    : E < 1024
                    ? (w = _(this, d, b))
                    : (w = C(this, d, b)),
                w
            )
        }
        function B(k, d) {
            ;(this.x = k), (this.y = d)
        }
        ;(B.prototype.makeRBT = function (d) {
            for (var b = new Array(d), w = s.prototype._countBits(d) - 1, E = 0; E < d; E++) b[E] = this.revBin(E, w, d)
            return b
        }),
            (B.prototype.revBin = function (d, b, w) {
                if (d === 0 || d === w - 1) return d
                for (var E = 0, T = 0; T < b; T++) (E |= (d & 1) << (b - T - 1)), (d >>= 1)
                return E
            }),
            (B.prototype.permute = function (d, b, w, E, T, A) {
                for (var $ = 0; $ < A; $++) (E[$] = b[d[$]]), (T[$] = w[d[$]])
            }),
            (B.prototype.transform = function (d, b, w, E, T, A) {
                this.permute(A, d, b, w, E, T)
                for (var $ = 1; $ < T; $ <<= 1)
                    for (var S = $ << 1, g = Math.cos((2 * Math.PI) / S), x = Math.sin((2 * Math.PI) / S), O = 0; O < T; O += S)
                        for (var j = g, L = x, h = 0; h < $; h++) {
                            var P = w[O + h],
                                M = E[O + h],
                                V = w[O + h + $],
                                z = E[O + h + $],
                                ee = j * V - L * z
                            ;(z = j * z + L * V),
                                (V = ee),
                                (w[O + h] = P + V),
                                (E[O + h] = M + z),
                                (w[O + h + $] = P - V),
                                (E[O + h + $] = M - z),
                                h !== S && ((ee = g * j - x * L), (L = g * L + x * j), (j = ee))
                        }
            }),
            (B.prototype.guessLen13b = function (d, b) {
                var w = Math.max(b, d) | 1,
                    E = w & 1,
                    T = 0
                for (w = (w / 2) | 0; w; w = w >>> 1) T++
                return 1 << (T + 1 + E)
            }),
            (B.prototype.conjugate = function (d, b, w) {
                if (!(w <= 1))
                    for (var E = 0; E < w / 2; E++) {
                        var T = d[E]
                        ;(d[E] = d[w - E - 1]), (d[w - E - 1] = T), (T = b[E]), (b[E] = -b[w - E - 1]), (b[w - E - 1] = -T)
                    }
            }),
            (B.prototype.normalize13b = function (d, b) {
                for (var w = 0, E = 0; E < b / 2; E++) {
                    var T = Math.round(d[2 * E + 1] / b) * 8192 + Math.round(d[2 * E] / b) + w
                    ;(d[E] = T & 67108863), T < 67108864 ? (w = 0) : (w = (T / 67108864) | 0)
                }
                return d
            }),
            (B.prototype.convert13b = function (d, b, w, E) {
                for (var T = 0, A = 0; A < b; A++)
                    (T = T + (d[A] | 0)), (w[2 * A] = T & 8191), (T = T >>> 13), (w[2 * A + 1] = T & 8191), (T = T >>> 13)
                for (A = 2 * b; A < E; ++A) w[A] = 0
                n(T === 0), n((T & -8192) === 0)
            }),
            (B.prototype.stub = function (d) {
                for (var b = new Array(d), w = 0; w < d; w++) b[w] = 0
                return b
            }),
            (B.prototype.mulp = function (d, b, w) {
                var E = 2 * this.guessLen13b(d.length, b.length),
                    T = this.makeRBT(E),
                    A = this.stub(E),
                    $ = new Array(E),
                    S = new Array(E),
                    g = new Array(E),
                    x = new Array(E),
                    O = new Array(E),
                    j = new Array(E),
                    L = w.words
                ;(L.length = E),
                    this.convert13b(d.words, d.length, $, E),
                    this.convert13b(b.words, b.length, x, E),
                    this.transform($, A, S, g, E, T),
                    this.transform(x, A, O, j, E, T)
                for (var h = 0; h < E; h++) {
                    var P = S[h] * O[h] - g[h] * j[h]
                    ;(g[h] = S[h] * j[h] + g[h] * O[h]), (S[h] = P)
                }
                return (
                    this.conjugate(S, g, E),
                    this.transform(S, g, L, A, E, T),
                    this.conjugate(L, A, E),
                    this.normalize13b(L, E),
                    (w.negative = d.negative ^ b.negative),
                    (w.length = d.length + b.length),
                    w.strip()
                )
            }),
            (s.prototype.mul = function (d) {
                var b = new s(null)
                return (b.words = new Array(this.length + d.length)), this.mulTo(d, b)
            }),
            (s.prototype.mulf = function (d) {
                var b = new s(null)
                return (b.words = new Array(this.length + d.length)), C(this, d, b)
            }),
            (s.prototype.imul = function (d) {
                return this.clone().mulTo(d, this)
            }),
            (s.prototype.imuln = function (d) {
                n(typeof d == "number"), n(d < 67108864)
                for (var b = 0, w = 0; w < this.length; w++) {
                    var E = (this.words[w] | 0) * d,
                        T = (E & 67108863) + (b & 67108863)
                    ;(b >>= 26), (b += (E / 67108864) | 0), (b += T >>> 26), (this.words[w] = T & 67108863)
                }
                return b !== 0 && ((this.words[w] = b), this.length++), this
            }),
            (s.prototype.muln = function (d) {
                return this.clone().imuln(d)
            }),
            (s.prototype.sqr = function () {
                return this.mul(this)
            }),
            (s.prototype.isqr = function () {
                return this.imul(this.clone())
            }),
            (s.prototype.pow = function (d) {
                var b = m(d)
                if (b.length === 0) return new s(1)
                for (var w = this, E = 0; E < b.length && b[E] === 0; E++, w = w.sqr());
                if (++E < b.length) for (var T = w.sqr(); E < b.length; E++, T = T.sqr()) b[E] !== 0 && (w = w.mul(T))
                return w
            }),
            (s.prototype.iushln = function (d) {
                n(typeof d == "number" && d >= 0)
                var b = d % 26,
                    w = (d - b) / 26,
                    E = (67108863 >>> (26 - b)) << (26 - b),
                    T
                if (b !== 0) {
                    var A = 0
                    for (T = 0; T < this.length; T++) {
                        var $ = this.words[T] & E,
                            S = ((this.words[T] | 0) - $) << b
                        ;(this.words[T] = S | A), (A = $ >>> (26 - b))
                    }
                    A && ((this.words[T] = A), this.length++)
                }
                if (w !== 0) {
                    for (T = this.length - 1; T >= 0; T--) this.words[T + w] = this.words[T]
                    for (T = 0; T < w; T++) this.words[T] = 0
                    this.length += w
                }
                return this.strip()
            }),
            (s.prototype.ishln = function (d) {
                return n(this.negative === 0), this.iushln(d)
            }),
            (s.prototype.iushrn = function (d, b, w) {
                n(typeof d == "number" && d >= 0)
                var E
                b ? (E = (b - (b % 26)) / 26) : (E = 0)
                var T = d % 26,
                    A = Math.min((d - T) / 26, this.length),
                    $ = 67108863 ^ ((67108863 >>> T) << T),
                    S = w
                if (((E -= A), (E = Math.max(0, E)), S)) {
                    for (var g = 0; g < A; g++) S.words[g] = this.words[g]
                    S.length = A
                }
                if (A !== 0)
                    if (this.length > A) for (this.length -= A, g = 0; g < this.length; g++) this.words[g] = this.words[g + A]
                    else (this.words[0] = 0), (this.length = 1)
                var x = 0
                for (g = this.length - 1; g >= 0 && (x !== 0 || g >= E); g--) {
                    var O = this.words[g] | 0
                    ;(this.words[g] = (x << (26 - T)) | (O >>> T)), (x = O & $)
                }
                return S && x !== 0 && (S.words[S.length++] = x), this.length === 0 && ((this.words[0] = 0), (this.length = 1)), this.strip()
            }),
            (s.prototype.ishrn = function (d, b, w) {
                return n(this.negative === 0), this.iushrn(d, b, w)
            }),
            (s.prototype.shln = function (d) {
                return this.clone().ishln(d)
            }),
            (s.prototype.ushln = function (d) {
                return this.clone().iushln(d)
            }),
            (s.prototype.shrn = function (d) {
                return this.clone().ishrn(d)
            }),
            (s.prototype.ushrn = function (d) {
                return this.clone().iushrn(d)
            }),
            (s.prototype.testn = function (d) {
                n(typeof d == "number" && d >= 0)
                var b = d % 26,
                    w = (d - b) / 26,
                    E = 1 << b
                if (this.length <= w) return !1
                var T = this.words[w]
                return !!(T & E)
            }),
            (s.prototype.imaskn = function (d) {
                n(typeof d == "number" && d >= 0)
                var b = d % 26,
                    w = (d - b) / 26
                if ((n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= w)) return this
                if ((b !== 0 && w++, (this.length = Math.min(w, this.length)), b !== 0)) {
                    var E = 67108863 ^ ((67108863 >>> b) << b)
                    this.words[this.length - 1] &= E
                }
                return this.strip()
            }),
            (s.prototype.maskn = function (d) {
                return this.clone().imaskn(d)
            }),
            (s.prototype.iaddn = function (d) {
                return (
                    n(typeof d == "number"),
                    n(d < 67108864),
                    d < 0
                        ? this.isubn(-d)
                        : this.negative !== 0
                        ? this.length === 1 && (this.words[0] | 0) < d
                            ? ((this.words[0] = d - (this.words[0] | 0)), (this.negative = 0), this)
                            : ((this.negative = 0), this.isubn(d), (this.negative = 1), this)
                        : this._iaddn(d)
                )
            }),
            (s.prototype._iaddn = function (d) {
                this.words[0] += d
                for (var b = 0; b < this.length && this.words[b] >= 67108864; b++)
                    (this.words[b] -= 67108864), b === this.length - 1 ? (this.words[b + 1] = 1) : this.words[b + 1]++
                return (this.length = Math.max(this.length, b + 1)), this
            }),
            (s.prototype.isubn = function (d) {
                if ((n(typeof d == "number"), n(d < 67108864), d < 0)) return this.iaddn(-d)
                if (this.negative !== 0) return (this.negative = 0), this.iaddn(d), (this.negative = 1), this
                if (((this.words[0] -= d), this.length === 1 && this.words[0] < 0)) (this.words[0] = -this.words[0]), (this.negative = 1)
                else for (var b = 0; b < this.length && this.words[b] < 0; b++) (this.words[b] += 67108864), (this.words[b + 1] -= 1)
                return this.strip()
            }),
            (s.prototype.addn = function (d) {
                return this.clone().iaddn(d)
            }),
            (s.prototype.subn = function (d) {
                return this.clone().isubn(d)
            }),
            (s.prototype.iabs = function () {
                return (this.negative = 0), this
            }),
            (s.prototype.abs = function () {
                return this.clone().iabs()
            }),
            (s.prototype._ishlnsubmul = function (d, b, w) {
                var E = d.length + w,
                    T
                this._expand(E)
                var A,
                    $ = 0
                for (T = 0; T < d.length; T++) {
                    A = (this.words[T + w] | 0) + $
                    var S = (d.words[T] | 0) * b
                    ;(A -= S & 67108863), ($ = (A >> 26) - ((S / 67108864) | 0)), (this.words[T + w] = A & 67108863)
                }
                for (; T < this.length - w; T++) (A = (this.words[T + w] | 0) + $), ($ = A >> 26), (this.words[T + w] = A & 67108863)
                if ($ === 0) return this.strip()
                for (n($ === -1), $ = 0, T = 0; T < this.length; T++)
                    (A = -(this.words[T] | 0) + $), ($ = A >> 26), (this.words[T] = A & 67108863)
                return (this.negative = 1), this.strip()
            }),
            (s.prototype._wordDiv = function (d, b) {
                var w = this.length - d.length,
                    E = this.clone(),
                    T = d,
                    A = T.words[T.length - 1] | 0,
                    $ = this._countBits(A)
                ;(w = 26 - $), w !== 0 && ((T = T.ushln(w)), E.iushln(w), (A = T.words[T.length - 1] | 0))
                var S = E.length - T.length,
                    g
                if (b !== "mod") {
                    ;(g = new s(null)), (g.length = S + 1), (g.words = new Array(g.length))
                    for (var x = 0; x < g.length; x++) g.words[x] = 0
                }
                var O = E.clone()._ishlnsubmul(T, 1, S)
                O.negative === 0 && ((E = O), g && (g.words[S] = 1))
                for (var j = S - 1; j >= 0; j--) {
                    var L = (E.words[T.length + j] | 0) * 67108864 + (E.words[T.length + j - 1] | 0)
                    for (L = Math.min((L / A) | 0, 67108863), E._ishlnsubmul(T, L, j); E.negative !== 0; )
                        L--, (E.negative = 0), E._ishlnsubmul(T, 1, j), E.isZero() || (E.negative ^= 1)
                    g && (g.words[j] = L)
                }
                return g && g.strip(), E.strip(), b !== "div" && w !== 0 && E.iushrn(w), { div: g || null, mod: E }
            }),
            (s.prototype.divmod = function (d, b, w) {
                if ((n(!d.isZero()), this.isZero())) return { div: new s(0), mod: new s(0) }
                var E, T, A
                return this.negative !== 0 && d.negative === 0
                    ? ((A = this.neg().divmod(d, b)),
                      b !== "mod" && (E = A.div.neg()),
                      b !== "div" && ((T = A.mod.neg()), w && T.negative !== 0 && T.iadd(d)),
                      { div: E, mod: T })
                    : this.negative === 0 && d.negative !== 0
                    ? ((A = this.divmod(d.neg(), b)), b !== "mod" && (E = A.div.neg()), { div: E, mod: A.mod })
                    : (this.negative & d.negative) !== 0
                    ? ((A = this.neg().divmod(d.neg(), b)),
                      b !== "div" && ((T = A.mod.neg()), w && T.negative !== 0 && T.isub(d)),
                      { div: A.div, mod: T })
                    : d.length > this.length || this.cmp(d) < 0
                    ? { div: new s(0), mod: this }
                    : d.length === 1
                    ? b === "div"
                        ? { div: this.divn(d.words[0]), mod: null }
                        : b === "mod"
                        ? { div: null, mod: new s(this.modn(d.words[0])) }
                        : { div: this.divn(d.words[0]), mod: new s(this.modn(d.words[0])) }
                    : this._wordDiv(d, b)
            }),
            (s.prototype.div = function (d) {
                return this.divmod(d, "div", !1).div
            }),
            (s.prototype.mod = function (d) {
                return this.divmod(d, "mod", !1).mod
            }),
            (s.prototype.umod = function (d) {
                return this.divmod(d, "mod", !0).mod
            }),
            (s.prototype.divRound = function (d) {
                var b = this.divmod(d)
                if (b.mod.isZero()) return b.div
                var w = b.div.negative !== 0 ? b.mod.isub(d) : b.mod,
                    E = d.ushrn(1),
                    T = d.andln(1),
                    A = w.cmp(E)
                return A < 0 || (T === 1 && A === 0) ? b.div : b.div.negative !== 0 ? b.div.isubn(1) : b.div.iaddn(1)
            }),
            (s.prototype.modn = function (d) {
                n(d <= 67108863)
                for (var b = (1 << 26) % d, w = 0, E = this.length - 1; E >= 0; E--) w = (b * w + (this.words[E] | 0)) % d
                return w
            }),
            (s.prototype.idivn = function (d) {
                n(d <= 67108863)
                for (var b = 0, w = this.length - 1; w >= 0; w--) {
                    var E = (this.words[w] | 0) + b * 67108864
                    ;(this.words[w] = (E / d) | 0), (b = E % d)
                }
                return this.strip()
            }),
            (s.prototype.divn = function (d) {
                return this.clone().idivn(d)
            }),
            (s.prototype.egcd = function (d) {
                n(d.negative === 0), n(!d.isZero())
                var b = this,
                    w = d.clone()
                b.negative !== 0 ? (b = b.umod(d)) : (b = b.clone())
                for (var E = new s(1), T = new s(0), A = new s(0), $ = new s(1), S = 0; b.isEven() && w.isEven(); ) b.iushrn(1), w.iushrn(1), ++S
                for (var g = w.clone(), x = b.clone(); !b.isZero(); ) {
                    for (var O = 0, j = 1; (b.words[0] & j) === 0 && O < 26; ++O, j <<= 1);
                    if (O > 0) for (b.iushrn(O); O-- > 0; ) (E.isOdd() || T.isOdd()) && (E.iadd(g), T.isub(x)), E.iushrn(1), T.iushrn(1)
                    for (var L = 0, h = 1; (w.words[0] & h) === 0 && L < 26; ++L, h <<= 1);
                    if (L > 0) for (w.iushrn(L); L-- > 0; ) (A.isOdd() || $.isOdd()) && (A.iadd(g), $.isub(x)), A.iushrn(1), $.iushrn(1)
                    b.cmp(w) >= 0 ? (b.isub(w), E.isub(A), T.isub($)) : (w.isub(b), A.isub(E), $.isub(T))
                }
                return { a: A, b: $, gcd: w.iushln(S) }
            }),
            (s.prototype._invmp = function (d) {
                n(d.negative === 0), n(!d.isZero())
                var b = this,
                    w = d.clone()
                b.negative !== 0 ? (b = b.umod(d)) : (b = b.clone())
                for (var E = new s(1), T = new s(0), A = w.clone(); b.cmpn(1) > 0 && w.cmpn(1) > 0; ) {
                    for (var $ = 0, S = 1; (b.words[0] & S) === 0 && $ < 26; ++$, S <<= 1);
                    if ($ > 0) for (b.iushrn($); $-- > 0; ) E.isOdd() && E.iadd(A), E.iushrn(1)
                    for (var g = 0, x = 1; (w.words[0] & x) === 0 && g < 26; ++g, x <<= 1);
                    if (g > 0) for (w.iushrn(g); g-- > 0; ) T.isOdd() && T.iadd(A), T.iushrn(1)
                    b.cmp(w) >= 0 ? (b.isub(w), E.isub(T)) : (w.isub(b), T.isub(E))
                }
                var O
                return b.cmpn(1) === 0 ? (O = E) : (O = T), O.cmpn(0) < 0 && O.iadd(d), O
            }),
            (s.prototype.gcd = function (d) {
                if (this.isZero()) return d.abs()
                if (d.isZero()) return this.abs()
                var b = this.clone(),
                    w = d.clone()
                ;(b.negative = 0), (w.negative = 0)
                for (var E = 0; b.isEven() && w.isEven(); E++) b.iushrn(1), w.iushrn(1)
                do {
                    for (; b.isEven(); ) b.iushrn(1)
                    for (; w.isEven(); ) w.iushrn(1)
                    var T = b.cmp(w)
                    if (T < 0) {
                        var A = b
                        ;(b = w), (w = A)
                    } else if (T === 0 || w.cmpn(1) === 0) break
                    b.isub(w)
                } while (!0)
                return w.iushln(E)
            }),
            (s.prototype.invm = function (d) {
                return this.egcd(d).a.umod(d)
            }),
            (s.prototype.isEven = function () {
                return (this.words[0] & 1) === 0
            }),
            (s.prototype.isOdd = function () {
                return (this.words[0] & 1) === 1
            }),
            (s.prototype.andln = function (d) {
                return this.words[0] & d
            }),
            (s.prototype.bincn = function (d) {
                n(typeof d == "number")
                var b = d % 26,
                    w = (d - b) / 26,
                    E = 1 << b
                if (this.length <= w) return this._expand(w + 1), (this.words[w] |= E), this
                for (var T = E, A = w; T !== 0 && A < this.length; A++) {
                    var $ = this.words[A] | 0
                    ;($ += T), (T = $ >>> 26), ($ &= 67108863), (this.words[A] = $)
                }
                return T !== 0 && ((this.words[A] = T), this.length++), this
            }),
            (s.prototype.isZero = function () {
                return this.length === 1 && this.words[0] === 0
            }),
            (s.prototype.cmpn = function (d) {
                var b = d < 0
                if (this.negative !== 0 && !b) return -1
                if (this.negative === 0 && b) return 1
                this.strip()
                var w
                if (this.length > 1) w = 1
                else {
                    b && (d = -d), n(d <= 67108863, "Number is too big")
                    var E = this.words[0] | 0
                    w = E === d ? 0 : E < d ? -1 : 1
                }
                return this.negative !== 0 ? -w | 0 : w
            }),
            (s.prototype.cmp = function (d) {
                if (this.negative !== 0 && d.negative === 0) return -1
                if (this.negative === 0 && d.negative !== 0) return 1
                var b = this.ucmp(d)
                return this.negative !== 0 ? -b | 0 : b
            }),
            (s.prototype.ucmp = function (d) {
                if (this.length > d.length) return 1
                if (this.length < d.length) return -1
                for (var b = 0, w = this.length - 1; w >= 0; w--) {
                    var E = this.words[w] | 0,
                        T = d.words[w] | 0
                    if (E !== T) {
                        E < T ? (b = -1) : E > T && (b = 1)
                        break
                    }
                }
                return b
            }),
            (s.prototype.gtn = function (d) {
                return this.cmpn(d) === 1
            }),
            (s.prototype.gt = function (d) {
                return this.cmp(d) === 1
            }),
            (s.prototype.gten = function (d) {
                return this.cmpn(d) >= 0
            }),
            (s.prototype.gte = function (d) {
                return this.cmp(d) >= 0
            }),
            (s.prototype.ltn = function (d) {
                return this.cmpn(d) === -1
            }),
            (s.prototype.lt = function (d) {
                return this.cmp(d) === -1
            }),
            (s.prototype.lten = function (d) {
                return this.cmpn(d) <= 0
            }),
            (s.prototype.lte = function (d) {
                return this.cmp(d) <= 0
            }),
            (s.prototype.eqn = function (d) {
                return this.cmpn(d) === 0
            }),
            (s.prototype.eq = function (d) {
                return this.cmp(d) === 0
            }),
            (s.red = function (d) {
                return new G(d)
            }),
            (s.prototype.toRed = function (d) {
                return (
                    n(!this.red, "Already a number in reduction context"),
                    n(this.negative === 0, "red works only with positives"),
                    d.convertTo(this)._forceRed(d)
                )
            }),
            (s.prototype.fromRed = function () {
                return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }),
            (s.prototype._forceRed = function (d) {
                return (this.red = d), this
            }),
            (s.prototype.forceRed = function (d) {
                return n(!this.red, "Already a number in reduction context"), this._forceRed(d)
            }),
            (s.prototype.redAdd = function (d) {
                return n(this.red, "redAdd works only with red numbers"), this.red.add(this, d)
            }),
            (s.prototype.redIAdd = function (d) {
                return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, d)
            }),
            (s.prototype.redSub = function (d) {
                return n(this.red, "redSub works only with red numbers"), this.red.sub(this, d)
            }),
            (s.prototype.redISub = function (d) {
                return n(this.red, "redISub works only with red numbers"), this.red.isub(this, d)
            }),
            (s.prototype.redShl = function (d) {
                return n(this.red, "redShl works only with red numbers"), this.red.shl(this, d)
            }),
            (s.prototype.redMul = function (d) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.mul(this, d)
            }),
            (s.prototype.redIMul = function (d) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.imul(this, d)
            }),
            (s.prototype.redSqr = function () {
                return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }),
            (s.prototype.redISqr = function () {
                return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }),
            (s.prototype.redSqrt = function () {
                return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }),
            (s.prototype.redInvm = function () {
                return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }),
            (s.prototype.redNeg = function () {
                return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }),
            (s.prototype.redPow = function (d) {
                return n(this.red && !d.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, d)
            })
        var R = { k256: null, p224: null, p192: null, p25519: null }
        function U(k, d) {
            ;(this.name = k),
                (this.p = new s(d, 16)),
                (this.n = this.p.bitLength()),
                (this.k = new s(1).iushln(this.n).isub(this.p)),
                (this.tmp = this._tmp())
        }
        ;(U.prototype._tmp = function () {
            var d = new s(null)
            return (d.words = new Array(Math.ceil(this.n / 13))), d
        }),
            (U.prototype.ireduce = function (d) {
                var b = d,
                    w
                do this.split(b, this.tmp), (b = this.imulK(b)), (b = b.iadd(this.tmp)), (w = b.bitLength())
                while (w > this.n)
                var E = w < this.n ? -1 : b.ucmp(this.p)
                return E === 0 ? ((b.words[0] = 0), (b.length = 1)) : E > 0 ? b.isub(this.p) : b.strip !== void 0 ? b.strip() : b._strip(), b
            }),
            (U.prototype.split = function (d, b) {
                d.iushrn(this.n, 0, b)
            }),
            (U.prototype.imulK = function (d) {
                return d.imul(this.k)
            })
        function D() {
            U.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(D, U),
            (D.prototype.split = function (d, b) {
                for (var w = 4194303, E = Math.min(d.length, 9), T = 0; T < E; T++) b.words[T] = d.words[T]
                if (((b.length = E), d.length <= 9)) {
                    ;(d.words[0] = 0), (d.length = 1)
                    return
                }
                var A = d.words[9]
                for (b.words[b.length++] = A & w, T = 10; T < d.length; T++) {
                    var $ = d.words[T] | 0
                    ;(d.words[T - 10] = (($ & w) << 4) | (A >>> 22)), (A = $)
                }
                ;(A >>>= 22), (d.words[T - 10] = A), A === 0 && d.length > 10 ? (d.length -= 10) : (d.length -= 9)
            }),
            (D.prototype.imulK = function (d) {
                ;(d.words[d.length] = 0), (d.words[d.length + 1] = 0), (d.length += 2)
                for (var b = 0, w = 0; w < d.length; w++) {
                    var E = d.words[w] | 0
                    ;(b += E * 977), (d.words[w] = b & 67108863), (b = E * 64 + ((b / 67108864) | 0))
                }
                return d.words[d.length - 1] === 0 && (d.length--, d.words[d.length - 1] === 0 && d.length--), d
            })
        function Y() {
            U.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(Y, U)
        function J() {
            U.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(J, U)
        function te() {
            U.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(te, U),
            (te.prototype.imulK = function (d) {
                for (var b = 0, w = 0; w < d.length; w++) {
                    var E = (d.words[w] | 0) * 19 + b,
                        T = E & 67108863
                    ;(E >>>= 26), (d.words[w] = T), (b = E)
                }
                return b !== 0 && (d.words[d.length++] = b), d
            }),
            (s._prime = function (d) {
                if (R[d]) return R[d]
                var b
                if (d === "k256") b = new D()
                else if (d === "p224") b = new Y()
                else if (d === "p192") b = new J()
                else if (d === "p25519") b = new te()
                else throw new Error("Unknown prime " + d)
                return (R[d] = b), b
            })
        function G(k) {
            if (typeof k == "string") {
                var d = s._prime(k)
                ;(this.m = d.p), (this.prime = d)
            } else n(k.gtn(1), "modulus must be greater than 1"), (this.m = k), (this.prime = null)
        }
        ;(G.prototype._verify1 = function (d) {
            n(d.negative === 0, "red works only with positives"), n(d.red, "red works only with red numbers")
        }),
            (G.prototype._verify2 = function (d, b) {
                n((d.negative | b.negative) === 0, "red works only with positives"),
                    n(d.red && d.red === b.red, "red works only with red numbers")
            }),
            (G.prototype.imod = function (d) {
                return this.prime ? this.prime.ireduce(d)._forceRed(this) : d.umod(this.m)._forceRed(this)
            }),
            (G.prototype.neg = function (d) {
                return d.isZero() ? d.clone() : this.m.sub(d)._forceRed(this)
            }),
            (G.prototype.add = function (d, b) {
                this._verify2(d, b)
                var w = d.add(b)
                return w.cmp(this.m) >= 0 && w.isub(this.m), w._forceRed(this)
            }),
            (G.prototype.iadd = function (d, b) {
                this._verify2(d, b)
                var w = d.iadd(b)
                return w.cmp(this.m) >= 0 && w.isub(this.m), w
            }),
            (G.prototype.sub = function (d, b) {
                this._verify2(d, b)
                var w = d.sub(b)
                return w.cmpn(0) < 0 && w.iadd(this.m), w._forceRed(this)
            }),
            (G.prototype.isub = function (d, b) {
                this._verify2(d, b)
                var w = d.isub(b)
                return w.cmpn(0) < 0 && w.iadd(this.m), w
            }),
            (G.prototype.shl = function (d, b) {
                return this._verify1(d), this.imod(d.ushln(b))
            }),
            (G.prototype.imul = function (d, b) {
                return this._verify2(d, b), this.imod(d.imul(b))
            }),
            (G.prototype.mul = function (d, b) {
                return this._verify2(d, b), this.imod(d.mul(b))
            }),
            (G.prototype.isqr = function (d) {
                return this.imul(d, d.clone())
            }),
            (G.prototype.sqr = function (d) {
                return this.mul(d, d)
            }),
            (G.prototype.sqrt = function (d) {
                if (d.isZero()) return d.clone()
                var b = this.m.andln(3)
                if ((n(b % 2 === 1), b === 3)) {
                    var w = this.m.add(new s(1)).iushrn(2)
                    return this.pow(d, w)
                }
                for (var E = this.m.subn(1), T = 0; !E.isZero() && E.andln(1) === 0; ) T++, E.iushrn(1)
                n(!E.isZero())
                var A = new s(1).toRed(this),
                    $ = A.redNeg(),
                    S = this.m.subn(1).iushrn(1),
                    g = this.m.bitLength()
                for (g = new s(2 * g * g).toRed(this); this.pow(g, S).cmp($) !== 0; ) g.redIAdd($)
                for (var x = this.pow(g, E), O = this.pow(d, E.addn(1).iushrn(1)), j = this.pow(d, E), L = T; j.cmp(A) !== 0; ) {
                    for (var h = j, P = 0; h.cmp(A) !== 0; P++) h = h.redSqr()
                    n(P < L)
                    var M = this.pow(x, new s(1).iushln(L - P - 1))
                    ;(O = O.redMul(M)), (x = M.redSqr()), (j = j.redMul(x)), (L = P)
                }
                return O
            }),
            (G.prototype.invm = function (d) {
                var b = d._invmp(this.m)
                return b.negative !== 0 ? ((b.negative = 0), this.imod(b).redNeg()) : this.imod(b)
            }),
            (G.prototype.pow = function (d, b) {
                if (b.isZero()) return new s(1).toRed(this)
                if (b.cmpn(1) === 0) return d.clone()
                var w = 4,
                    E = new Array(1 << w)
                ;(E[0] = new s(1).toRed(this)), (E[1] = d)
                for (var T = 2; T < E.length; T++) E[T] = this.mul(E[T - 1], d)
                var A = E[0],
                    $ = 0,
                    S = 0,
                    g = b.bitLength() % 26
                for (g === 0 && (g = 26), T = b.length - 1; T >= 0; T--) {
                    for (var x = b.words[T], O = g - 1; O >= 0; O--) {
                        var j = (x >> O) & 1
                        if ((A !== E[0] && (A = this.sqr(A)), j === 0 && $ === 0)) {
                            S = 0
                            continue
                        }
                        ;($ <<= 1), ($ |= j), S++, !(S !== w && (T !== 0 || O !== 0)) && ((A = this.mul(A, E[$])), (S = 0), ($ = 0))
                    }
                    g = 26
                }
                return A
            }),
            (G.prototype.convertTo = function (d) {
                var b = d.umod(this.m)
                return b === d ? b.clone() : b
            }),
            (G.prototype.convertFrom = function (d) {
                var b = d.clone()
                return (b.red = null), b
            }),
            (s.mont = function (d) {
                return new de(d)
            })
        function de(k) {
            G.call(this, k),
                (this.shift = this.m.bitLength()),
                this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
                (this.r = new s(1).iushln(this.shift)),
                (this.r2 = this.imod(this.r.sqr())),
                (this.rinv = this.r._invmp(this.m)),
                (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
                (this.minv = this.minv.umod(this.r)),
                (this.minv = this.r.sub(this.minv))
        }
        i(de, G),
            (de.prototype.convertTo = function (d) {
                return this.imod(d.ushln(this.shift))
            }),
            (de.prototype.convertFrom = function (d) {
                var b = this.imod(d.mul(this.rinv))
                return (b.red = null), b
            }),
            (de.prototype.imul = function (d, b) {
                if (d.isZero() || b.isZero()) return (d.words[0] = 0), (d.length = 1), d
                var w = d.imul(b),
                    E = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    T = w.isub(E).iushrn(this.shift),
                    A = T
                return T.cmp(this.m) >= 0 ? (A = T.isub(this.m)) : T.cmpn(0) < 0 && (A = T.iadd(this.m)), A._forceRed(this)
            }),
            (de.prototype.mul = function (d, b) {
                if (d.isZero() || b.isZero()) return new s(0)._forceRed(this)
                var w = d.mul(b),
                    E = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    T = w.isub(E).iushrn(this.shift),
                    A = T
                return T.cmp(this.m) >= 0 ? (A = T.isub(this.m)) : T.cmpn(0) < 0 && (A = T.iadd(this.m)), A._forceRed(this)
            }),
            (de.prototype.invm = function (d) {
                var b = this.imod(d._invmp(this.m).mul(this.r2))
                return b._forceRed(this)
            })
    })(t, Vt)
})(zb)
var Oe = zb.exports
const Rw = "logger/5.5.0"
let ap = !1,
    lp = !1
const Yl = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 }
let cp = Yl.default,
    Zf = null
function Lw() {
    try {
        const t = []
        if (
            (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }),
            t.length)
        )
            throw new Error("missing " + t.join(", "))
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const fp = Lw()
var rd
;(function (t) {
    ;(t.DEBUG = "DEBUG"), (t.INFO = "INFO"), (t.WARNING = "WARNING"), (t.ERROR = "ERROR"), (t.OFF = "OFF")
})(rd || (rd = {}))
var za
;(function (t) {
    ;(t.UNKNOWN_ERROR = "UNKNOWN_ERROR"),
        (t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED"),
        (t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION"),
        (t.NETWORK_ERROR = "NETWORK_ERROR"),
        (t.SERVER_ERROR = "SERVER_ERROR"),
        (t.TIMEOUT = "TIMEOUT"),
        (t.BUFFER_OVERRUN = "BUFFER_OVERRUN"),
        (t.NUMERIC_FAULT = "NUMERIC_FAULT"),
        (t.MISSING_NEW = "MISSING_NEW"),
        (t.INVALID_ARGUMENT = "INVALID_ARGUMENT"),
        (t.MISSING_ARGUMENT = "MISSING_ARGUMENT"),
        (t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT"),
        (t.CALL_EXCEPTION = "CALL_EXCEPTION"),
        (t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"),
        (t.NONCE_EXPIRED = "NONCE_EXPIRED"),
        (t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED"),
        (t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT"),
        (t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED")
})(za || (za = {}))
const up = "0123456789abcdef"
class F {
    constructor(e) {
        Object.defineProperty(this, "version", { enumerable: !0, value: e, writable: !1 })
    }
    _log(e, r) {
        const n = e.toLowerCase()
        Yl[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(cp > Yl[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(F.levels.DEBUG, e)
    }
    info(...e) {
        this._log(F.levels.INFO, e)
    }
    warn(...e) {
        this._log(F.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (lp) return this.makeError("censored error", r, {})
        r || (r = F.errors.UNKNOWN_ERROR), n || (n = {})
        const i = []
        Object.keys(n).forEach((a) => {
            const l = n[a]
            try {
                if (l instanceof Uint8Array) {
                    let c = ""
                    for (let f = 0; f < l.length; f++) (c += up[l[f] >> 4]), (c += up[l[f] & 15])
                    i.push(a + "=Uint8Array(0x" + c + ")")
                } else i.push(a + "=" + JSON.stringify(l))
            } catch {
                i.push(a + "=" + JSON.stringify(n[a].toString()))
            }
        }),
            i.push(`code=${r}`),
            i.push(`version=${this.version}`)
        const s = e
        i.length && (e += " (" + i.join(", ") + ")")
        const o = new Error(e)
        return (
            (o.reason = s),
            (o.code = r),
            Object.keys(n).forEach(function (a) {
                o[a] = n[a]
            }),
            o
        )
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, F.errors.INVALID_ARGUMENT, { argument: r, value: n })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        fp &&
            this.throwError("platform missing String.prototype.normalize", F.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize",
                form: fp,
            })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" &&
            (r == null && (r = "value not safe"),
            (e < 0 || e >= 9007199254740991) &&
                this.throwError(r, F.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "out-of-safe-range", value: e }),
            e % 1 && this.throwError(r, F.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "non-integer", value: e }))
    }
    checkArgumentCount(e, r, n) {
        n ? (n = ": " + n) : (n = ""),
            e < r && this.throwError("missing argument" + n, F.errors.MISSING_ARGUMENT, { count: e, expectedCount: r }),
            e > r && this.throwError("too many arguments" + n, F.errors.UNEXPECTED_ARGUMENT, { count: e, expectedCount: r })
    }
    checkNew(e, r) {
        ;(e === Object || e == null) && this.throwError("missing new", F.errors.MISSING_NEW, { name: r.name })
    }
    checkAbstract(e, r) {
        e === r
            ? this.throwError(
                  "cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class",
                  F.errors.UNSUPPORTED_OPERATION,
                  { name: e.name, operation: "new" }
              )
            : (e === Object || e == null) && this.throwError("missing new", F.errors.MISSING_NEW, { name: r.name })
    }
    static globalLogger() {
        return Zf || (Zf = new F(Rw)), Zf
    }
    static setCensorship(e, r) {
        if (
            (!e &&
                r &&
                this.globalLogger().throwError("cannot permanently disable censorship", F.errors.UNSUPPORTED_OPERATION, {
                    operation: "setCensorship",
                }),
            ap)
        ) {
            if (!e) return
            this.globalLogger().throwError("error censorship permanent", F.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" })
        }
        ;(lp = !!e), (ap = !!r)
    }
    static setLogLevel(e) {
        const r = Yl[e.toLowerCase()]
        if (r == null) {
            F.globalLogger().warn("invalid log level - " + e)
            return
        }
        cp = r
    }
    static from(e) {
        return new F(e)
    }
}
F.errors = za
F.levels = rd
const Dw = "bytes/5.5.0",
    Lt = new F(Dw)
function Kb(t) {
    return !!t.toHexString
}
function bo(t) {
    return (
        t.slice ||
            (t.slice = function () {
                const e = Array.prototype.slice.call(arguments)
                return bo(new Uint8Array(Array.prototype.slice.apply(t, e)))
            }),
        t
    )
}
function ol(t) {
    return (Le(t) && !(t.length % 2)) || Ji(t)
}
function dp(t) {
    return typeof t == "number" && t == t && t % 1 === 0
}
function Ji(t) {
    if (t == null) return !1
    if (t.constructor === Uint8Array) return !0
    if (typeof t == "string" || !dp(t.length) || t.length < 0) return !1
    for (let e = 0; e < t.length; e++) {
        const r = t[e]
        if (!dp(r) || r < 0 || r >= 256) return !1
    }
    return !0
}
function le(t, e) {
    if ((e || (e = {}), typeof t == "number")) {
        Lt.checkSafeUint53(t, "invalid arrayify value")
        const r = []
        for (; t; ) r.unshift(t & 255), (t = parseInt(String(t / 256)))
        return r.length === 0 && r.push(0), bo(new Uint8Array(r))
    }
    if ((e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Kb(t) && (t = t.toHexString()), Le(t))) {
        let r = t.substring(2)
        r.length % 2 &&
            (e.hexPad === "left"
                ? (r = "0x0" + r.substring(2))
                : e.hexPad === "right"
                ? (r += "0")
                : Lt.throwArgumentError("hex data is odd-length", "value", t))
        const n = []
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16))
        return bo(new Uint8Array(n))
    }
    return Ji(t) ? bo(new Uint8Array(t)) : Lt.throwArgumentError("invalid arrayify value", "value", t)
}
function ft(t) {
    const e = t.map((i) => le(i)),
        r = e.reduce((i, s) => i + s.length, 0),
        n = new Uint8Array(r)
    return e.reduce((i, s) => (n.set(s, i), i + s.length), 0), bo(n)
}
function In(t) {
    let e = le(t)
    if (e.length === 0) return e
    let r = 0
    for (; r < e.length && e[r] === 0; ) r++
    return r && (e = e.slice(r)), e
}
function Ca(t, e) {
    ;(t = le(t)), t.length > e && Lt.throwArgumentError("value out of range", "value", arguments[0])
    const r = new Uint8Array(e)
    return r.set(t, e - t.length), bo(r)
}
function Le(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || (e && t.length !== 2 + 2 * e))
}
const Qf = "0123456789abcdef"
function pe(t, e) {
    if ((e || (e = {}), typeof t == "number")) {
        Lt.checkSafeUint53(t, "invalid hexlify value")
        let r = ""
        for (; t; ) (r = Qf[t & 15] + r), (t = Math.floor(t / 16))
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return (t = t.toString(16)), t.length % 2 ? "0x0" + t : "0x" + t
    if ((e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Kb(t))) return t.toHexString()
    if (Le(t))
        return (
            t.length % 2 &&
                (e.hexPad === "left"
                    ? (t = "0x0" + t.substring(2))
                    : e.hexPad === "right"
                    ? (t += "0")
                    : Lt.throwArgumentError("hex data is odd-length", "value", t)),
            t.toLowerCase()
        )
    if (Ji(t)) {
        let r = "0x"
        for (let n = 0; n < t.length; n++) {
            let i = t[n]
            r += Qf[(i & 240) >> 4] + Qf[i & 15]
        }
        return r
    }
    return Lt.throwArgumentError("invalid hexlify value", "value", t)
}
function Hi(t) {
    if (typeof t != "string") t = pe(t)
    else if (!Le(t) || t.length % 2) return null
    return (t.length - 2) / 2
}
function Er(t, e, r) {
    return (
        typeof t != "string" ? (t = pe(t)) : (!Le(t) || t.length % 2) && Lt.throwArgumentError("invalid hexData", "value", t),
        (e = 2 + 2 * e),
        r != null ? "0x" + t.substring(e, 2 + 2 * r) : "0x" + t.substring(e)
    )
}
function qr(t) {
    let e = "0x"
    return (
        t.forEach((r) => {
            e += pe(r).substring(2)
        }),
        e
    )
}
function al(t) {
    const e = Gb(pe(t, { hexPad: "left" }))
    return e === "0x" ? "0x0" : e
}
function Gb(t) {
    typeof t != "string" && (t = pe(t)), Le(t) || Lt.throwArgumentError("invalid hex string", "value", t), (t = t.substring(2))
    let e = 0
    for (; e < t.length && t[e] === "0"; ) e++
    return "0x" + t.substring(e)
}
function ut(t, e) {
    for (
        typeof t != "string" ? (t = pe(t)) : Le(t) || Lt.throwArgumentError("invalid hex string", "value", t),
            t.length > 2 * e + 2 && Lt.throwArgumentError("value out of range", "value", arguments[1]);
        t.length < 2 * e + 2;

    )
        t = "0x0" + t.substring(2)
    return t
}
function Us(t) {
    const e = { r: "0x", s: "0x", _vs: "0x", recoveryParam: 0, v: 0 }
    if (ol(t)) {
        const r = le(t)
        r.length !== 65 && Lt.throwArgumentError("invalid signature string; must be 65 bytes", "signature", t),
            (e.r = pe(r.slice(0, 32))),
            (e.s = pe(r.slice(32, 64))),
            (e.v = r[64]),
            e.v < 27 && (e.v === 0 || e.v === 1 ? (e.v += 27) : Lt.throwArgumentError("signature invalid v byte", "signature", t)),
            (e.recoveryParam = 1 - (e.v % 2)),
            e.recoveryParam && (r[32] |= 128),
            (e._vs = pe(r.slice(32, 64)))
    } else {
        if (((e.r = t.r), (e.s = t.s), (e.v = t.v), (e.recoveryParam = t.recoveryParam), (e._vs = t._vs), e._vs != null)) {
            const i = Ca(le(e._vs), 32)
            e._vs = pe(i)
            const s = i[0] >= 128 ? 1 : 0
            e.recoveryParam == null
                ? (e.recoveryParam = s)
                : e.recoveryParam !== s && Lt.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t),
                (i[0] &= 127)
            const o = pe(i)
            e.s == null ? (e.s = o) : e.s !== o && Lt.throwArgumentError("signature v mismatch _vs", "signature", t)
        }
        if (e.recoveryParam == null)
            e.v == null
                ? Lt.throwArgumentError("signature missing v and recoveryParam", "signature", t)
                : e.v === 0 || e.v === 1
                ? (e.recoveryParam = e.v)
                : (e.recoveryParam = 1 - (e.v % 2))
        else if (e.v == null) e.v = 27 + e.recoveryParam
        else {
            const i = e.v === 0 || e.v === 1 ? e.v : 1 - (e.v % 2)
            e.recoveryParam !== i && Lt.throwArgumentError("signature recoveryParam mismatch v", "signature", t)
        }
        e.r == null || !Le(e.r) ? Lt.throwArgumentError("signature missing or invalid r", "signature", t) : (e.r = ut(e.r, 32)),
            e.s == null || !Le(e.s) ? Lt.throwArgumentError("signature missing or invalid s", "signature", t) : (e.s = ut(e.s, 32))
        const r = le(e.s)
        r[0] >= 128 && Lt.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128)
        const n = pe(r)
        e._vs && (Le(e._vs) || Lt.throwArgumentError("signature invalid _vs", "signature", t), (e._vs = ut(e._vs, 32))),
            e._vs == null ? (e._vs = n) : e._vs !== n && Lt.throwArgumentError("signature _vs mismatch v and s", "signature", t)
    }
    return e
}
function nd(t) {
    return (t = Us(t)), pe(ft([t.r, t.s, t.recoveryParam ? "0x1c" : "0x1b"]))
}
const Wb = "bignumber/5.5.0"
var Ka = Oe.BN
const bn = new F(Wb),
    eu = {},
    hp = 9007199254740991
function Fw(t) {
    return (
        t != null &&
        (ce.isBigNumber(t) ||
            (typeof t == "number" && t % 1 === 0) ||
            (typeof t == "string" && !!t.match(/^-?[0-9]+$/)) ||
            Le(t) ||
            typeof t == "bigint" ||
            Ji(t))
    )
}
let pp = !1
class ce {
    constructor(e, r) {
        bn.checkNew(new.target, ce),
            e !== eu &&
                bn.throwError("cannot call constructor directly; use BigNumber.from", F.errors.UNSUPPORTED_OPERATION, {
                    operation: "new (BigNumber)",
                }),
            (this._hex = r),
            (this._isBigNumber = !0),
            Object.freeze(this)
    }
    fromTwos(e) {
        return xr(ze(this).fromTwos(e))
    }
    toTwos(e) {
        return xr(ze(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? ce.from(this._hex.substring(1)) : this
    }
    add(e) {
        return xr(ze(this).add(ze(e)))
    }
    sub(e) {
        return xr(ze(this).sub(ze(e)))
    }
    div(e) {
        return ce.from(e).isZero() && Ur("division by zero", "div"), xr(ze(this).div(ze(e)))
    }
    mul(e) {
        return xr(ze(this).mul(ze(e)))
    }
    mod(e) {
        const r = ze(e)
        return r.isNeg() && Ur("cannot modulo negative values", "mod"), xr(ze(this).umod(r))
    }
    pow(e) {
        const r = ze(e)
        return r.isNeg() && Ur("cannot raise to negative values", "pow"), xr(ze(this).pow(r))
    }
    and(e) {
        const r = ze(e)
        return (this.isNegative() || r.isNeg()) && Ur("cannot 'and' negative values", "and"), xr(ze(this).and(r))
    }
    or(e) {
        const r = ze(e)
        return (this.isNegative() || r.isNeg()) && Ur("cannot 'or' negative values", "or"), xr(ze(this).or(r))
    }
    xor(e) {
        const r = ze(e)
        return (this.isNegative() || r.isNeg()) && Ur("cannot 'xor' negative values", "xor"), xr(ze(this).xor(r))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && Ur("cannot mask negative values", "mask"), xr(ze(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && Ur("cannot shift negative values", "shl"), xr(ze(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && Ur("cannot shift negative values", "shr"), xr(ze(this).shrn(e))
    }
    eq(e) {
        return ze(this).eq(ze(e))
    }
    lt(e) {
        return ze(this).lt(ze(e))
    }
    lte(e) {
        return ze(this).lte(ze(e))
    }
    gt(e) {
        return ze(this).gt(ze(e))
    }
    gte(e) {
        return ze(this).gte(ze(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return ze(this).isZero()
    }
    toNumber() {
        try {
            return ze(this).toNumber()
        } catch {
            Ur("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return bn.throwError("this platform does not support BigInt", F.errors.UNSUPPORTED_OPERATION, { value: this.toString() })
    }
    toString() {
        return (
            arguments.length > 0 &&
                (arguments[0] === 10
                    ? pp || ((pp = !0), bn.warn("BigNumber.toString does not accept any parameters; base-10 is assumed"))
                    : arguments[0] === 16
                    ? bn.throwError(
                          "BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",
                          F.errors.UNEXPECTED_ARGUMENT,
                          {}
                      )
                    : bn.throwError("BigNumber.toString does not accept parameters", F.errors.UNEXPECTED_ARGUMENT, {})),
            ze(this).toString(10)
        )
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return { type: "BigNumber", hex: this.toHexString() }
    }
    static from(e) {
        if (e instanceof ce) return e
        if (typeof e == "string")
            return e.match(/^-?0x[0-9a-f]+$/i)
                ? new ce(eu, Ga(e))
                : e.match(/^-?[0-9]+$/)
                ? new ce(eu, Ga(new Ka(e)))
                : bn.throwArgumentError("invalid BigNumber string", "value", e)
        if (typeof e == "number")
            return (
                e % 1 && Ur("underflow", "BigNumber.from", e), (e >= hp || e <= -hp) && Ur("overflow", "BigNumber.from", e), ce.from(String(e))
            )
        const r = e
        if (typeof r == "bigint") return ce.from(r.toString())
        if (Ji(r)) return ce.from(pe(r))
        if (r)
            if (r.toHexString) {
                const n = r.toHexString()
                if (typeof n == "string") return ce.from(n)
            } else {
                let n = r._hex
                if (
                    (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (Le(n) || (n[0] === "-" && Le(n.substring(1)))))
                )
                    return ce.from(n)
            }
        return bn.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}
function Ga(t) {
    if (typeof t != "string") return Ga(t.toString(16))
    if (t[0] === "-")
        return (t = t.substring(1)), t[0] === "-" && bn.throwArgumentError("invalid hex", "value", t), (t = Ga(t)), t === "0x00" ? t : "-" + t
    if ((t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x")) return "0x00"
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00"; ) t = "0x" + t.substring(4)
    return t
}
function xr(t) {
    return ce.from(Ga(t))
}
function ze(t) {
    const e = ce.from(t).toHexString()
    return e[0] === "-" ? new Ka("-" + e.substring(3), 16) : new Ka(e.substring(2), 16)
}
function Ur(t, e, r) {
    const n = { fault: t, operation: e }
    return r != null && (n.value = r), bn.throwError(t, F.errors.NUMERIC_FAULT, n)
}
function Vw(t) {
    return new Ka(t, 36).toString(16)
}
function Uw(t) {
    return new Ka(t, 16).toString(36)
}
const lr = new F(Wb),
    ka = {},
    Jb = ce.from(0),
    Xb = ce.from(-1)
function Yb(t, e, r, n) {
    const i = { fault: e, operation: r }
    return n !== void 0 && (i.value = n), lr.throwError(t, F.errors.NUMERIC_FAULT, i)
}
let Na = "0"
for (; Na.length < 256; ) Na += Na
function m0(t) {
    if (typeof t != "number")
        try {
            t = ce.from(t).toNumber()
        } catch {}
    return typeof t == "number" && t >= 0 && t <= 256 && !(t % 1)
        ? "1" + Na.substring(0, t)
        : lr.throwArgumentError("invalid decimal size", "decimals", t)
}
function Zl(t, e) {
    e == null && (e = 0)
    const r = m0(e)
    t = ce.from(t)
    const n = t.lt(Jb)
    n && (t = t.mul(Xb))
    let i = t.mod(r).toString()
    for (; i.length < r.length - 1; ) i = "0" + i
    i = i.match(/^([0-9]*[1-9]|0)(0*)/)[1]
    const s = t.div(r).toString()
    return r.length === 1 ? (t = s) : (t = s + "." + i), n && (t = "-" + t), t
}
function mn(t, e) {
    e == null && (e = 0)
    const r = m0(e)
    ;(typeof t != "string" || !t.match(/^-?[0-9.]+$/)) && lr.throwArgumentError("invalid decimal value", "value", t)
    const n = t.substring(0, 1) === "-"
    n && (t = t.substring(1)), t === "." && lr.throwArgumentError("missing value", "value", t)
    const i = t.split(".")
    i.length > 2 && lr.throwArgumentError("too many decimal points", "value", t)
    let s = i[0],
        o = i[1]
    for (s || (s = "0"), o || (o = "0"); o[o.length - 1] === "0"; ) o = o.substring(0, o.length - 1)
    for (
        o.length > r.length - 1 && Yb("fractional component exceeds decimals", "underflow", "parseFixed"), o === "" && (o = "0");
        o.length < r.length - 1;

    )
        o += "0"
    const a = ce.from(s),
        l = ce.from(o)
    let c = a.mul(r).add(l)
    return n && (c = c.mul(Xb)), c
}
class xo {
    constructor(e, r, n, i) {
        e !== ka &&
            lr.throwError("cannot use FixedFormat constructor; use FixedFormat.from", F.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat",
            }),
            (this.signed = r),
            (this.width = n),
            (this.decimals = i),
            (this.name = (r ? "" : "u") + "fixed" + String(n) + "x" + String(i)),
            (this._multiplier = m0(i)),
            Object.freeze(this)
    }
    static from(e) {
        if (e instanceof xo) return e
        typeof e == "number" && (e = `fixed128x${e}`)
        let r = !0,
            n = 128,
            i = 18
        if (typeof e == "string") {
            if (e !== "fixed")
                if (e === "ufixed") r = !1
                else {
                    const s = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/)
                    s || lr.throwArgumentError("invalid fixed format", "format", e),
                        (r = s[1] !== "u"),
                        (n = parseInt(s[2])),
                        (i = parseInt(s[3]))
                }
        } else if (e) {
            const s = (o, a, l) =>
                e[o] == null
                    ? l
                    : (typeof e[o] !== a && lr.throwArgumentError("invalid fixed format (" + o + " not " + a + ")", "format." + o, e[o]), e[o])
            ;(r = s("signed", "boolean", r)), (n = s("width", "number", n)), (i = s("decimals", "number", i))
        }
        return (
            n % 8 && lr.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", n),
            i > 80 && lr.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", i),
            new xo(ka, r, n, i)
        )
    }
}
class qt {
    constructor(e, r, n, i) {
        lr.checkNew(new.target, qt),
            e !== ka &&
                lr.throwError("cannot use FixedNumber constructor; use FixedNumber.from", F.errors.UNSUPPORTED_OPERATION, {
                    operation: "new FixedFormat",
                }),
            (this.format = i),
            (this._hex = r),
            (this._value = n),
            (this._isFixedNumber = !0),
            Object.freeze(this)
    }
    _checkFormat(e) {
        this.format.name !== e.format.name && lr.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", e)
    }
    addUnsafe(e) {
        this._checkFormat(e)
        const r = mn(this._value, this.format.decimals),
            n = mn(e._value, e.format.decimals)
        return qt.fromValue(r.add(n), this.format.decimals, this.format)
    }
    subUnsafe(e) {
        this._checkFormat(e)
        const r = mn(this._value, this.format.decimals),
            n = mn(e._value, e.format.decimals)
        return qt.fromValue(r.sub(n), this.format.decimals, this.format)
    }
    mulUnsafe(e) {
        this._checkFormat(e)
        const r = mn(this._value, this.format.decimals),
            n = mn(e._value, e.format.decimals)
        return qt.fromValue(r.mul(n).div(this.format._multiplier), this.format.decimals, this.format)
    }
    divUnsafe(e) {
        this._checkFormat(e)
        const r = mn(this._value, this.format.decimals),
            n = mn(e._value, e.format.decimals)
        return qt.fromValue(r.mul(this.format._multiplier).div(n), this.format.decimals, this.format)
    }
    floor() {
        const e = this.toString().split(".")
        e.length === 1 && e.push("0")
        let r = qt.from(e[0], this.format)
        const n = !e[1].match(/^(0*)$/)
        return this.isNegative() && n && (r = r.subUnsafe(gp.toFormat(r.format))), r
    }
    ceiling() {
        const e = this.toString().split(".")
        e.length === 1 && e.push("0")
        let r = qt.from(e[0], this.format)
        const n = !e[1].match(/^(0*)$/)
        return !this.isNegative() && n && (r = r.addUnsafe(gp.toFormat(r.format))), r
    }
    round(e) {
        e == null && (e = 0)
        const r = this.toString().split(".")
        if (
            (r.length === 1 && r.push("0"),
            (e < 0 || e > 80 || e % 1) && lr.throwArgumentError("invalid decimal count", "decimals", e),
            r[1].length <= e)
        )
            return this
        const n = qt.from("1" + Na.substring(0, e), this.format),
            i = Hw.toFormat(this.format)
        return this.mulUnsafe(n).addUnsafe(i).floor().divUnsafe(n)
    }
    isZero() {
        return this._value === "0.0" || this._value === "0"
    }
    isNegative() {
        return this._value[0] === "-"
    }
    toString() {
        return this._value
    }
    toHexString(e) {
        if (e == null) return this._hex
        e % 8 && lr.throwArgumentError("invalid byte width", "width", e)
        const r = ce.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString()
        return ut(r, e / 8)
    }
    toUnsafeFloat() {
        return parseFloat(this.toString())
    }
    toFormat(e) {
        return qt.fromString(this._value, e)
    }
    static fromValue(e, r, n) {
        return (
            n == null && r != null && !Fw(r) && ((n = r), (r = null)),
            r == null && (r = 0),
            n == null && (n = "fixed"),
            qt.fromString(Zl(e, r), xo.from(n))
        )
    }
    static fromString(e, r) {
        r == null && (r = "fixed")
        const n = xo.from(r),
            i = mn(e, n.decimals)
        !n.signed && i.lt(Jb) && Yb("unsigned value cannot be negative", "overflow", "value", e)
        let s = null
        n.signed ? (s = i.toTwos(n.width).toHexString()) : ((s = i.toHexString()), (s = ut(s, n.width / 8)))
        const o = Zl(i, n.decimals)
        return new qt(ka, s, o, n)
    }
    static fromBytes(e, r) {
        r == null && (r = "fixed")
        const n = xo.from(r)
        if (le(e).length > n.width / 8) throw new Error("overflow")
        let i = ce.from(e)
        n.signed && (i = i.fromTwos(n.width))
        const s = i.toTwos((n.signed ? 0 : 1) + n.width).toHexString(),
            o = Zl(i, n.decimals)
        return new qt(ka, s, o, n)
    }
    static from(e, r) {
        if (typeof e == "string") return qt.fromString(e, r)
        if (Ji(e)) return qt.fromBytes(e, r)
        try {
            return qt.fromValue(e, 0, r)
        } catch (n) {
            if (n.code !== F.errors.INVALID_ARGUMENT) throw n
        }
        return lr.throwArgumentError("invalid FixedNumber value", "value", e)
    }
    static isFixedNumber(e) {
        return !!(e && e._isFixedNumber)
    }
}
const gp = qt.from(1),
    Hw = qt.from("0.5"),
    qw = "properties/5.5.0"
var jw =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const yc = new F(qw)
function X(t, e, r) {
    Object.defineProperty(t, e, { enumerable: !0, value: r, writable: !1 })
}
function Yt(t, e) {
    for (let r = 0; r < 32; r++) {
        if (t[e]) return t[e]
        if (!t.prototype || typeof t.prototype != "object") break
        t = Object.getPrototypeOf(t.prototype).constructor
    }
    return null
}
function Dt(t) {
    return jw(this, void 0, void 0, function* () {
        const e = Object.keys(t).map((n) => {
            const i = t[n]
            return Promise.resolve(i).then((s) => ({ key: n, value: s }))
        })
        return (yield Promise.all(e)).reduce((n, i) => ((n[i.key] = i.value), n), {})
    })
}
function b0(t, e) {
    ;(!t || typeof t != "object") && yc.throwArgumentError("invalid object", "object", t),
        Object.keys(t).forEach((r) => {
            e[r] || yc.throwArgumentError("invalid object key - " + r, "transaction:" + r, t)
        })
}
function Pt(t) {
    const e = {}
    for (const r in t) e[r] = t[r]
    return e
}
const zw = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 }
function Zb(t) {
    if (t == null || zw[typeof t]) return !0
    if (Array.isArray(t) || typeof t == "object") {
        if (!Object.isFrozen(t)) return !1
        const e = Object.keys(t)
        for (let r = 0; r < e.length; r++) {
            let n = null
            try {
                n = t[e[r]]
            } catch {
                continue
            }
            if (!Zb(n)) return !1
        }
        return !0
    }
    return yc.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}
function Kw(t) {
    if (Zb(t)) return t
    if (Array.isArray(t)) return Object.freeze(t.map((e) => pr(e)))
    if (typeof t == "object") {
        const e = {}
        for (const r in t) {
            const n = t[r]
            n !== void 0 && X(e, r, pr(n))
        }
        return e
    }
    return yc.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}
function pr(t) {
    return Kw(t)
}
class Hs {
    constructor(e) {
        for (const r in e) this[r] = pr(e[r])
    }
}
const ll = "abi/5.5.0",
    We = new F(ll),
    Os = {}
let mp = { calldata: !0, memory: !0, storage: !0 },
    Gw = { calldata: !0, memory: !0 }
function Pl(t, e) {
    if (t === "bytes" || t === "string") {
        if (mp[e]) return !0
    } else if (t === "address") {
        if (e === "payable") return !0
    } else if ((t.indexOf("[") >= 0 || t === "tuple") && Gw[e]) return !0
    return (mp[e] || e === "payable") && We.throwArgumentError("invalid modifier", "name", e), !1
}
function Ww(t, e) {
    let r = t
    function n(a) {
        We.throwArgumentError(`unexpected character at position ${a}`, "param", t)
    }
    t = t.replace(/\s/g, " ")
    function i(a) {
        let l = { type: "", name: "", parent: a, state: { allowType: !0 } }
        return e && (l.indexed = !1), l
    }
    let s = { type: "", name: "", state: { allowType: !0 } },
        o = s
    for (let a = 0; a < t.length; a++) {
        let l = t[a]
        switch (l) {
            case "(":
                o.state.allowType && o.type === "" ? (o.type = "tuple") : o.state.allowParams || n(a),
                    (o.state.allowType = !1),
                    (o.type = io(o.type)),
                    (o.components = [i(o)]),
                    (o = o.components[0])
                break
            case ")":
                delete o.state,
                    o.name === "indexed" && (e || n(a), (o.indexed = !0), (o.name = "")),
                    Pl(o.type, o.name) && (o.name = ""),
                    (o.type = io(o.type))
                let c = o
                ;(o = o.parent), o || n(a), delete c.parent, (o.state.allowParams = !1), (o.state.allowName = !0), (o.state.allowArray = !0)
                break
            case ",":
                delete o.state,
                    o.name === "indexed" && (e || n(a), (o.indexed = !0), (o.name = "")),
                    Pl(o.type, o.name) && (o.name = ""),
                    (o.type = io(o.type))
                let f = i(o.parent)
                o.parent.components.push(f), delete o.parent, (o = f)
                break
            case " ":
                o.state.allowType &&
                    o.type !== "" &&
                    ((o.type = io(o.type)), delete o.state.allowType, (o.state.allowName = !0), (o.state.allowParams = !0)),
                    o.state.allowName &&
                        o.name !== "" &&
                        (o.name === "indexed"
                            ? (e || n(a), o.indexed && n(a), (o.indexed = !0), (o.name = ""))
                            : Pl(o.type, o.name)
                            ? (o.name = "")
                            : (o.state.allowName = !1))
                break
            case "[":
                o.state.allowArray || n(a), (o.type += l), (o.state.allowArray = !1), (o.state.allowName = !1), (o.state.readArray = !0)
                break
            case "]":
                o.state.readArray || n(a), (o.type += l), (o.state.readArray = !1), (o.state.allowArray = !0), (o.state.allowName = !0)
                break
            default:
                o.state.allowType
                    ? ((o.type += l), (o.state.allowParams = !0), (o.state.allowArray = !0))
                    : o.state.allowName
                    ? ((o.name += l), delete o.state.allowArray)
                    : o.state.readArray
                    ? (o.type += l)
                    : n(a)
        }
    }
    return (
        o.parent && We.throwArgumentError("unexpected eof", "param", t),
        delete s.state,
        o.name === "indexed"
            ? (e || n(r.length - 7), o.indexed && n(r.length - 7), (o.indexed = !0), (o.name = ""))
            : Pl(o.type, o.name) && (o.name = ""),
        (s.type = io(s.type)),
        s
    )
}
function Ql(t, e) {
    for (let r in e) X(t, r, e[r])
}
const Xe = Object.freeze({ sighash: "sighash", minimal: "minimal", full: "full", json: "json" }),
    Jw = new RegExp(/^(.*)\[([0-9]*)\]$/)
class Wt {
    constructor(e, r) {
        e !== Os && We.throwError("use fromString", F.errors.UNSUPPORTED_OPERATION, { operation: "new ParamType()" }), Ql(this, r)
        let n = this.type.match(Jw)
        n
            ? Ql(this, {
                  arrayLength: parseInt(n[2] || "-1"),
                  arrayChildren: Wt.fromObject({ type: n[1], components: this.components }),
                  baseType: "array",
              })
            : Ql(this, { arrayLength: null, arrayChildren: null, baseType: this.components != null ? "tuple" : this.type }),
            (this._isParamType = !0),
            Object.freeze(this)
    }
    format(e) {
        if ((e || (e = Xe.sighash), Xe[e] || We.throwArgumentError("invalid format type", "format", e), e === Xe.json)) {
            let n = { type: this.baseType === "tuple" ? "tuple" : this.type, name: this.name || void 0 }
            return (
                typeof this.indexed == "boolean" && (n.indexed = this.indexed),
                this.components && (n.components = this.components.map((i) => JSON.parse(i.format(e)))),
                JSON.stringify(n)
            )
        }
        let r = ""
        return (
            this.baseType === "array"
                ? ((r += this.arrayChildren.format(e)), (r += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]"))
                : this.baseType === "tuple"
                ? (e !== Xe.sighash && (r += this.type),
                  (r += "(" + this.components.map((n) => n.format(e)).join(e === Xe.full ? ", " : ",") + ")"))
                : (r += this.type),
            e !== Xe.sighash && (this.indexed === !0 && (r += " indexed"), e === Xe.full && this.name && (r += " " + this.name)),
            r
        )
    }
    static from(e, r) {
        return typeof e == "string" ? Wt.fromString(e, r) : Wt.fromObject(e)
    }
    static fromObject(e) {
        return Wt.isParamType(e)
            ? e
            : new Wt(Os, {
                  name: e.name || null,
                  type: io(e.type),
                  indexed: e.indexed == null ? null : !!e.indexed,
                  components: e.components ? e.components.map(Wt.fromObject) : null,
              })
    }
    static fromString(e, r) {
        function n(i) {
            return Wt.fromObject({ name: i.name, type: i.type, indexed: i.indexed, components: i.components })
        }
        return n(Ww(e, !!r))
    }
    static isParamType(e) {
        return !!(e != null && e._isParamType)
    }
}
function Wa(t, e) {
    return Yw(t).map((r) => Wt.fromString(r, e))
}
class En {
    constructor(e, r) {
        e !== Os && We.throwError("use a static from method", F.errors.UNSUPPORTED_OPERATION, { operation: "new Fragment()" }),
            Ql(this, r),
            (this._isFragment = !0),
            Object.freeze(this)
    }
    static from(e) {
        return En.isFragment(e) ? e : typeof e == "string" ? En.fromString(e) : En.fromObject(e)
    }
    static fromObject(e) {
        if (En.isFragment(e)) return e
        switch (e.type) {
            case "function":
                return nn.fromObject(e)
            case "event":
                return _n.fromObject(e)
            case "constructor":
                return rn.fromObject(e)
            case "error":
                return Yn.fromObject(e)
            case "fallback":
            case "receive":
                return null
        }
        return We.throwArgumentError("invalid fragment object", "value", e)
    }
    static fromString(e) {
        return (
            (e = e.replace(/\s/g, " ")),
            (e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")),
            (e = e.trim()),
            e.split(" ")[0] === "event"
                ? _n.fromString(e.substring(5).trim())
                : e.split(" ")[0] === "function"
                ? nn.fromString(e.substring(8).trim())
                : e.split("(")[0].trim() === "constructor"
                ? rn.fromString(e.trim())
                : e.split(" ")[0] === "error"
                ? Yn.fromString(e.substring(5).trim())
                : We.throwArgumentError("unsupported fragment", "value", e)
        )
    }
    static isFragment(e) {
        return !!(e && e._isFragment)
    }
}
class _n extends En {
    format(e) {
        if ((e || (e = Xe.sighash), Xe[e] || We.throwArgumentError("invalid format type", "format", e), e === Xe.json))
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((n) => JSON.parse(n.format(e))),
            })
        let r = ""
        return (
            e !== Xe.sighash && (r += "event "),
            (r += this.name + "(" + this.inputs.map((n) => n.format(e)).join(e === Xe.full ? ", " : ",") + ") "),
            e !== Xe.sighash && this.anonymous && (r += "anonymous "),
            r.trim()
        )
    }
    static from(e) {
        return typeof e == "string" ? _n.fromString(e) : _n.fromObject(e)
    }
    static fromObject(e) {
        if (_n.isEventFragment(e)) return e
        e.type !== "event" && We.throwArgumentError("invalid event object", "value", e)
        const r = { name: Ja(e.name), anonymous: e.anonymous, inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [], type: "event" }
        return new _n(Os, r)
    }
    static fromString(e) {
        let r = e.match(Xa)
        r || We.throwArgumentError("invalid event string", "value", e)
        let n = !1
        return (
            r[3].split(" ").forEach((i) => {
                switch (i.trim()) {
                    case "anonymous":
                        n = !0
                        break
                    case "":
                        break
                    default:
                        We.warn("unknown modifier: " + i)
                }
            }),
            _n.fromObject({ name: r[1].trim(), anonymous: n, inputs: Wa(r[2], !0), type: "event" })
        )
    }
    static isEventFragment(e) {
        return e && e._isFragment && e.type === "event"
    }
}
function Qb(t, e) {
    e.gas = null
    let r = t.split("@")
    return r.length !== 1
        ? (r.length > 2 && We.throwArgumentError("invalid human-readable ABI signature", "value", t),
          r[1].match(/^[0-9]+$/) || We.throwArgumentError("invalid human-readable ABI signature gas", "value", t),
          (e.gas = ce.from(r[1])),
          r[0])
        : t
}
function e1(t, e) {
    ;(e.constant = !1),
        (e.payable = !1),
        (e.stateMutability = "nonpayable"),
        t.split(" ").forEach((r) => {
            switch (r.trim()) {
                case "constant":
                    e.constant = !0
                    break
                case "payable":
                    ;(e.payable = !0), (e.stateMutability = "payable")
                    break
                case "nonpayable":
                    ;(e.payable = !1), (e.stateMutability = "nonpayable")
                    break
                case "pure":
                    ;(e.constant = !0), (e.stateMutability = "pure")
                    break
                case "view":
                    ;(e.constant = !0), (e.stateMutability = "view")
                    break
                case "external":
                case "public":
                case "":
                    break
                default:
                    console.log("unknown modifier: " + r)
            }
        })
}
function t1(t) {
    let e = { constant: !1, payable: !0, stateMutability: "payable" }
    return (
        t.stateMutability != null
            ? ((e.stateMutability = t.stateMutability),
              (e.constant = e.stateMutability === "view" || e.stateMutability === "pure"),
              t.constant != null &&
                  !!t.constant !== e.constant &&
                  We.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", t),
              (e.payable = e.stateMutability === "payable"),
              t.payable != null &&
                  !!t.payable !== e.payable &&
                  We.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", t))
            : t.payable != null
            ? ((e.payable = !!t.payable),
              t.constant == null &&
                  !e.payable &&
                  t.type !== "constructor" &&
                  We.throwArgumentError("unable to determine stateMutability", "value", t),
              (e.constant = !!t.constant),
              e.constant ? (e.stateMutability = "view") : (e.stateMutability = e.payable ? "payable" : "nonpayable"),
              e.payable && e.constant && We.throwArgumentError("cannot have constant payable function", "value", t))
            : t.constant != null
            ? ((e.constant = !!t.constant), (e.payable = !e.constant), (e.stateMutability = e.constant ? "view" : "payable"))
            : t.type !== "constructor" && We.throwArgumentError("unable to determine stateMutability", "value", t),
        e
    )
}
class rn extends En {
    format(e) {
        if ((e || (e = Xe.sighash), Xe[e] || We.throwArgumentError("invalid format type", "format", e), e === Xe.json))
            return JSON.stringify({
                type: "constructor",
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map((n) => JSON.parse(n.format(e))),
            })
        e === Xe.sighash &&
            We.throwError("cannot format a constructor for sighash", F.errors.UNSUPPORTED_OPERATION, { operation: "format(sighash)" })
        let r = "constructor(" + this.inputs.map((n) => n.format(e)).join(e === Xe.full ? ", " : ",") + ") "
        return this.stateMutability && this.stateMutability !== "nonpayable" && (r += this.stateMutability + " "), r.trim()
    }
    static from(e) {
        return typeof e == "string" ? rn.fromString(e) : rn.fromObject(e)
    }
    static fromObject(e) {
        if (rn.isConstructorFragment(e)) return e
        e.type !== "constructor" && We.throwArgumentError("invalid constructor object", "value", e)
        let r = t1(e)
        r.constant && We.throwArgumentError("constructor cannot be constant", "value", e)
        const n = {
            name: null,
            type: e.type,
            inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
            payable: r.payable,
            stateMutability: r.stateMutability,
            gas: e.gas ? ce.from(e.gas) : null,
        }
        return new rn(Os, n)
    }
    static fromString(e) {
        let r = { type: "constructor" }
        e = Qb(e, r)
        let n = e.match(Xa)
        return (
            (!n || n[1].trim() !== "constructor") && We.throwArgumentError("invalid constructor string", "value", e),
            (r.inputs = Wa(n[2].trim(), !1)),
            e1(n[3].trim(), r),
            rn.fromObject(r)
        )
    }
    static isConstructorFragment(e) {
        return e && e._isFragment && e.type === "constructor"
    }
}
class nn extends rn {
    format(e) {
        if ((e || (e = Xe.sighash), Xe[e] || We.throwArgumentError("invalid format type", "format", e), e === Xe.json))
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map((n) => JSON.parse(n.format(e))),
                outputs: this.outputs.map((n) => JSON.parse(n.format(e))),
            })
        let r = ""
        return (
            e !== Xe.sighash && (r += "function "),
            (r += this.name + "(" + this.inputs.map((n) => n.format(e)).join(e === Xe.full ? ", " : ",") + ") "),
            e !== Xe.sighash &&
                (this.stateMutability
                    ? this.stateMutability !== "nonpayable" && (r += this.stateMutability + " ")
                    : this.constant && (r += "view "),
                this.outputs && this.outputs.length && (r += "returns (" + this.outputs.map((n) => n.format(e)).join(", ") + ") "),
                this.gas != null && (r += "@" + this.gas.toString() + " ")),
            r.trim()
        )
    }
    static from(e) {
        return typeof e == "string" ? nn.fromString(e) : nn.fromObject(e)
    }
    static fromObject(e) {
        if (nn.isFunctionFragment(e)) return e
        e.type !== "function" && We.throwArgumentError("invalid function object", "value", e)
        let r = t1(e)
        const n = {
            type: e.type,
            name: Ja(e.name),
            constant: r.constant,
            inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
            outputs: e.outputs ? e.outputs.map(Wt.fromObject) : [],
            payable: r.payable,
            stateMutability: r.stateMutability,
            gas: e.gas ? ce.from(e.gas) : null,
        }
        return new nn(Os, n)
    }
    static fromString(e) {
        let r = { type: "function" }
        e = Qb(e, r)
        let n = e.split(" returns ")
        n.length > 2 && We.throwArgumentError("invalid function string", "value", e)
        let i = n[0].match(Xa)
        if (
            (i || We.throwArgumentError("invalid function signature", "value", e),
            (r.name = i[1].trim()),
            r.name && Ja(r.name),
            (r.inputs = Wa(i[2], !1)),
            e1(i[3].trim(), r),
            n.length > 1)
        ) {
            let s = n[1].match(Xa)
            ;(s[1].trim() != "" || s[3].trim() != "") && We.throwArgumentError("unexpected tokens", "value", e), (r.outputs = Wa(s[2], !1))
        } else r.outputs = []
        return nn.fromObject(r)
    }
    static isFunctionFragment(e) {
        return e && e._isFragment && e.type === "function"
    }
}
function bp(t) {
    const e = t.format()
    return (e === "Error(string)" || e === "Panic(uint256)") && We.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", t), t
}
class Yn extends En {
    format(e) {
        if ((e || (e = Xe.sighash), Xe[e] || We.throwArgumentError("invalid format type", "format", e), e === Xe.json))
            return JSON.stringify({ type: "error", name: this.name, inputs: this.inputs.map((n) => JSON.parse(n.format(e))) })
        let r = ""
        return (
            e !== Xe.sighash && (r += "error "),
            (r += this.name + "(" + this.inputs.map((n) => n.format(e)).join(e === Xe.full ? ", " : ",") + ") "),
            r.trim()
        )
    }
    static from(e) {
        return typeof e == "string" ? Yn.fromString(e) : Yn.fromObject(e)
    }
    static fromObject(e) {
        if (Yn.isErrorFragment(e)) return e
        e.type !== "error" && We.throwArgumentError("invalid error object", "value", e)
        const r = { type: e.type, name: Ja(e.name), inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [] }
        return bp(new Yn(Os, r))
    }
    static fromString(e) {
        let r = { type: "error" },
            n = e.match(Xa)
        return (
            n || We.throwArgumentError("invalid error signature", "value", e),
            (r.name = n[1].trim()),
            r.name && Ja(r.name),
            (r.inputs = Wa(n[2], !1)),
            bp(Yn.fromObject(r))
        )
    }
    static isErrorFragment(e) {
        return e && e._isFragment && e.type === "error"
    }
}
function io(t) {
    return t.match(/^uint($|[^1-9])/) ? (t = "uint256" + t.substring(4)) : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)), t
}
const Xw = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$")
function Ja(t) {
    return (!t || !t.match(Xw)) && We.throwArgumentError(`invalid identifier "${t}"`, "value", t), t
}
const Xa = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$")
function Yw(t) {
    t = t.trim()
    let e = [],
        r = "",
        n = 0
    for (let i = 0; i < t.length; i++) {
        let s = t[i]
        s === "," && n === 0
            ? (e.push(r), (r = ""))
            : ((r += s), s === "(" ? n++ : s === ")" && (n--, n === -1 && We.throwArgumentError("unbalanced parenthesis", "value", t)))
    }
    return r && e.push(r), e
}
const x0 = new F(ll)
function r1(t) {
    const e = [],
        r = function (n, i) {
            if (!!Array.isArray(i))
                for (let s in i) {
                    const o = n.slice()
                    o.push(s)
                    try {
                        r(o, i[s])
                    } catch (a) {
                        e.push({ path: o, error: a })
                    }
                }
        }
    return r([], t), e
}
class ui {
    constructor(e, r, n, i) {
        ;(this.name = e), (this.type = r), (this.localName = n), (this.dynamic = i)
    }
    _throwError(e, r) {
        x0.throwArgumentError(e, this.localName, r)
    }
}
class id {
    constructor(e) {
        X(this, "wordSize", e || 32), (this._data = []), (this._dataLength = 0), (this._padding = new Uint8Array(e))
    }
    get data() {
        return qr(this._data)
    }
    get length() {
        return this._dataLength
    }
    _writeData(e) {
        return this._data.push(e), (this._dataLength += e.length), e.length
    }
    appendWriter(e) {
        return this._writeData(ft(e._data))
    }
    writeBytes(e) {
        let r = le(e)
        const n = r.length % this.wordSize
        return n && (r = ft([r, this._padding.slice(n)])), this._writeData(r)
    }
    _getValue(e) {
        let r = le(ce.from(e))
        return (
            r.length > this.wordSize &&
                x0.throwError("value out-of-bounds", F.errors.BUFFER_OVERRUN, { length: this.wordSize, offset: r.length }),
            r.length % this.wordSize && (r = ft([this._padding.slice(r.length % this.wordSize), r])),
            r
        )
    }
    writeValue(e) {
        return this._writeData(this._getValue(e))
    }
    writeUpdatableValue() {
        const e = this._data.length
        return (
            this._data.push(this._padding),
            (this._dataLength += this.wordSize),
            (r) => {
                this._data[e] = this._getValue(r)
            }
        )
    }
}
class _c {
    constructor(e, r, n, i) {
        X(this, "_data", le(e)), X(this, "wordSize", r || 32), X(this, "_coerceFunc", n), X(this, "allowLoose", i), (this._offset = 0)
    }
    get data() {
        return pe(this._data)
    }
    get consumed() {
        return this._offset
    }
    static coerce(e, r) {
        let n = e.match("^u?int([0-9]+)$")
        return n && parseInt(n[1]) <= 48 && (r = r.toNumber()), r
    }
    coerce(e, r) {
        return this._coerceFunc ? this._coerceFunc(e, r) : _c.coerce(e, r)
    }
    _peekBytes(e, r, n) {
        let i = Math.ceil(r / this.wordSize) * this.wordSize
        return (
            this._offset + i > this._data.length &&
                (this.allowLoose && n && this._offset + r <= this._data.length
                    ? (i = r)
                    : x0.throwError("data out-of-bounds", F.errors.BUFFER_OVERRUN, { length: this._data.length, offset: this._offset + i })),
            this._data.slice(this._offset, this._offset + i)
        )
    }
    subReader(e) {
        return new _c(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose)
    }
    readBytes(e, r) {
        let n = this._peekBytes(0, e, !!r)
        return (this._offset += n.length), n.slice(0, e)
    }
    readValue() {
        return ce.from(this.readBytes(this.wordSize))
    }
}
var n1 = { exports: {} }
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */ ;(function (t) {
    ;(function () {
        var e = "input is invalid type",
            r = "finalize already called",
            n = typeof window == "object",
            i = n ? window : {}
        i.JS_SHA3_NO_WINDOW && (n = !1)
        var s = !n && typeof self == "object",
            o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node
        o ? (i = Vt) : s && (i = self)
        var a = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports,
            l = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined",
            c = "0123456789abcdef".split(""),
            f = [31, 7936, 2031616, 520093696],
            u = [4, 1024, 262144, 67108864],
            p = [1, 256, 65536, 16777216],
            m = [6, 1536, 393216, 100663296],
            y = [0, 8, 16, 24],
            v = [
                1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648,
                138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770,
                2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0,
                2147516424, 2147483648,
            ],
            _ = [224, 256, 384, 512],
            C = [128, 256],
            B = ["hex", "buffer", "arrayBuffer", "array", "digest"],
            R = { 128: 168, 256: 136 }
        ;(i.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
            (Array.isArray = function (h) {
                return Object.prototype.toString.call(h) === "[object Array]"
            }),
            l &&
                (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
                (ArrayBuffer.isView = function (h) {
                    return typeof h == "object" && h.buffer && h.buffer.constructor === ArrayBuffer
                })
        for (
            var U = function (h, P, M) {
                    return function (V) {
                        return new O(h, P, h).update(V)[M]()
                    }
                },
                D = function (h, P, M) {
                    return function (V, z) {
                        return new O(h, P, z).update(V)[M]()
                    }
                },
                Y = function (h, P, M) {
                    return function (V, z, ee, ne) {
                        return w["cshake" + h].update(V, z, ee, ne)[M]()
                    }
                },
                J = function (h, P, M) {
                    return function (V, z, ee, ne) {
                        return w["kmac" + h].update(V, z, ee, ne)[M]()
                    }
                },
                te = function (h, P, M, V) {
                    for (var z = 0; z < B.length; ++z) {
                        var ee = B[z]
                        h[ee] = P(M, V, ee)
                    }
                    return h
                },
                G = function (h, P) {
                    var M = U(h, P, "hex")
                    return (
                        (M.create = function () {
                            return new O(h, P, h)
                        }),
                        (M.update = function (V) {
                            return M.create().update(V)
                        }),
                        te(M, U, h, P)
                    )
                },
                de = function (h, P) {
                    var M = D(h, P, "hex")
                    return (
                        (M.create = function (V) {
                            return new O(h, P, V)
                        }),
                        (M.update = function (V, z) {
                            return M.create(z).update(V)
                        }),
                        te(M, D, h, P)
                    )
                },
                k = function (h, P) {
                    var M = R[h],
                        V = Y(h, P, "hex")
                    return (
                        (V.create = function (z, ee, ne) {
                            return !ee && !ne ? w["shake" + h].create(z) : new O(h, P, z).bytepad([ee, ne], M)
                        }),
                        (V.update = function (z, ee, ne, W) {
                            return V.create(ee, ne, W).update(z)
                        }),
                        te(V, Y, h, P)
                    )
                },
                d = function (h, P) {
                    var M = R[h],
                        V = J(h, P, "hex")
                    return (
                        (V.create = function (z, ee, ne) {
                            return new j(h, P, ee).bytepad(["KMAC", ne], M).bytepad([z], M)
                        }),
                        (V.update = function (z, ee, ne, W) {
                            return V.create(z, ne, W).update(ee)
                        }),
                        te(V, J, h, P)
                    )
                },
                b = [
                    { name: "keccak", padding: p, bits: _, createMethod: G },
                    { name: "sha3", padding: m, bits: _, createMethod: G },
                    { name: "shake", padding: f, bits: C, createMethod: de },
                    { name: "cshake", padding: u, bits: C, createMethod: k },
                    { name: "kmac", padding: u, bits: C, createMethod: d },
                ],
                w = {},
                E = [],
                T = 0;
            T < b.length;
            ++T
        )
            for (var A = b[T], $ = A.bits, S = 0; S < $.length; ++S) {
                var g = A.name + "_" + $[S]
                if ((E.push(g), (w[g] = A.createMethod($[S], A.padding)), A.name !== "sha3")) {
                    var x = A.name + $[S]
                    E.push(x), (w[x] = w[g])
                }
            }
        function O(h, P, M) {
            ;(this.blocks = []),
                (this.s = []),
                (this.padding = P),
                (this.outputBits = M),
                (this.reset = !0),
                (this.finalized = !1),
                (this.block = 0),
                (this.start = 0),
                (this.blockCount = (1600 - (h << 1)) >> 5),
                (this.byteCount = this.blockCount << 2),
                (this.outputBlocks = M >> 5),
                (this.extraBytes = (M & 31) >> 3)
            for (var V = 0; V < 50; ++V) this.s[V] = 0
        }
        ;(O.prototype.update = function (h) {
            if (this.finalized) throw new Error(r)
            var P,
                M = typeof h
            if (M !== "string") {
                if (M === "object") {
                    if (h === null) throw new Error(e)
                    if (l && h.constructor === ArrayBuffer) h = new Uint8Array(h)
                    else if (!Array.isArray(h) && (!l || !ArrayBuffer.isView(h))) throw new Error(e)
                } else throw new Error(e)
                P = !0
            }
            for (var V = this.blocks, z = this.byteCount, ee = h.length, ne = this.blockCount, W = 0, N = this.s, I, q; W < ee; ) {
                if (this.reset) for (this.reset = !1, V[0] = this.block, I = 1; I < ne + 1; ++I) V[I] = 0
                if (P) for (I = this.start; W < ee && I < z; ++W) V[I >> 2] |= h[W] << y[I++ & 3]
                else
                    for (I = this.start; W < ee && I < z; ++W)
                        (q = h.charCodeAt(W)),
                            q < 128
                                ? (V[I >> 2] |= q << y[I++ & 3])
                                : q < 2048
                                ? ((V[I >> 2] |= (192 | (q >> 6)) << y[I++ & 3]), (V[I >> 2] |= (128 | (q & 63)) << y[I++ & 3]))
                                : q < 55296 || q >= 57344
                                ? ((V[I >> 2] |= (224 | (q >> 12)) << y[I++ & 3]),
                                  (V[I >> 2] |= (128 | ((q >> 6) & 63)) << y[I++ & 3]),
                                  (V[I >> 2] |= (128 | (q & 63)) << y[I++ & 3]))
                                : ((q = 65536 + (((q & 1023) << 10) | (h.charCodeAt(++W) & 1023))),
                                  (V[I >> 2] |= (240 | (q >> 18)) << y[I++ & 3]),
                                  (V[I >> 2] |= (128 | ((q >> 12) & 63)) << y[I++ & 3]),
                                  (V[I >> 2] |= (128 | ((q >> 6) & 63)) << y[I++ & 3]),
                                  (V[I >> 2] |= (128 | (q & 63)) << y[I++ & 3]))
                if (((this.lastByteIndex = I), I >= z)) {
                    for (this.start = I - z, this.block = V[ne], I = 0; I < ne; ++I) N[I] ^= V[I]
                    L(N), (this.reset = !0)
                } else this.start = I
            }
            return this
        }),
            (O.prototype.encode = function (h, P) {
                var M = h & 255,
                    V = 1,
                    z = [M]
                for (h = h >> 8, M = h & 255; M > 0; ) z.unshift(M), (h = h >> 8), (M = h & 255), ++V
                return P ? z.push(V) : z.unshift(V), this.update(z), z.length
            }),
            (O.prototype.encodeString = function (h) {
                var P,
                    M = typeof h
                if (M !== "string") {
                    if (M === "object") {
                        if (h === null) throw new Error(e)
                        if (l && h.constructor === ArrayBuffer) h = new Uint8Array(h)
                        else if (!Array.isArray(h) && (!l || !ArrayBuffer.isView(h))) throw new Error(e)
                    } else throw new Error(e)
                    P = !0
                }
                var V = 0,
                    z = h.length
                if (P) V = z
                else
                    for (var ee = 0; ee < h.length; ++ee) {
                        var ne = h.charCodeAt(ee)
                        ne < 128
                            ? (V += 1)
                            : ne < 2048
                            ? (V += 2)
                            : ne < 55296 || ne >= 57344
                            ? (V += 3)
                            : ((ne = 65536 + (((ne & 1023) << 10) | (h.charCodeAt(++ee) & 1023))), (V += 4))
                    }
                return (V += this.encode(V * 8)), this.update(h), V
            }),
            (O.prototype.bytepad = function (h, P) {
                for (var M = this.encode(P), V = 0; V < h.length; ++V) M += this.encodeString(h[V])
                var z = P - (M % P),
                    ee = []
                return (ee.length = z), this.update(ee), this
            }),
            (O.prototype.finalize = function () {
                if (!this.finalized) {
                    this.finalized = !0
                    var h = this.blocks,
                        P = this.lastByteIndex,
                        M = this.blockCount,
                        V = this.s
                    if (((h[P >> 2] |= this.padding[P & 3]), this.lastByteIndex === this.byteCount))
                        for (h[0] = h[M], P = 1; P < M + 1; ++P) h[P] = 0
                    for (h[M - 1] |= 2147483648, P = 0; P < M; ++P) V[P] ^= h[P]
                    L(V)
                }
            }),
            (O.prototype.toString = O.prototype.hex =
                function () {
                    this.finalize()
                    for (var h = this.blockCount, P = this.s, M = this.outputBlocks, V = this.extraBytes, z = 0, ee = 0, ne = "", W; ee < M; ) {
                        for (z = 0; z < h && ee < M; ++z, ++ee)
                            (W = P[z]),
                                (ne +=
                                    c[(W >> 4) & 15] +
                                    c[W & 15] +
                                    c[(W >> 12) & 15] +
                                    c[(W >> 8) & 15] +
                                    c[(W >> 20) & 15] +
                                    c[(W >> 16) & 15] +
                                    c[(W >> 28) & 15] +
                                    c[(W >> 24) & 15])
                        ee % h === 0 && (L(P), (z = 0))
                    }
                    return (
                        V &&
                            ((W = P[z]),
                            (ne += c[(W >> 4) & 15] + c[W & 15]),
                            V > 1 && (ne += c[(W >> 12) & 15] + c[(W >> 8) & 15]),
                            V > 2 && (ne += c[(W >> 20) & 15] + c[(W >> 16) & 15])),
                        ne
                    )
                }),
            (O.prototype.arrayBuffer = function () {
                this.finalize()
                var h = this.blockCount,
                    P = this.s,
                    M = this.outputBlocks,
                    V = this.extraBytes,
                    z = 0,
                    ee = 0,
                    ne = this.outputBits >> 3,
                    W
                V ? (W = new ArrayBuffer((M + 1) << 2)) : (W = new ArrayBuffer(ne))
                for (var N = new Uint32Array(W); ee < M; ) {
                    for (z = 0; z < h && ee < M; ++z, ++ee) N[ee] = P[z]
                    ee % h === 0 && L(P)
                }
                return V && ((N[z] = P[z]), (W = W.slice(0, ne))), W
            }),
            (O.prototype.buffer = O.prototype.arrayBuffer),
            (O.prototype.digest = O.prototype.array =
                function () {
                    this.finalize()
                    for (
                        var h = this.blockCount, P = this.s, M = this.outputBlocks, V = this.extraBytes, z = 0, ee = 0, ne = [], W, N;
                        ee < M;

                    ) {
                        for (z = 0; z < h && ee < M; ++z, ++ee)
                            (W = ee << 2),
                                (N = P[z]),
                                (ne[W] = N & 255),
                                (ne[W + 1] = (N >> 8) & 255),
                                (ne[W + 2] = (N >> 16) & 255),
                                (ne[W + 3] = (N >> 24) & 255)
                        ee % h === 0 && L(P)
                    }
                    return (
                        V &&
                            ((W = ee << 2),
                            (N = P[z]),
                            (ne[W] = N & 255),
                            V > 1 && (ne[W + 1] = (N >> 8) & 255),
                            V > 2 && (ne[W + 2] = (N >> 16) & 255)),
                        ne
                    )
                })
        function j(h, P, M) {
            O.call(this, h, P, M)
        }
        ;(j.prototype = new O()),
            (j.prototype.finalize = function () {
                return this.encode(this.outputBits, !0), O.prototype.finalize.call(this)
            })
        var L = function (h) {
            var P,
                M,
                V,
                z,
                ee,
                ne,
                W,
                N,
                I,
                q,
                Q,
                ie,
                Z,
                oe,
                fe,
                se,
                re,
                Ee,
                he,
                me,
                Ce,
                Se,
                Ne,
                Ge,
                ke,
                qe,
                br,
                it,
                Ze,
                fn,
                Ve,
                je,
                un,
                dt,
                ht,
                ns,
                pt,
                gt,
                is,
                mt,
                bt,
                ss,
                xt,
                vt,
                os,
                yt,
                _t,
                as,
                wt,
                Et,
                ls,
                St,
                At,
                cs,
                Tt,
                Ct,
                hi,
                pi,
                gi,
                mi,
                bi,
                xi,
                vi
            for (V = 0; V < 48; V += 2)
                (z = h[0] ^ h[10] ^ h[20] ^ h[30] ^ h[40]),
                    (ee = h[1] ^ h[11] ^ h[21] ^ h[31] ^ h[41]),
                    (ne = h[2] ^ h[12] ^ h[22] ^ h[32] ^ h[42]),
                    (W = h[3] ^ h[13] ^ h[23] ^ h[33] ^ h[43]),
                    (N = h[4] ^ h[14] ^ h[24] ^ h[34] ^ h[44]),
                    (I = h[5] ^ h[15] ^ h[25] ^ h[35] ^ h[45]),
                    (q = h[6] ^ h[16] ^ h[26] ^ h[36] ^ h[46]),
                    (Q = h[7] ^ h[17] ^ h[27] ^ h[37] ^ h[47]),
                    (ie = h[8] ^ h[18] ^ h[28] ^ h[38] ^ h[48]),
                    (Z = h[9] ^ h[19] ^ h[29] ^ h[39] ^ h[49]),
                    (P = ie ^ ((ne << 1) | (W >>> 31))),
                    (M = Z ^ ((W << 1) | (ne >>> 31))),
                    (h[0] ^= P),
                    (h[1] ^= M),
                    (h[10] ^= P),
                    (h[11] ^= M),
                    (h[20] ^= P),
                    (h[21] ^= M),
                    (h[30] ^= P),
                    (h[31] ^= M),
                    (h[40] ^= P),
                    (h[41] ^= M),
                    (P = z ^ ((N << 1) | (I >>> 31))),
                    (M = ee ^ ((I << 1) | (N >>> 31))),
                    (h[2] ^= P),
                    (h[3] ^= M),
                    (h[12] ^= P),
                    (h[13] ^= M),
                    (h[22] ^= P),
                    (h[23] ^= M),
                    (h[32] ^= P),
                    (h[33] ^= M),
                    (h[42] ^= P),
                    (h[43] ^= M),
                    (P = ne ^ ((q << 1) | (Q >>> 31))),
                    (M = W ^ ((Q << 1) | (q >>> 31))),
                    (h[4] ^= P),
                    (h[5] ^= M),
                    (h[14] ^= P),
                    (h[15] ^= M),
                    (h[24] ^= P),
                    (h[25] ^= M),
                    (h[34] ^= P),
                    (h[35] ^= M),
                    (h[44] ^= P),
                    (h[45] ^= M),
                    (P = N ^ ((ie << 1) | (Z >>> 31))),
                    (M = I ^ ((Z << 1) | (ie >>> 31))),
                    (h[6] ^= P),
                    (h[7] ^= M),
                    (h[16] ^= P),
                    (h[17] ^= M),
                    (h[26] ^= P),
                    (h[27] ^= M),
                    (h[36] ^= P),
                    (h[37] ^= M),
                    (h[46] ^= P),
                    (h[47] ^= M),
                    (P = q ^ ((z << 1) | (ee >>> 31))),
                    (M = Q ^ ((ee << 1) | (z >>> 31))),
                    (h[8] ^= P),
                    (h[9] ^= M),
                    (h[18] ^= P),
                    (h[19] ^= M),
                    (h[28] ^= P),
                    (h[29] ^= M),
                    (h[38] ^= P),
                    (h[39] ^= M),
                    (h[48] ^= P),
                    (h[49] ^= M),
                    (oe = h[0]),
                    (fe = h[1]),
                    (yt = (h[11] << 4) | (h[10] >>> 28)),
                    (_t = (h[10] << 4) | (h[11] >>> 28)),
                    (it = (h[20] << 3) | (h[21] >>> 29)),
                    (Ze = (h[21] << 3) | (h[20] >>> 29)),
                    (mi = (h[31] << 9) | (h[30] >>> 23)),
                    (bi = (h[30] << 9) | (h[31] >>> 23)),
                    (ss = (h[40] << 18) | (h[41] >>> 14)),
                    (xt = (h[41] << 18) | (h[40] >>> 14)),
                    (dt = (h[2] << 1) | (h[3] >>> 31)),
                    (ht = (h[3] << 1) | (h[2] >>> 31)),
                    (se = (h[13] << 12) | (h[12] >>> 20)),
                    (re = (h[12] << 12) | (h[13] >>> 20)),
                    (as = (h[22] << 10) | (h[23] >>> 22)),
                    (wt = (h[23] << 10) | (h[22] >>> 22)),
                    (fn = (h[33] << 13) | (h[32] >>> 19)),
                    (Ve = (h[32] << 13) | (h[33] >>> 19)),
                    (xi = (h[42] << 2) | (h[43] >>> 30)),
                    (vi = (h[43] << 2) | (h[42] >>> 30)),
                    (cs = (h[5] << 30) | (h[4] >>> 2)),
                    (Tt = (h[4] << 30) | (h[5] >>> 2)),
                    (ns = (h[14] << 6) | (h[15] >>> 26)),
                    (pt = (h[15] << 6) | (h[14] >>> 26)),
                    (Ee = (h[25] << 11) | (h[24] >>> 21)),
                    (he = (h[24] << 11) | (h[25] >>> 21)),
                    (Et = (h[34] << 15) | (h[35] >>> 17)),
                    (ls = (h[35] << 15) | (h[34] >>> 17)),
                    (je = (h[45] << 29) | (h[44] >>> 3)),
                    (un = (h[44] << 29) | (h[45] >>> 3)),
                    (Ge = (h[6] << 28) | (h[7] >>> 4)),
                    (ke = (h[7] << 28) | (h[6] >>> 4)),
                    (Ct = (h[17] << 23) | (h[16] >>> 9)),
                    (hi = (h[16] << 23) | (h[17] >>> 9)),
                    (gt = (h[26] << 25) | (h[27] >>> 7)),
                    (is = (h[27] << 25) | (h[26] >>> 7)),
                    (me = (h[36] << 21) | (h[37] >>> 11)),
                    (Ce = (h[37] << 21) | (h[36] >>> 11)),
                    (St = (h[47] << 24) | (h[46] >>> 8)),
                    (At = (h[46] << 24) | (h[47] >>> 8)),
                    (vt = (h[8] << 27) | (h[9] >>> 5)),
                    (os = (h[9] << 27) | (h[8] >>> 5)),
                    (qe = (h[18] << 20) | (h[19] >>> 12)),
                    (br = (h[19] << 20) | (h[18] >>> 12)),
                    (pi = (h[29] << 7) | (h[28] >>> 25)),
                    (gi = (h[28] << 7) | (h[29] >>> 25)),
                    (mt = (h[38] << 8) | (h[39] >>> 24)),
                    (bt = (h[39] << 8) | (h[38] >>> 24)),
                    (Se = (h[48] << 14) | (h[49] >>> 18)),
                    (Ne = (h[49] << 14) | (h[48] >>> 18)),
                    (h[0] = oe ^ (~se & Ee)),
                    (h[1] = fe ^ (~re & he)),
                    (h[10] = Ge ^ (~qe & it)),
                    (h[11] = ke ^ (~br & Ze)),
                    (h[20] = dt ^ (~ns & gt)),
                    (h[21] = ht ^ (~pt & is)),
                    (h[30] = vt ^ (~yt & as)),
                    (h[31] = os ^ (~_t & wt)),
                    (h[40] = cs ^ (~Ct & pi)),
                    (h[41] = Tt ^ (~hi & gi)),
                    (h[2] = se ^ (~Ee & me)),
                    (h[3] = re ^ (~he & Ce)),
                    (h[12] = qe ^ (~it & fn)),
                    (h[13] = br ^ (~Ze & Ve)),
                    (h[22] = ns ^ (~gt & mt)),
                    (h[23] = pt ^ (~is & bt)),
                    (h[32] = yt ^ (~as & Et)),
                    (h[33] = _t ^ (~wt & ls)),
                    (h[42] = Ct ^ (~pi & mi)),
                    (h[43] = hi ^ (~gi & bi)),
                    (h[4] = Ee ^ (~me & Se)),
                    (h[5] = he ^ (~Ce & Ne)),
                    (h[14] = it ^ (~fn & je)),
                    (h[15] = Ze ^ (~Ve & un)),
                    (h[24] = gt ^ (~mt & ss)),
                    (h[25] = is ^ (~bt & xt)),
                    (h[34] = as ^ (~Et & St)),
                    (h[35] = wt ^ (~ls & At)),
                    (h[44] = pi ^ (~mi & xi)),
                    (h[45] = gi ^ (~bi & vi)),
                    (h[6] = me ^ (~Se & oe)),
                    (h[7] = Ce ^ (~Ne & fe)),
                    (h[16] = fn ^ (~je & Ge)),
                    (h[17] = Ve ^ (~un & ke)),
                    (h[26] = mt ^ (~ss & dt)),
                    (h[27] = bt ^ (~xt & ht)),
                    (h[36] = Et ^ (~St & vt)),
                    (h[37] = ls ^ (~At & os)),
                    (h[46] = mi ^ (~xi & cs)),
                    (h[47] = bi ^ (~vi & Tt)),
                    (h[8] = Se ^ (~oe & se)),
                    (h[9] = Ne ^ (~fe & re)),
                    (h[18] = je ^ (~Ge & qe)),
                    (h[19] = un ^ (~ke & br)),
                    (h[28] = ss ^ (~dt & ns)),
                    (h[29] = xt ^ (~ht & pt)),
                    (h[38] = St ^ (~vt & yt)),
                    (h[39] = At ^ (~os & _t)),
                    (h[48] = xi ^ (~cs & Ct)),
                    (h[49] = vi ^ (~Tt & hi)),
                    (h[0] ^= v[V]),
                    (h[1] ^= v[V + 1])
        }
        if (a) t.exports = w
        else for (T = 0; T < E.length; ++T) i[E[T]] = w[E[T]]
    })()
})(n1)
var Zw = n1.exports
function st(t) {
    return "0x" + Zw.keccak_256(le(t))
}
const Qw = "rlp/5.5.0",
    xn = new F(Qw)
function xp(t) {
    const e = []
    for (; t; ) e.unshift(t & 255), (t >>= 8)
    return e
}
function vp(t, e, r) {
    let n = 0
    for (let i = 0; i < r; i++) n = n * 256 + t[e + i]
    return n
}
function i1(t) {
    if (Array.isArray(t)) {
        let n = []
        if (
            (t.forEach(function (s) {
                n = n.concat(i1(s))
            }),
            n.length <= 55)
        )
            return n.unshift(192 + n.length), n
        const i = xp(n.length)
        return i.unshift(247 + i.length), i.concat(n)
    }
    ol(t) || xn.throwArgumentError("RLP object must be BytesLike", "object", t)
    const e = Array.prototype.slice.call(le(t))
    if (e.length === 1 && e[0] <= 127) return e
    if (e.length <= 55) return e.unshift(128 + e.length), e
    const r = xp(e.length)
    return r.unshift(183 + r.length), r.concat(e)
}
function Ms(t) {
    return pe(i1(t))
}
function yp(t, e, r, n) {
    const i = []
    for (; r < e + 1 + n; ) {
        const s = s1(t, r)
        i.push(s.result), (r += s.consumed), r > e + 1 + n && xn.throwError("child data too short", F.errors.BUFFER_OVERRUN, {})
    }
    return { consumed: 1 + n, result: i }
}
function s1(t, e) {
    if ((t.length === 0 && xn.throwError("data too short", F.errors.BUFFER_OVERRUN, {}), t[e] >= 248)) {
        const r = t[e] - 247
        e + 1 + r > t.length && xn.throwError("data short segment too short", F.errors.BUFFER_OVERRUN, {})
        const n = vp(t, e + 1, r)
        return e + 1 + r + n > t.length && xn.throwError("data long segment too short", F.errors.BUFFER_OVERRUN, {}), yp(t, e, e + 1 + r, r + n)
    } else if (t[e] >= 192) {
        const r = t[e] - 192
        return e + 1 + r > t.length && xn.throwError("data array too short", F.errors.BUFFER_OVERRUN, {}), yp(t, e, e + 1, r)
    } else if (t[e] >= 184) {
        const r = t[e] - 183
        e + 1 + r > t.length && xn.throwError("data array too short", F.errors.BUFFER_OVERRUN, {})
        const n = vp(t, e + 1, r)
        e + 1 + r + n > t.length && xn.throwError("data array too short", F.errors.BUFFER_OVERRUN, {})
        const i = pe(t.slice(e + 1 + r, e + 1 + r + n))
        return { consumed: 1 + r + n, result: i }
    } else if (t[e] >= 128) {
        const r = t[e] - 128
        e + 1 + r > t.length && xn.throwError("data too short", F.errors.BUFFER_OVERRUN, {})
        const n = pe(t.slice(e + 1, e + 1 + r))
        return { consumed: 1 + r, result: n }
    }
    return { consumed: 1, result: pe(t[e]) }
}
function Wc(t) {
    const e = le(t),
        r = s1(e, 0)
    return r.consumed !== e.length && xn.throwArgumentError("invalid rlp data", "data", t), r.result
}
var e6 = Object.freeze({ __proto__: null, [Symbol.toStringTag]: "Module", encode: Ms, decode: Wc })
const t6 = "address/5.5.0",
    $i = new F(t6)
function _p(t) {
    Le(t, 20) || $i.throwArgumentError("invalid address", "address", t), (t = t.toLowerCase())
    const e = t.substring(2).split(""),
        r = new Uint8Array(40)
    for (let i = 0; i < 40; i++) r[i] = e[i].charCodeAt(0)
    const n = le(st(r))
    for (let i = 0; i < 40; i += 2)
        n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase())
    return "0x" + e.join("")
}
const r6 = 9007199254740991
function n6(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
}
const v0 = {}
for (let t = 0; t < 10; t++) v0[String(t)] = String(t)
for (let t = 0; t < 26; t++) v0[String.fromCharCode(65 + t)] = String(10 + t)
const wp = Math.floor(n6(r6))
function o1(t) {
    ;(t = t.toUpperCase()), (t = t.substring(4) + t.substring(0, 2) + "00")
    let e = t
        .split("")
        .map((n) => v0[n])
        .join("")
    for (; e.length >= wp; ) {
        let n = e.substring(0, wp)
        e = (parseInt(n, 10) % 97) + e.substring(n.length)
    }
    let r = String(98 - (parseInt(e, 10) % 97))
    for (; r.length < 2; ) r = "0" + r
    return r
}
function nt(t) {
    let e = null
    if ((typeof t != "string" && $i.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)))
        t.substring(0, 2) !== "0x" && (t = "0x" + t),
            (e = _p(t)),
            t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && $i.throwArgumentError("bad address checksum", "address", t)
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (t.substring(2, 4) !== o1(t) && $i.throwArgumentError("bad icap checksum", "address", t), e = Vw(t.substring(4)); e.length < 40; )
            e = "0" + e
        e = _p("0x" + e)
    } else $i.throwArgumentError("invalid address", "address", t)
    return e
}
function i6(t) {
    try {
        return nt(t), !0
    } catch {}
    return !1
}
function s6(t) {
    let e = Uw(nt(t).substring(2)).toUpperCase()
    for (; e.length < 30; ) e = "0" + e
    return "XE" + o1("XE00" + e) + e
}
function Jc(t) {
    let e = null
    try {
        e = nt(t.from)
    } catch {
        $i.throwArgumentError("missing from address", "transaction", t)
    }
    const r = In(le(ce.from(t.nonce).toHexString()))
    return nt(Er(st(Ms([e, r])), 12))
}
function o6(t, e, r) {
    return (
        Hi(e) !== 32 && $i.throwArgumentError("salt must be 32 bytes", "salt", e),
        Hi(r) !== 32 && $i.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", r),
        nt(Er(st(ft(["0xff", nt(t), e, r])), 12))
    )
}
class a6 extends ui {
    constructor(e) {
        super("address", "address", e, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(e, r) {
        try {
            r = nt(r)
        } catch (n) {
            this._throwError(n.message, r)
        }
        return e.writeValue(r)
    }
    decode(e) {
        return nt(ut(e.readValue().toHexString(), 20))
    }
}
class l6 extends ui {
    constructor(e) {
        super(e.name, e.type, void 0, e.dynamic)
        this.coder = e
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(e, r) {
        return this.coder.encode(e, r)
    }
    decode(e) {
        return this.coder.decode(e)
    }
}
const co = new F(ll)
function a1(t, e, r) {
    let n = null
    if (Array.isArray(r)) n = r
    else if (r && typeof r == "object") {
        let l = {}
        n = e.map((c) => {
            const f = c.localName
            return (
                f ||
                    co.throwError("cannot encode object for signature with missing names", F.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: c,
                        value: r,
                    }),
                l[f] &&
                    co.throwError("cannot encode object for signature with duplicate names", F.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: c,
                        value: r,
                    }),
                (l[f] = !0),
                r[f]
            )
        })
    } else co.throwArgumentError("invalid tuple value", "tuple", r)
    e.length !== n.length && co.throwArgumentError("types/value length mismatch", "tuple", r)
    let i = new id(t.wordSize),
        s = new id(t.wordSize),
        o = []
    e.forEach((l, c) => {
        let f = n[c]
        if (l.dynamic) {
            let u = s.length
            l.encode(s, f)
            let p = i.writeUpdatableValue()
            o.push((m) => {
                p(m + u)
            })
        } else l.encode(i, f)
    }),
        o.forEach((l) => {
            l(i.length)
        })
    let a = t.appendWriter(i)
    return (a += t.appendWriter(s)), a
}
function l1(t, e) {
    let r = [],
        n = t.subReader(0)
    e.forEach((s) => {
        let o = null
        if (s.dynamic) {
            let a = t.readValue(),
                l = n.subReader(a.toNumber())
            try {
                o = s.decode(l)
            } catch (c) {
                if (c.code === F.errors.BUFFER_OVERRUN) throw c
                ;(o = c), (o.baseType = s.name), (o.name = s.localName), (o.type = s.type)
            }
        } else
            try {
                o = s.decode(t)
            } catch (a) {
                if (a.code === F.errors.BUFFER_OVERRUN) throw a
                ;(o = a), (o.baseType = s.name), (o.name = s.localName), (o.type = s.type)
            }
        o != null && r.push(o)
    })
    const i = e.reduce((s, o) => {
        const a = o.localName
        return a && (s[a] || (s[a] = 0), s[a]++), s
    }, {})
    e.forEach((s, o) => {
        let a = s.localName
        if (!a || i[a] !== 1 || (a === "length" && (a = "_length"), r[a] != null)) return
        const l = r[o]
        l instanceof Error
            ? Object.defineProperty(r, a, {
                  enumerable: !0,
                  get: () => {
                      throw l
                  },
              })
            : (r[a] = l)
    })
    for (let s = 0; s < r.length; s++) {
        const o = r[s]
        o instanceof Error &&
            Object.defineProperty(r, s, {
                enumerable: !0,
                get: () => {
                    throw o
                },
            })
    }
    return Object.freeze(r)
}
class c6 extends ui {
    constructor(e, r, n) {
        const i = e.type + "[" + (r >= 0 ? r : "") + "]",
            s = r === -1 || e.dynamic
        super("array", i, n, s)
        ;(this.coder = e), (this.length = r)
    }
    defaultValue() {
        const e = this.coder.defaultValue(),
            r = []
        for (let n = 0; n < this.length; n++) r.push(e)
        return r
    }
    encode(e, r) {
        Array.isArray(r) || this._throwError("expected array value", r)
        let n = this.length
        n === -1 && ((n = r.length), e.writeValue(r.length)),
            co.checkArgumentCount(r.length, n, "coder array" + (this.localName ? " " + this.localName : ""))
        let i = []
        for (let s = 0; s < r.length; s++) i.push(this.coder)
        return a1(e, i, r)
    }
    decode(e) {
        let r = this.length
        r === -1 &&
            ((r = e.readValue().toNumber()),
            r * 32 > e._data.length && co.throwError("insufficient data length", F.errors.BUFFER_OVERRUN, { length: e._data.length, count: r }))
        let n = []
        for (let i = 0; i < r; i++) n.push(new l6(this.coder))
        return e.coerce(this.name, l1(e, n))
    }
}
class f6 extends ui {
    constructor(e) {
        super("bool", "bool", e, !1)
    }
    defaultValue() {
        return !1
    }
    encode(e, r) {
        return e.writeValue(r ? 1 : 0)
    }
    decode(e) {
        return e.coerce(this.type, !e.readValue().isZero())
    }
}
class c1 extends ui {
    constructor(e, r) {
        super(e, e, r, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(e, r) {
        r = le(r)
        let n = e.writeValue(r.length)
        return (n += e.writeBytes(r)), n
    }
    decode(e) {
        return e.readBytes(e.readValue().toNumber(), !0)
    }
}
class u6 extends c1 {
    constructor(e) {
        super("bytes", e)
    }
    decode(e) {
        return e.coerce(this.name, pe(super.decode(e)))
    }
}
class d6 extends ui {
    constructor(e, r) {
        let n = "bytes" + String(e)
        super(n, n, r, !1)
        this.size = e
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(e, r) {
        let n = le(r)
        return n.length !== this.size && this._throwError("incorrect data length", r), e.writeBytes(n)
    }
    decode(e) {
        return e.coerce(this.name, pe(e.readBytes(this.size)))
    }
}
class h6 extends ui {
    constructor(e) {
        super("null", "", e, !1)
    }
    defaultValue() {
        return null
    }
    encode(e, r) {
        return r != null && this._throwError("not null", r), e.writeBytes([])
    }
    decode(e) {
        return e.readBytes(0), e.coerce(this.name, null)
    }
}
const f1 = "0x0000000000000000000000000000000000000000",
    u1 = ce.from(-1),
    y0 = ce.from(0),
    d1 = ce.from(1),
    p6 = ce.from(2),
    g6 = ce.from("1000000000000000000"),
    h1 = ce.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    m6 = ce.from("-0x8000000000000000000000000000000000000000000000000000000000000000"),
    b6 = ce.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    _0 = "0x0000000000000000000000000000000000000000000000000000000000000000",
    x6 = "\u039E"
var p1 = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    AddressZero: f1,
    NegativeOne: u1,
    Zero: y0,
    One: d1,
    Two: p6,
    WeiPerEther: g6,
    MaxUint256: h1,
    MinInt256: m6,
    MaxInt256: b6,
    HashZero: _0,
    EtherSymbol: x6,
})
class v6 extends ui {
    constructor(e, r, n) {
        const i = (r ? "int" : "uint") + e * 8
        super(i, i, n, !1)
        ;(this.size = e), (this.signed = r)
    }
    defaultValue() {
        return 0
    }
    encode(e, r) {
        let n = ce.from(r),
            i = h1.mask(e.wordSize * 8)
        if (this.signed) {
            let s = i.mask(this.size * 8 - 1)
            ;(n.gt(s) || n.lt(s.add(d1).mul(u1))) && this._throwError("value out-of-bounds", r)
        } else (n.lt(y0) || n.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", r)
        return (
            (n = n.toTwos(this.size * 8).mask(this.size * 8)),
            this.signed && (n = n.fromTwos(this.size * 8).toTwos(8 * e.wordSize)),
            e.writeValue(n)
        )
    }
    decode(e) {
        let r = e.readValue().mask(this.size * 8)
        return this.signed && (r = r.fromTwos(this.size * 8)), e.coerce(this.name, r)
    }
}
const y6 = "strings/5.5.0",
    g1 = new F(y6)
var Dn
;(function (t) {
    ;(t.current = ""), (t.NFC = "NFC"), (t.NFD = "NFD"), (t.NFKC = "NFKC"), (t.NFKD = "NFKD")
})(Dn || (Dn = {}))
var _r
;(function (t) {
    ;(t.UNEXPECTED_CONTINUE = "unexpected continuation byte"),
        (t.BAD_PREFIX = "bad codepoint prefix"),
        (t.OVERRUN = "string overrun"),
        (t.MISSING_CONTINUE = "missing continuation byte"),
        (t.OUT_OF_RANGE = "out of UTF-8 range"),
        (t.UTF16_SURROGATE = "UTF-16 surrogate"),
        (t.OVERLONG = "overlong representation")
})(_r || (_r = {}))
function _6(t, e, r, n, i) {
    return g1.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", r)
}
function m1(t, e, r, n, i) {
    if (t === _r.BAD_PREFIX || t === _r.UNEXPECTED_CONTINUE) {
        let s = 0
        for (let o = e + 1; o < r.length && r[o] >> 6 === 2; o++) s++
        return s
    }
    return t === _r.OVERRUN ? r.length - e - 1 : 0
}
function w6(t, e, r, n, i) {
    return t === _r.OVERLONG ? (n.push(i), 0) : (n.push(65533), m1(t, e, r))
}
const b1 = Object.freeze({ error: _6, ignore: m1, replace: w6 })
function w0(t, e) {
    e == null && (e = b1.error), (t = le(t))
    const r = []
    let n = 0
    for (; n < t.length; ) {
        const i = t[n++]
        if (i >> 7 === 0) {
            r.push(i)
            continue
        }
        let s = null,
            o = null
        if ((i & 224) === 192) (s = 1), (o = 127)
        else if ((i & 240) === 224) (s = 2), (o = 2047)
        else if ((i & 248) === 240) (s = 3), (o = 65535)
        else {
            ;(i & 192) === 128 ? (n += e(_r.UNEXPECTED_CONTINUE, n - 1, t, r)) : (n += e(_r.BAD_PREFIX, n - 1, t, r))
            continue
        }
        if (n - 1 + s >= t.length) {
            n += e(_r.OVERRUN, n - 1, t, r)
            continue
        }
        let a = i & ((1 << (8 - s - 1)) - 1)
        for (let l = 0; l < s; l++) {
            let c = t[n]
            if ((c & 192) != 128) {
                ;(n += e(_r.MISSING_CONTINUE, n, t, r)), (a = null)
                break
            }
            ;(a = (a << 6) | (c & 63)), n++
        }
        if (a !== null) {
            if (a > 1114111) {
                n += e(_r.OUT_OF_RANGE, n - 1 - s, t, r, a)
                continue
            }
            if (a >= 55296 && a <= 57343) {
                n += e(_r.UTF16_SURROGATE, n - 1 - s, t, r, a)
                continue
            }
            if (a <= o) {
                n += e(_r.OVERLONG, n - 1 - s, t, r, a)
                continue
            }
            r.push(a)
        }
    }
    return r
}
function zt(t, e = Dn.current) {
    e != Dn.current && (g1.checkNormalize(), (t = t.normalize(e)))
    let r = []
    for (let n = 0; n < t.length; n++) {
        const i = t.charCodeAt(n)
        if (i < 128) r.push(i)
        else if (i < 2048) r.push((i >> 6) | 192), r.push((i & 63) | 128)
        else if ((i & 64512) == 55296) {
            n++
            const s = t.charCodeAt(n)
            if (n >= t.length || (s & 64512) !== 56320) throw new Error("invalid utf-8 string")
            const o = 65536 + ((i & 1023) << 10) + (s & 1023)
            r.push((o >> 18) | 240), r.push(((o >> 12) & 63) | 128), r.push(((o >> 6) & 63) | 128), r.push((o & 63) | 128)
        } else r.push((i >> 12) | 224), r.push(((i >> 6) & 63) | 128), r.push((i & 63) | 128)
    }
    return le(r)
}
function tu(t) {
    const e = "0000" + t.toString(16)
    return "\\u" + e.substring(e.length - 4)
}
function E6(t, e) {
    return (
        '"' +
        w0(t, e)
            .map((r) => {
                if (r < 256) {
                    switch (r) {
                        case 8:
                            return "\\b"
                        case 9:
                            return "\\t"
                        case 10:
                            return "\\n"
                        case 13:
                            return "\\r"
                        case 34:
                            return '\\"'
                        case 92:
                            return "\\\\"
                    }
                    if (r >= 32 && r < 127) return String.fromCharCode(r)
                }
                return r <= 65535 ? tu(r) : ((r -= 65536), tu(((r >> 10) & 1023) + 55296) + tu((r & 1023) + 56320))
            })
            .join("") +
        '"'
    )
}
function sd(t) {
    return t
        .map((e) => (e <= 65535 ? String.fromCharCode(e) : ((e -= 65536), String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320))))
        .join("")
}
function Xi(t, e) {
    return sd(w0(t, e))
}
function od(t, e = Dn.current) {
    return w0(zt(t, e))
}
function S6(t) {
    const e = zt(t)
    if (e.length > 31) throw new Error("bytes32 string must be less than 32 bytes")
    return pe(ft([e, _0]).slice(0, 32))
}
function A6(t) {
    const e = le(t)
    if (e.length !== 32) throw new Error("invalid bytes32 - not 32 bytes long")
    if (e[31] !== 0) throw new Error("invalid bytes32 string - no null terminator")
    let r = 31
    for (; e[r - 1] === 0; ) r--
    return Xi(e.slice(0, r))
}
function T6(t) {
    if (t.length % 4 !== 0) throw new Error("bad data")
    let e = []
    for (let r = 0; r < t.length; r += 4) e.push(parseInt(t.substring(r, r + 4), 16))
    return e
}
function E0(t, e) {
    e ||
        (e = function (i) {
            return [parseInt(i, 16)]
        })
    let r = 0,
        n = {}
    return (
        t.split(",").forEach((i) => {
            let s = i.split(":")
            ;(r += parseInt(s[0], 16)), (n[r] = e(s[1]))
        }),
        n
    )
}
function x1(t) {
    let e = 0
    return t.split(",").map((r) => {
        let n = r.split("-")
        n.length === 1 ? (n[1] = "0") : n[1] === "" && (n[1] = "1")
        let i = e + parseInt(n[0], 16)
        return (e = parseInt(n[1], 16)), { l: i, h: e }
    })
}
function S0(t, e) {
    let r = 0
    for (let n = 0; n < e.length; n++) {
        let i = e[n]
        if (((r += i.l), t >= r && t <= r + i.h && (t - r) % (i.d || 1) === 0)) {
            if (i.e && i.e.indexOf(t - r) !== -1) continue
            return i
        }
    }
    return null
}
const C6 = x1(
        "221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"
    ),
    k6 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((t) => parseInt(t, 16)),
    N6 = [
        { h: 25, s: 32, l: 65 },
        { h: 30, s: 32, e: [23], l: 127 },
        { h: 54, s: 1, e: [48], l: 64, d: 2 },
        { h: 14, s: 1, l: 57, d: 2 },
        { h: 44, s: 1, l: 17, d: 2 },
        { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
        { h: 16, s: 1, l: 68, d: 2 },
        { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
        { h: 26, s: 32, e: [17], l: 435 },
        { h: 22, s: 1, l: 71, d: 2 },
        { h: 15, s: 80, l: 40 },
        { h: 31, s: 32, l: 16 },
        { h: 32, s: 1, l: 80, d: 2 },
        { h: 52, s: 1, l: 42, d: 2 },
        { h: 12, s: 1, l: 55, d: 2 },
        { h: 40, s: 1, e: [38], l: 15, d: 2 },
        { h: 14, s: 1, l: 48, d: 2 },
        { h: 37, s: 48, l: 49 },
        { h: 148, s: 1, l: 6351, d: 2 },
        { h: 88, s: 1, l: 160, d: 2 },
        { h: 15, s: 16, l: 704 },
        { h: 25, s: 26, l: 854 },
        { h: 25, s: 32, l: 55915 },
        { h: 37, s: 40, l: 1247 },
        { h: 25, s: -119711, l: 53248 },
        { h: 25, s: -119763, l: 52 },
        { h: 25, s: -119815, l: 52 },
        { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
        { h: 25, s: -119919, l: 52 },
        { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
        { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
        { h: 25, s: -120075, l: 52 },
        { h: 25, s: -120127, l: 52 },
        { h: 25, s: -120179, l: 52 },
        { h: 25, s: -120231, l: 52 },
        { h: 25, s: -120283, l: 52 },
        { h: 25, s: -120335, l: 52 },
        { h: 24, s: -119543, e: [17], l: 56 },
        { h: 24, s: -119601, e: [17], l: 58 },
        { h: 24, s: -119659, e: [17], l: 58 },
        { h: 24, s: -119717, e: [17], l: 58 },
        { h: 24, s: -119775, e: [17], l: 58 },
    ],
    P6 = E0(
        "b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"
    ),
    I6 = E0(
        "179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"
    ),
    $6 = E0(
        "df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D",
        T6
    ),
    B6 = x1(
        "80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001"
    )
function O6(t) {
    return t.reduce(
        (e, r) => (
            r.forEach((n) => {
                e.push(n)
            }),
            e
        ),
        []
    )
}
function M6(t) {
    return !!S0(t, C6)
}
function R6(t) {
    let e = S0(t, N6)
    if (e) return [t + e.s]
    let r = P6[t]
    if (r) return r
    let n = I6[t]
    if (n) return [t + n[0]]
    let i = $6[t]
    return i || null
}
function L6(t) {
    return !!S0(t, B6)
}
function A0(t) {
    if (t.match(/^[a-z0-9-]*$/i) && t.length <= 59) return t.toLowerCase()
    let e = od(t)
    ;(e = O6(
        e.map((n) => {
            if (k6.indexOf(n) >= 0) return []
            if (n >= 65024 && n <= 65039) return []
            let i = R6(n)
            return i || [n]
        })
    )),
        (e = od(sd(e), Dn.NFKC)),
        e.forEach((n) => {
            if (L6(n)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED")
        }),
        e.forEach((n) => {
            if (M6(n)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED")
        })
    let r = sd(e)
    if (r.substring(0, 1) === "-" || r.substring(2, 4) === "--" || r.substring(r.length - 1) === "-") throw new Error("invalid hyphen")
    if (r.length > 63) throw new Error("too long")
    return r
}
class D6 extends c1 {
    constructor(e) {
        super("string", e)
    }
    defaultValue() {
        return ""
    }
    encode(e, r) {
        return super.encode(e, zt(r))
    }
    decode(e) {
        return Xi(super.decode(e))
    }
}
class Il extends ui {
    constructor(e, r) {
        let n = !1
        const i = []
        e.forEach((o) => {
            o.dynamic && (n = !0), i.push(o.type)
        })
        const s = "tuple(" + i.join(",") + ")"
        super("tuple", s, r, n)
        this.coders = e
    }
    defaultValue() {
        const e = []
        this.coders.forEach((n) => {
            e.push(n.defaultValue())
        })
        const r = this.coders.reduce((n, i) => {
            const s = i.localName
            return s && (n[s] || (n[s] = 0), n[s]++), n
        }, {})
        return (
            this.coders.forEach((n, i) => {
                let s = n.localName
                !s || r[s] !== 1 || (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]))
            }),
            Object.freeze(e)
        )
    }
    encode(e, r) {
        return a1(e, this.coders, r)
    }
    decode(e) {
        return e.coerce(this.name, l1(e, this.coders))
    }
}
const ta = new F(ll),
    F6 = new RegExp(/^bytes([0-9]*)$/),
    V6 = new RegExp(/^(u?int)([0-9]*)$/)
class Xc {
    constructor(e) {
        ta.checkNew(new.target, Xc), X(this, "coerceFunc", e || null)
    }
    _getCoder(e) {
        switch (e.baseType) {
            case "address":
                return new a6(e.name)
            case "bool":
                return new f6(e.name)
            case "string":
                return new D6(e.name)
            case "bytes":
                return new u6(e.name)
            case "array":
                return new c6(this._getCoder(e.arrayChildren), e.arrayLength, e.name)
            case "tuple":
                return new Il(
                    (e.components || []).map((n) => this._getCoder(n)),
                    e.name
                )
            case "":
                return new h6(e.name)
        }
        let r = e.type.match(V6)
        if (r) {
            let n = parseInt(r[2] || "256")
            return (
                (n === 0 || n > 256 || n % 8 !== 0) && ta.throwArgumentError("invalid " + r[1] + " bit length", "param", e),
                new v6(n / 8, r[1] === "int", e.name)
            )
        }
        if (((r = e.type.match(F6)), r)) {
            let n = parseInt(r[1])
            return (n === 0 || n > 32) && ta.throwArgumentError("invalid bytes length", "param", e), new d6(n, e.name)
        }
        return ta.throwArgumentError("invalid type", "type", e.type)
    }
    _getWordSize() {
        return 32
    }
    _getReader(e, r) {
        return new _c(e, this._getWordSize(), this.coerceFunc, r)
    }
    _getWriter() {
        return new id(this._getWordSize())
    }
    getDefaultValue(e) {
        const r = e.map((i) => this._getCoder(Wt.from(i)))
        return new Il(r, "_").defaultValue()
    }
    encode(e, r) {
        e.length !== r.length &&
            ta.throwError("types/values length mismatch", F.errors.INVALID_ARGUMENT, {
                count: { types: e.length, values: r.length },
                value: { types: e, values: r },
            })
        const n = e.map((o) => this._getCoder(Wt.from(o))),
            i = new Il(n, "_"),
            s = this._getWriter()
        return i.encode(s, r), s.data
    }
    decode(e, r, n) {
        const i = e.map((o) => this._getCoder(Wt.from(o)))
        return new Il(i, "_").decode(this._getReader(le(r), n))
    }
}
const v1 = new Xc()
function Bi(t) {
    return st(zt(t))
}
const y1 = "hash/5.5.0",
    Ep = new F(y1),
    _1 = new Uint8Array(32)
_1.fill(0)
const U6 = new RegExp("^((.*)\\.)?([^.]+)$")
function H6(t) {
    try {
        const e = t.split(".")
        for (let r = 0; r < e.length; r++) if (A0(e[r]).length === 0) throw new Error("empty")
        return !0
    } catch {}
    return !1
}
function Ya(t) {
    typeof t != "string" && Ep.throwArgumentError("invalid ENS name; not a string", "name", t)
    let e = t,
        r = _1
    for (; e.length; ) {
        const n = e.match(U6)
        ;(n == null || n[2] === "") && Ep.throwArgumentError("invalid ENS address; missing component", "name", t)
        const i = zt(A0(n[3]))
        ;(r = st(ft([r, st(i)]))), (e = n[2] || "")
    }
    return pe(r)
}
const q6 = `Ethereum Signed Message:
`
function T0(t) {
    return typeof t == "string" && (t = zt(t)), st(ft([zt(q6), zt(String(t.length)), t]))
}
var j6 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const Mt = new F(y1),
    w1 = new Uint8Array(32)
w1.fill(0)
const z6 = ce.from(-1),
    E1 = ce.from(0),
    S1 = ce.from(1),
    K6 = ce.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
function G6(t) {
    const e = le(t),
        r = e.length % 32
    return r ? qr([e, w1.slice(r)]) : pe(e)
}
const W6 = ut(S1.toHexString(), 32),
    J6 = ut(E1.toHexString(), 32),
    Sp = { name: "string", version: "string", chainId: "uint256", verifyingContract: "address", salt: "bytes32" },
    ru = ["name", "version", "chainId", "verifyingContract", "salt"]
function Ap(t) {
    return function (e) {
        return typeof e != "string" && Mt.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e
    }
}
const X6 = {
    name: Ap("name"),
    version: Ap("version"),
    chainId: function (t) {
        try {
            return ce.from(t).toString()
        } catch {}
        return Mt.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", t)
    },
    verifyingContract: function (t) {
        try {
            return nt(t).toLowerCase()
        } catch {}
        return Mt.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", t)
    },
    salt: function (t) {
        try {
            const e = le(t)
            if (e.length !== 32) throw new Error("bad length")
            return pe(e)
        } catch {}
        return Mt.throwArgumentError('invalid domain value "salt"', "domain.salt", t)
    },
}
function nu(t) {
    {
        const e = t.match(/^(u?)int(\d*)$/)
        if (e) {
            const r = e[1] === "",
                n = parseInt(e[2] || "256")
            ;(n % 8 !== 0 || n > 256 || (e[2] && e[2] !== String(n))) && Mt.throwArgumentError("invalid numeric width", "type", t)
            const i = K6.mask(r ? n - 1 : n),
                s = r ? i.add(S1).mul(z6) : E1
            return function (o) {
                const a = ce.from(o)
                return (
                    (a.lt(s) || a.gt(i)) && Mt.throwArgumentError(`value out-of-bounds for ${t}`, "value", o),
                    ut(a.toTwos(256).toHexString(), 32)
                )
            }
        }
    }
    {
        const e = t.match(/^bytes(\d+)$/)
        if (e) {
            const r = parseInt(e[1])
            return (
                (r === 0 || r > 32 || e[1] !== String(r)) && Mt.throwArgumentError("invalid bytes width", "type", t),
                function (n) {
                    return le(n).length !== r && Mt.throwArgumentError(`invalid length for ${t}`, "value", n), G6(n)
                }
            )
        }
    }
    switch (t) {
        case "address":
            return function (e) {
                return ut(nt(e), 32)
            }
        case "bool":
            return function (e) {
                return e ? W6 : J6
            }
        case "bytes":
            return function (e) {
                return st(e)
            }
        case "string":
            return function (e) {
                return Bi(e)
            }
    }
    return null
}
function Tp(t, e) {
    return `${t}(${e.map(({ name: r, type: n }) => n + " " + r).join(",")})`
}
class tr {
    constructor(e) {
        X(this, "types", Object.freeze(pr(e))), X(this, "_encoderCache", {}), X(this, "_types", {})
        const r = {},
            n = {},
            i = {}
        Object.keys(e).forEach((a) => {
            ;(r[a] = {}), (n[a] = []), (i[a] = {})
        })
        for (const a in e) {
            const l = {}
            e[a].forEach((c) => {
                l[c.name] && Mt.throwArgumentError(`duplicate variable name ${JSON.stringify(c.name)} in ${JSON.stringify(a)}`, "types", e),
                    (l[c.name] = !0)
                const f = c.type.match(/^([^\x5b]*)(\x5b|$)/)[1]
                f === a && Mt.throwArgumentError(`circular type reference to ${JSON.stringify(f)}`, "types", e),
                    !nu(f) && (n[f] || Mt.throwArgumentError(`unknown type ${JSON.stringify(f)}`, "types", e), n[f].push(a), (r[a][f] = !0))
            })
        }
        const s = Object.keys(n).filter((a) => n[a].length === 0)
        s.length === 0
            ? Mt.throwArgumentError("missing primary type", "types", e)
            : s.length > 1 &&
              Mt.throwArgumentError(`ambiguous primary types or unused types: ${s.map((a) => JSON.stringify(a)).join(", ")}`, "types", e),
            X(this, "primaryType", s[0])
        function o(a, l) {
            l[a] && Mt.throwArgumentError(`circular type reference to ${JSON.stringify(a)}`, "types", e),
                (l[a] = !0),
                Object.keys(r[a]).forEach((c) => {
                    !n[c] ||
                        (o(c, l),
                        Object.keys(l).forEach((f) => {
                            i[f][c] = !0
                        }))
                }),
                delete l[a]
        }
        o(this.primaryType, {})
        for (const a in i) {
            const l = Object.keys(i[a])
            l.sort(), (this._types[a] = Tp(a, e[a]) + l.map((c) => Tp(c, e[c])).join(""))
        }
    }
    getEncoder(e) {
        let r = this._encoderCache[e]
        return r || (r = this._encoderCache[e] = this._getEncoder(e)), r
    }
    _getEncoder(e) {
        {
            const i = nu(e)
            if (i) return i
        }
        const r = e.match(/^(.*)(\x5b(\d*)\x5d)$/)
        if (r) {
            const i = r[1],
                s = this.getEncoder(i),
                o = parseInt(r[3])
            return (a) => {
                o >= 0 && a.length !== o && Mt.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", a)
                let l = a.map(s)
                return this._types[i] && (l = l.map(st)), st(qr(l))
            }
        }
        const n = this.types[e]
        if (n) {
            const i = Bi(this._types[e])
            return (s) => {
                const o = n.map(({ name: a, type: l }) => {
                    const c = this.getEncoder(l)(s[a])
                    return this._types[l] ? st(c) : c
                })
                return o.unshift(i), qr(o)
            }
        }
        return Mt.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    encodeType(e) {
        const r = this._types[e]
        return r || Mt.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), r
    }
    encodeData(e, r) {
        return this.getEncoder(e)(r)
    }
    hashStruct(e, r) {
        return st(this.encodeData(e, r))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, r, n) {
        if (nu(e)) return n(e, r)
        const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/)
        if (i) {
            const o = i[1],
                a = parseInt(i[3])
            return (
                a >= 0 && r.length !== a && Mt.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", r),
                r.map((l) => this._visit(o, l, n))
            )
        }
        const s = this.types[e]
        return s
            ? s.reduce((o, { name: a, type: l }) => ((o[a] = this._visit(l, r[a], n)), o), {})
            : Mt.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    visit(e, r) {
        return this._visit(this.primaryType, e, r)
    }
    static from(e) {
        return new tr(e)
    }
    static getPrimaryType(e) {
        return tr.from(e).primaryType
    }
    static hashStruct(e, r, n) {
        return tr.from(r).hashStruct(e, n)
    }
    static hashDomain(e) {
        const r = []
        for (const n in e) {
            const i = Sp[n]
            i || Mt.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", e), r.push({ name: n, type: i })
        }
        return r.sort((n, i) => ru.indexOf(n.name) - ru.indexOf(i.name)), tr.hashStruct("EIP712Domain", { EIP712Domain: r }, e)
    }
    static encode(e, r, n) {
        return qr(["0x1901", tr.hashDomain(e), tr.from(r).hash(n)])
    }
    static hash(e, r, n) {
        return st(tr.encode(e, r, n))
    }
    static resolveNames(e, r, n, i) {
        return j6(this, void 0, void 0, function* () {
            e = Pt(e)
            const s = {}
            e.verifyingContract && !Le(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x")
            const o = tr.from(r)
            o.visit(n, (a, l) => (a === "address" && !Le(l, 20) && (s[l] = "0x"), l))
            for (const a in s) s[a] = yield i(a)
            return (
                e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]),
                (n = o.visit(n, (a, l) => (a === "address" && s[l] ? s[l] : l))),
                { domain: e, value: n }
            )
        })
    }
    static getPayload(e, r, n) {
        tr.hashDomain(e)
        const i = {},
            s = []
        ru.forEach((l) => {
            const c = e[l]
            c != null && ((i[l] = X6[l](c)), s.push({ name: l, type: Sp[l] }))
        })
        const o = tr.from(r),
            a = Pt(r)
        return (
            a.EIP712Domain ? Mt.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", r) : (a.EIP712Domain = s),
            o.encode(n),
            {
                types: a,
                domain: i,
                primaryType: o.primaryType,
                message: o.visit(n, (l, c) => {
                    if (l.match(/^bytes(\d*)/)) return pe(le(c))
                    if (l.match(/^u?int/)) return ce.from(c).toString()
                    switch (l) {
                        case "address":
                            return c.toLowerCase()
                        case "bool":
                            return !!c
                        case "string":
                            return typeof c != "string" && Mt.throwArgumentError("invalid string", "value", c), c
                    }
                    return Mt.throwArgumentError("unsupported type", "type", l)
                }),
            }
        )
    }
}
const $t = new F(ll)
class A1 extends Hs {}
class T1 extends Hs {}
class Y6 extends Hs {}
class wc extends Hs {
    static isIndexed(e) {
        return !!(e && e._isIndexed)
    }
}
const Z6 = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] },
}
function Cp(t, e) {
    const r = new Error(`deferred error during ABI decoding triggered accessing ${t}`)
    return (r.error = e), r
}
class Za {
    constructor(e) {
        $t.checkNew(new.target, Za)
        let r = []
        typeof e == "string" ? (r = JSON.parse(e)) : (r = e),
            X(
                this,
                "fragments",
                r.map((n) => En.from(n)).filter((n) => n != null)
            ),
            X(this, "_abiCoder", Yt(new.target, "getAbiCoder")()),
            X(this, "functions", {}),
            X(this, "errors", {}),
            X(this, "events", {}),
            X(this, "structs", {}),
            this.fragments.forEach((n) => {
                let i = null
                switch (n.type) {
                    case "constructor":
                        if (this.deploy) {
                            $t.warn("duplicate definition - constructor")
                            return
                        }
                        X(this, "deploy", n)
                        return
                    case "function":
                        i = this.functions
                        break
                    case "event":
                        i = this.events
                        break
                    case "error":
                        i = this.errors
                        break
                    default:
                        return
                }
                let s = n.format()
                if (i[s]) {
                    $t.warn("duplicate definition - " + s)
                    return
                }
                i[s] = n
            }),
            this.deploy || X(this, "deploy", rn.from({ payable: !1, type: "constructor" })),
            X(this, "_isInterface", !0)
    }
    format(e) {
        e || (e = Xe.full), e === Xe.sighash && $t.throwArgumentError("interface does not support formatting sighash", "format", e)
        const r = this.fragments.map((n) => n.format(e))
        return e === Xe.json ? JSON.stringify(r.map((n) => JSON.parse(n))) : r
    }
    static getAbiCoder() {
        return v1
    }
    static getAddress(e) {
        return nt(e)
    }
    static getSighash(e) {
        return Er(Bi(e.format()), 0, 4)
    }
    static getEventTopic(e) {
        return Bi(e.format())
    }
    getFunction(e) {
        if (Le(e)) {
            for (const n in this.functions) if (e === this.getSighash(n)) return this.functions[n]
            $t.throwArgumentError("no matching function", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const n = e.trim(),
                i = Object.keys(this.functions).filter((s) => s.split("(")[0] === n)
            return (
                i.length === 0
                    ? $t.throwArgumentError("no matching function", "name", n)
                    : i.length > 1 && $t.throwArgumentError("multiple matching functions", "name", n),
                this.functions[i[0]]
            )
        }
        const r = this.functions[nn.fromString(e).format()]
        return r || $t.throwArgumentError("no matching function", "signature", e), r
    }
    getEvent(e) {
        if (Le(e)) {
            const n = e.toLowerCase()
            for (const i in this.events) if (n === this.getEventTopic(i)) return this.events[i]
            $t.throwArgumentError("no matching event", "topichash", n)
        }
        if (e.indexOf("(") === -1) {
            const n = e.trim(),
                i = Object.keys(this.events).filter((s) => s.split("(")[0] === n)
            return (
                i.length === 0
                    ? $t.throwArgumentError("no matching event", "name", n)
                    : i.length > 1 && $t.throwArgumentError("multiple matching events", "name", n),
                this.events[i[0]]
            )
        }
        const r = this.events[_n.fromString(e).format()]
        return r || $t.throwArgumentError("no matching event", "signature", e), r
    }
    getError(e) {
        if (Le(e)) {
            const n = Yt(this.constructor, "getSighash")
            for (const i in this.errors) {
                const s = this.errors[i]
                if (e === n(s)) return this.errors[i]
            }
            $t.throwArgumentError("no matching error", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const n = e.trim(),
                i = Object.keys(this.errors).filter((s) => s.split("(")[0] === n)
            return (
                i.length === 0
                    ? $t.throwArgumentError("no matching error", "name", n)
                    : i.length > 1 && $t.throwArgumentError("multiple matching errors", "name", n),
                this.errors[i[0]]
            )
        }
        const r = this.errors[nn.fromString(e).format()]
        return r || $t.throwArgumentError("no matching error", "signature", e), r
    }
    getSighash(e) {
        if (typeof e == "string")
            try {
                e = this.getFunction(e)
            } catch (r) {
                try {
                    e = this.getError(e)
                } catch {
                    throw r
                }
            }
        return Yt(this.constructor, "getSighash")(e)
    }
    getEventTopic(e) {
        return typeof e == "string" && (e = this.getEvent(e)), Yt(this.constructor, "getEventTopic")(e)
    }
    _decodeParams(e, r) {
        return this._abiCoder.decode(e, r)
    }
    _encodeParams(e, r) {
        return this._abiCoder.encode(e, r)
    }
    encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
    }
    decodeErrorResult(e, r) {
        typeof e == "string" && (e = this.getError(e))
        const n = le(r)
        return (
            pe(n.slice(0, 4)) !== this.getSighash(e) && $t.throwArgumentError(`data signature does not match error ${e.name}.`, "data", pe(n)),
            this._decodeParams(e.inputs, n.slice(4))
        )
    }
    encodeErrorResult(e, r) {
        return typeof e == "string" && (e = this.getError(e)), pe(ft([this.getSighash(e), this._encodeParams(e.inputs, r || [])]))
    }
    decodeFunctionData(e, r) {
        typeof e == "string" && (e = this.getFunction(e))
        const n = le(r)
        return (
            pe(n.slice(0, 4)) !== this.getSighash(e) &&
                $t.throwArgumentError(`data signature does not match function ${e.name}.`, "data", pe(n)),
            this._decodeParams(e.inputs, n.slice(4))
        )
    }
    encodeFunctionData(e, r) {
        return typeof e == "string" && (e = this.getFunction(e)), pe(ft([this.getSighash(e), this._encodeParams(e.inputs, r || [])]))
    }
    decodeFunctionResult(e, r) {
        typeof e == "string" && (e = this.getFunction(e))
        let n = le(r),
            i = null,
            s = null,
            o = null,
            a = null
        switch (n.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(e.outputs, n)
                } catch {}
                break
            case 4: {
                const l = pe(n.slice(0, 4)),
                    c = Z6[l]
                if (c) (s = this._abiCoder.decode(c.inputs, n.slice(4))), (o = c.name), (a = c.signature), c.reason && (i = s[0])
                else
                    try {
                        const f = this.getError(l)
                        ;(s = this._abiCoder.decode(f.inputs, n.slice(4))), (o = f.name), (a = f.format())
                    } catch (f) {
                        console.log(f)
                    }
                break
            }
        }
        return $t.throwError("call revert exception", F.errors.CALL_EXCEPTION, {
            method: e.format(),
            errorArgs: s,
            errorName: o,
            errorSignature: a,
            reason: i,
        })
    }
    encodeFunctionResult(e, r) {
        return typeof e == "string" && (e = this.getFunction(e)), pe(this._abiCoder.encode(e.outputs, r || []))
    }
    encodeFilterTopics(e, r) {
        typeof e == "string" && (e = this.getEvent(e)),
            r.length > e.inputs.length &&
                $t.throwError("too many arguments for " + e.format(), F.errors.UNEXPECTED_ARGUMENT, { argument: "values", value: r })
        let n = []
        e.anonymous || n.push(this.getEventTopic(e))
        const i = (s, o) =>
            s.type === "string"
                ? Bi(o)
                : s.type === "bytes"
                ? st(pe(o))
                : (s.type === "address" && this._abiCoder.encode(["address"], [o]), ut(pe(o), 32))
        for (
            r.forEach((s, o) => {
                let a = e.inputs[o]
                if (!a.indexed) {
                    s != null && $t.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + a.name, s)
                    return
                }
                s == null
                    ? n.push(null)
                    : a.baseType === "array" || a.baseType === "tuple"
                    ? $t.throwArgumentError("filtering with tuples or arrays not supported", "contract." + a.name, s)
                    : Array.isArray(s)
                    ? n.push(s.map((l) => i(a, l)))
                    : n.push(i(a, s))
            });
            n.length && n[n.length - 1] === null;

        )
            n.pop()
        return n
    }
    encodeEventLog(e, r) {
        typeof e == "string" && (e = this.getEvent(e))
        const n = [],
            i = [],
            s = []
        return (
            e.anonymous || n.push(this.getEventTopic(e)),
            r.length !== e.inputs.length && $t.throwArgumentError("event arguments/values mismatch", "values", r),
            e.inputs.forEach((o, a) => {
                const l = r[a]
                if (o.indexed)
                    if (o.type === "string") n.push(Bi(l))
                    else if (o.type === "bytes") n.push(st(l))
                    else {
                        if (o.baseType === "tuple" || o.baseType === "array") throw new Error("not implemented")
                        n.push(this._abiCoder.encode([o.type], [l]))
                    }
                else i.push(o), s.push(l)
            }),
            { data: this._abiCoder.encode(i, s), topics: n }
        )
    }
    decodeEventLog(e, r, n) {
        if ((typeof e == "string" && (e = this.getEvent(e)), n != null && !e.anonymous)) {
            let p = this.getEventTopic(e)
            ;(!Le(n[0], 32) || n[0].toLowerCase() !== p) &&
                $t.throwError("fragment/topic mismatch", F.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: p, value: n[0] }),
                (n = n.slice(1))
        }
        let i = [],
            s = [],
            o = []
        e.inputs.forEach((p, m) => {
            p.indexed
                ? p.type === "string" || p.type === "bytes" || p.baseType === "tuple" || p.baseType === "array"
                    ? (i.push(Wt.fromObject({ type: "bytes32", name: p.name })), o.push(!0))
                    : (i.push(p), o.push(!1))
                : (s.push(p), o.push(!1))
        })
        let a = n != null ? this._abiCoder.decode(i, ft(n)) : null,
            l = this._abiCoder.decode(s, r, !0),
            c = [],
            f = 0,
            u = 0
        e.inputs.forEach((p, m) => {
            if (p.indexed)
                if (a == null) c[m] = new wc({ _isIndexed: !0, hash: null })
                else if (o[m]) c[m] = new wc({ _isIndexed: !0, hash: a[u++] })
                else
                    try {
                        c[m] = a[u++]
                    } catch (y) {
                        c[m] = y
                    }
            else
                try {
                    c[m] = l[f++]
                } catch (y) {
                    c[m] = y
                }
            if (p.name && c[p.name] == null) {
                const y = c[m]
                y instanceof Error
                    ? Object.defineProperty(c, p.name, {
                          enumerable: !0,
                          get: () => {
                              throw Cp(`property ${JSON.stringify(p.name)}`, y)
                          },
                      })
                    : (c[p.name] = y)
            }
        })
        for (let p = 0; p < c.length; p++) {
            const m = c[p]
            m instanceof Error &&
                Object.defineProperty(c, p, {
                    enumerable: !0,
                    get: () => {
                        throw Cp(`index ${p}`, m)
                    },
                })
        }
        return Object.freeze(c)
    }
    parseTransaction(e) {
        let r = this.getFunction(e.data.substring(0, 10).toLowerCase())
        return r
            ? new T1({
                  args: this._abiCoder.decode(r.inputs, "0x" + e.data.substring(10)),
                  functionFragment: r,
                  name: r.name,
                  signature: r.format(),
                  sighash: this.getSighash(r),
                  value: ce.from(e.value || "0"),
              })
            : null
    }
    parseLog(e) {
        let r = this.getEvent(e.topics[0])
        return !r || r.anonymous
            ? null
            : new A1({
                  eventFragment: r,
                  name: r.name,
                  signature: r.format(),
                  topic: this.getEventTopic(r),
                  args: this.decodeEventLog(r, e.data, e.topics),
              })
    }
    parseError(e) {
        const r = pe(e)
        let n = this.getError(r.substring(0, 10).toLowerCase())
        return n
            ? new Y6({
                  args: this._abiCoder.decode(n.inputs, "0x" + r.substring(10)),
                  errorFragment: n,
                  name: n.name,
                  signature: n.format(),
                  sighash: this.getSighash(n),
              })
            : null
    }
    static isInterface(e) {
        return !!(e && e._isInterface)
    }
}
const Q6 = "abstract-provider/5.5.1"
var eE =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const tE = new F(Q6)
class rE extends Hs {
    static isForkEvent(e) {
        return !!(e && e._isForkEvent)
    }
}
class qi {
    constructor() {
        tE.checkAbstract(new.target, qi), X(this, "_isProvider", !0)
    }
    getFeeData() {
        return eE(this, void 0, void 0, function* () {
            const { block: e, gasPrice: r } = yield Dt({ block: this.getBlock("latest"), gasPrice: this.getGasPrice().catch((s) => null) })
            let n = null,
                i = null
            return (
                e && e.baseFeePerGas && ((i = ce.from("2500000000")), (n = e.baseFeePerGas.mul(2).add(i))),
                { maxFeePerGas: n, maxPriorityFeePerGas: i, gasPrice: r }
            )
        })
    }
    addListener(e, r) {
        return this.on(e, r)
    }
    removeListener(e, r) {
        return this.off(e, r)
    }
    static isProvider(e) {
        return !!(e && e._isProvider)
    }
}
const nE = "abstract-signer/5.5.0"
var Zr =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const kr = new F(nE),
    iE = [
        "accessList",
        "chainId",
        "customData",
        "data",
        "from",
        "gasLimit",
        "gasPrice",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "to",
        "type",
        "value",
    ],
    sE = [F.errors.INSUFFICIENT_FUNDS, F.errors.NONCE_EXPIRED, F.errors.REPLACEMENT_UNDERPRICED]
class di {
    constructor() {
        kr.checkAbstract(new.target, di), X(this, "_isSigner", !0)
    }
    getBalance(e) {
        return Zr(this, void 0, void 0, function* () {
            return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e)
        })
    }
    getTransactionCount(e) {
        return Zr(this, void 0, void 0, function* () {
            return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e)
        })
    }
    estimateGas(e) {
        return Zr(this, void 0, void 0, function* () {
            this._checkProvider("estimateGas")
            const r = yield Dt(this.checkTransaction(e))
            return yield this.provider.estimateGas(r)
        })
    }
    call(e, r) {
        return Zr(this, void 0, void 0, function* () {
            this._checkProvider("call")
            const n = yield Dt(this.checkTransaction(e))
            return yield this.provider.call(n, r)
        })
    }
    sendTransaction(e) {
        return Zr(this, void 0, void 0, function* () {
            this._checkProvider("sendTransaction")
            const r = yield this.populateTransaction(e),
                n = yield this.signTransaction(r)
            return yield this.provider.sendTransaction(n)
        })
    }
    getChainId() {
        return Zr(this, void 0, void 0, function* () {
            return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId
        })
    }
    getGasPrice() {
        return Zr(this, void 0, void 0, function* () {
            return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
        })
    }
    getFeeData() {
        return Zr(this, void 0, void 0, function* () {
            return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
        })
    }
    resolveName(e) {
        return Zr(this, void 0, void 0, function* () {
            return this._checkProvider("resolveName"), yield this.provider.resolveName(e)
        })
    }
    checkTransaction(e) {
        for (const n in e) iE.indexOf(n) === -1 && kr.throwArgumentError("invalid transaction key: " + n, "transaction", e)
        const r = Pt(e)
        return (
            r.from == null
                ? (r.from = this.getAddress())
                : (r.from = Promise.all([Promise.resolve(r.from), this.getAddress()]).then(
                      (n) => (
                          n[0].toLowerCase() !== n[1].toLowerCase() && kr.throwArgumentError("from address mismatch", "transaction", e), n[0]
                      )
                  )),
            r
        )
    }
    populateTransaction(e) {
        return Zr(this, void 0, void 0, function* () {
            const r = yield Dt(this.checkTransaction(e))
            r.to != null &&
                ((r.to = Promise.resolve(r.to).then((i) =>
                    Zr(this, void 0, void 0, function* () {
                        if (i == null) return null
                        const s = yield this.resolveName(i)
                        return s == null && kr.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s
                    })
                )),
                r.to.catch((i) => {}))
            const n = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null
            if (
                (r.gasPrice != null && (r.type === 2 || n)
                    ? kr.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e)
                    : (r.type === 0 || r.type === 1) &&
                      n &&
                      kr.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e),
                (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
            )
                r.type = 2
            else if (r.type === 0 || r.type === 1) r.gasPrice == null && (r.gasPrice = this.getGasPrice())
            else {
                const i = yield this.getFeeData()
                if (r.type == null)
                    if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
                        if (((r.type = 2), r.gasPrice != null)) {
                            const s = r.gasPrice
                            delete r.gasPrice, (r.maxFeePerGas = s), (r.maxPriorityFeePerGas = s)
                        } else
                            r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas),
                                r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas)
                    else
                        i.gasPrice != null
                            ? (n &&
                                  kr.throwError("network does not support EIP-1559", F.errors.UNSUPPORTED_OPERATION, {
                                      operation: "populateTransaction",
                                  }),
                              r.gasPrice == null && (r.gasPrice = i.gasPrice),
                              (r.type = 0))
                            : kr.throwError("failed to get consistent fee data", F.errors.UNSUPPORTED_OPERATION, {
                                  operation: "signer.getFeeData",
                              })
                else
                    r.type === 2 &&
                        (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas),
                        r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas))
            }
            return (
                r.nonce == null && (r.nonce = this.getTransactionCount("pending")),
                r.gasLimit == null &&
                    (r.gasLimit = this.estimateGas(r).catch((i) => {
                        if (sE.indexOf(i.code) >= 0) throw i
                        return kr.throwError(
                            "cannot estimate gas; transaction may fail or may require manual gas limit",
                            F.errors.UNPREDICTABLE_GAS_LIMIT,
                            { error: i, tx: r }
                        )
                    })),
                r.chainId == null
                    ? (r.chainId = this.getChainId())
                    : (r.chainId = Promise.all([Promise.resolve(r.chainId), this.getChainId()]).then(
                          (i) => (i[1] !== 0 && i[0] !== i[1] && kr.throwArgumentError("chainId address mismatch", "transaction", e), i[0])
                      )),
                yield Dt(r)
            )
        })
    }
    _checkProvider(e) {
        this.provider || kr.throwError("missing provider", F.errors.UNSUPPORTED_OPERATION, { operation: e || "_checkProvider" })
    }
    static isSigner(e) {
        return !!(e && e._isSigner)
    }
}
class To extends di {
    constructor(e, r) {
        kr.checkNew(new.target, To)
        super()
        X(this, "address", e), X(this, "provider", r || null)
    }
    getAddress() {
        return Promise.resolve(this.address)
    }
    _fail(e, r) {
        return Promise.resolve().then(() => {
            kr.throwError(e, F.errors.UNSUPPORTED_OPERATION, { operation: r })
        })
    }
    signMessage(e) {
        return this._fail("VoidSigner cannot sign messages", "signMessage")
    }
    signTransaction(e) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction")
    }
    _signTypedData(e, r, n) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData")
    }
    connect(e) {
        return new To(this.address, e)
    }
}
var hr = {},
    Ke = {},
    cl = C1
function C1(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
C1.equal = function (e, r, n) {
    if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r)
}
var ad = { exports: {} }
typeof Object.create == "function"
    ? (ad.exports = function (e, r) {
          r &&
              ((e.super_ = r),
              (e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })))
      })
    : (ad.exports = function (e, r) {
          if (r) {
              e.super_ = r
              var n = function () {}
              ;(n.prototype = r.prototype), (e.prototype = new n()), (e.prototype.constructor = e)
          }
      })
var oE = cl,
    aE = ad.exports
Ke.inherits = aE
function lE(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320
}
function cE(t, e) {
    if (Array.isArray(t)) return t.slice()
    if (!t) return []
    var r = []
    if (typeof t == "string")
        if (e) {
            if (e === "hex")
                for (t = t.replace(/[^a-z0-9]+/gi, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2)
                    r.push(parseInt(t[i] + t[i + 1], 16))
        } else
            for (var n = 0, i = 0; i < t.length; i++) {
                var s = t.charCodeAt(i)
                s < 128
                    ? (r[n++] = s)
                    : s < 2048
                    ? ((r[n++] = (s >> 6) | 192), (r[n++] = (s & 63) | 128))
                    : lE(t, i)
                    ? ((s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023)),
                      (r[n++] = (s >> 18) | 240),
                      (r[n++] = ((s >> 12) & 63) | 128),
                      (r[n++] = ((s >> 6) & 63) | 128),
                      (r[n++] = (s & 63) | 128))
                    : ((r[n++] = (s >> 12) | 224), (r[n++] = ((s >> 6) & 63) | 128), (r[n++] = (s & 63) | 128))
            }
    else for (i = 0; i < t.length; i++) r[i] = t[i] | 0
    return r
}
Ke.toArray = cE
function fE(t) {
    for (var e = "", r = 0; r < t.length; r++) e += N1(t[r].toString(16))
    return e
}
Ke.toHex = fE
function k1(t) {
    var e = (t >>> 24) | ((t >>> 8) & 65280) | ((t << 8) & 16711680) | ((t & 255) << 24)
    return e >>> 0
}
Ke.htonl = k1
function uE(t, e) {
    for (var r = "", n = 0; n < t.length; n++) {
        var i = t[n]
        e === "little" && (i = k1(i)), (r += P1(i.toString(16)))
    }
    return r
}
Ke.toHex32 = uE
function N1(t) {
    return t.length === 1 ? "0" + t : t
}
Ke.zero2 = N1
function P1(t) {
    return t.length === 7
        ? "0" + t
        : t.length === 6
        ? "00" + t
        : t.length === 5
        ? "000" + t
        : t.length === 4
        ? "0000" + t
        : t.length === 3
        ? "00000" + t
        : t.length === 2
        ? "000000" + t
        : t.length === 1
        ? "0000000" + t
        : t
}
Ke.zero8 = P1
function dE(t, e, r, n) {
    var i = r - e
    oE(i % 4 === 0)
    for (var s = new Array(i / 4), o = 0, a = e; o < s.length; o++, a += 4) {
        var l
        n === "big"
            ? (l = (t[a] << 24) | (t[a + 1] << 16) | (t[a + 2] << 8) | t[a + 3])
            : (l = (t[a + 3] << 24) | (t[a + 2] << 16) | (t[a + 1] << 8) | t[a]),
            (s[o] = l >>> 0)
    }
    return s
}
Ke.join32 = dE
function hE(t, e) {
    for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
        var s = t[n]
        e === "big"
            ? ((r[i] = s >>> 24), (r[i + 1] = (s >>> 16) & 255), (r[i + 2] = (s >>> 8) & 255), (r[i + 3] = s & 255))
            : ((r[i + 3] = s >>> 24), (r[i + 2] = (s >>> 16) & 255), (r[i + 1] = (s >>> 8) & 255), (r[i] = s & 255))
    }
    return r
}
Ke.split32 = hE
function pE(t, e) {
    return (t >>> e) | (t << (32 - e))
}
Ke.rotr32 = pE
function gE(t, e) {
    return (t << e) | (t >>> (32 - e))
}
Ke.rotl32 = gE
function mE(t, e) {
    return (t + e) >>> 0
}
Ke.sum32 = mE
function bE(t, e, r) {
    return (t + e + r) >>> 0
}
Ke.sum32_3 = bE
function xE(t, e, r, n) {
    return (t + e + r + n) >>> 0
}
Ke.sum32_4 = xE
function vE(t, e, r, n, i) {
    return (t + e + r + n + i) >>> 0
}
Ke.sum32_5 = vE
function yE(t, e, r, n) {
    var i = t[e],
        s = t[e + 1],
        o = (n + s) >>> 0,
        a = (o < n ? 1 : 0) + r + i
    ;(t[e] = a >>> 0), (t[e + 1] = o)
}
Ke.sum64 = yE
function _E(t, e, r, n) {
    var i = (e + n) >>> 0,
        s = (i < e ? 1 : 0) + t + r
    return s >>> 0
}
Ke.sum64_hi = _E
function wE(t, e, r, n) {
    var i = e + n
    return i >>> 0
}
Ke.sum64_lo = wE
function EE(t, e, r, n, i, s, o, a) {
    var l = 0,
        c = e
    ;(c = (c + n) >>> 0), (l += c < e ? 1 : 0), (c = (c + s) >>> 0), (l += c < s ? 1 : 0), (c = (c + a) >>> 0), (l += c < a ? 1 : 0)
    var f = t + r + i + o + l
    return f >>> 0
}
Ke.sum64_4_hi = EE
function SE(t, e, r, n, i, s, o, a) {
    var l = e + n + s + a
    return l >>> 0
}
Ke.sum64_4_lo = SE
function AE(t, e, r, n, i, s, o, a, l, c) {
    var f = 0,
        u = e
    ;(u = (u + n) >>> 0),
        (f += u < e ? 1 : 0),
        (u = (u + s) >>> 0),
        (f += u < s ? 1 : 0),
        (u = (u + a) >>> 0),
        (f += u < a ? 1 : 0),
        (u = (u + c) >>> 0),
        (f += u < c ? 1 : 0)
    var p = t + r + i + o + l + f
    return p >>> 0
}
Ke.sum64_5_hi = AE
function TE(t, e, r, n, i, s, o, a, l, c) {
    var f = e + n + s + a + c
    return f >>> 0
}
Ke.sum64_5_lo = TE
function CE(t, e, r) {
    var n = (e << (32 - r)) | (t >>> r)
    return n >>> 0
}
Ke.rotr64_hi = CE
function kE(t, e, r) {
    var n = (t << (32 - r)) | (e >>> r)
    return n >>> 0
}
Ke.rotr64_lo = kE
function NE(t, e, r) {
    return t >>> r
}
Ke.shr64_hi = NE
function PE(t, e, r) {
    var n = (t << (32 - r)) | (e >>> r)
    return n >>> 0
}
Ke.shr64_lo = PE
var qo = {},
    kp = Ke,
    IE = cl
function Yc() {
    ;(this.pending = null),
        (this.pendingTotal = 0),
        (this.blockSize = this.constructor.blockSize),
        (this.outSize = this.constructor.outSize),
        (this.hmacStrength = this.constructor.hmacStrength),
        (this.padLength = this.constructor.padLength / 8),
        (this.endian = "big"),
        (this._delta8 = this.blockSize / 8),
        (this._delta32 = this.blockSize / 32)
}
qo.BlockHash = Yc
Yc.prototype.update = function (e, r) {
    if (
        ((e = kp.toArray(e, r)),
        this.pending ? (this.pending = this.pending.concat(e)) : (this.pending = e),
        (this.pendingTotal += e.length),
        this.pending.length >= this._delta8)
    ) {
        e = this.pending
        var n = e.length % this._delta8
        ;(this.pending = e.slice(e.length - n, e.length)),
            this.pending.length === 0 && (this.pending = null),
            (e = kp.join32(e, 0, e.length - n, this.endian))
        for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
    }
    return this
}
Yc.prototype.digest = function (e) {
    return this.update(this._pad()), IE(this.pending === null), this._digest(e)
}
Yc.prototype._pad = function () {
    var e = this.pendingTotal,
        r = this._delta8,
        n = r - ((e + this.padLength) % r),
        i = new Array(n + this.padLength)
    i[0] = 128
    for (var s = 1; s < n; s++) i[s] = 0
    if (((e <<= 3), this.endian === "big")) {
        for (var o = 8; o < this.padLength; o++) i[s++] = 0
        ;(i[s++] = 0),
            (i[s++] = 0),
            (i[s++] = 0),
            (i[s++] = 0),
            (i[s++] = (e >>> 24) & 255),
            (i[s++] = (e >>> 16) & 255),
            (i[s++] = (e >>> 8) & 255),
            (i[s++] = e & 255)
    } else
        for (
            i[s++] = e & 255,
                i[s++] = (e >>> 8) & 255,
                i[s++] = (e >>> 16) & 255,
                i[s++] = (e >>> 24) & 255,
                i[s++] = 0,
                i[s++] = 0,
                i[s++] = 0,
                i[s++] = 0,
                o = 8;
            o < this.padLength;
            o++
        )
            i[s++] = 0
    return i
}
var jo = {},
    jn = {},
    $E = Ke,
    $n = $E.rotr32
function BE(t, e, r, n) {
    if (t === 0) return I1(e, r, n)
    if (t === 1 || t === 3) return B1(e, r, n)
    if (t === 2) return $1(e, r, n)
}
jn.ft_1 = BE
function I1(t, e, r) {
    return (t & e) ^ (~t & r)
}
jn.ch32 = I1
function $1(t, e, r) {
    return (t & e) ^ (t & r) ^ (e & r)
}
jn.maj32 = $1
function B1(t, e, r) {
    return t ^ e ^ r
}
jn.p32 = B1
function OE(t) {
    return $n(t, 2) ^ $n(t, 13) ^ $n(t, 22)
}
jn.s0_256 = OE
function ME(t) {
    return $n(t, 6) ^ $n(t, 11) ^ $n(t, 25)
}
jn.s1_256 = ME
function RE(t) {
    return $n(t, 7) ^ $n(t, 18) ^ (t >>> 3)
}
jn.g0_256 = RE
function LE(t) {
    return $n(t, 17) ^ $n(t, 19) ^ (t >>> 10)
}
jn.g1_256 = LE
var Co = Ke,
    DE = qo,
    FE = jn,
    iu = Co.rotl32,
    ra = Co.sum32,
    VE = Co.sum32_5,
    UE = FE.ft_1,
    O1 = DE.BlockHash,
    HE = [1518500249, 1859775393, 2400959708, 3395469782]
function Fn() {
    if (!(this instanceof Fn)) return new Fn()
    O1.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.W = new Array(80))
}
Co.inherits(Fn, O1)
var qE = Fn
Fn.blockSize = 512
Fn.outSize = 160
Fn.hmacStrength = 80
Fn.padLength = 64
Fn.prototype._update = function (e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i]
    for (; i < n.length; i++) n[i] = iu(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1)
    var s = this.h[0],
        o = this.h[1],
        a = this.h[2],
        l = this.h[3],
        c = this.h[4]
    for (i = 0; i < n.length; i++) {
        var f = ~~(i / 20),
            u = VE(iu(s, 5), UE(f, o, a, l), c, n[i], HE[f])
        ;(c = l), (l = a), (a = iu(o, 30)), (o = s), (s = u)
    }
    ;(this.h[0] = ra(this.h[0], s)),
        (this.h[1] = ra(this.h[1], o)),
        (this.h[2] = ra(this.h[2], a)),
        (this.h[3] = ra(this.h[3], l)),
        (this.h[4] = ra(this.h[4], c))
}
Fn.prototype._digest = function (e) {
    return e === "hex" ? Co.toHex32(this.h, "big") : Co.split32(this.h, "big")
}
var ko = Ke,
    jE = qo,
    zo = jn,
    zE = cl,
    Qr = ko.sum32,
    KE = ko.sum32_4,
    GE = ko.sum32_5,
    WE = zo.ch32,
    JE = zo.maj32,
    XE = zo.s0_256,
    YE = zo.s1_256,
    ZE = zo.g0_256,
    QE = zo.g1_256,
    M1 = jE.BlockHash,
    e4 = [
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278,
        1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122,
        1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205,
        773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
    ]
function Vn() {
    if (!(this instanceof Vn)) return new Vn()
    M1.call(this),
        (this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
        (this.k = e4),
        (this.W = new Array(64))
}
ko.inherits(Vn, M1)
var R1 = Vn
Vn.blockSize = 512
Vn.outSize = 256
Vn.hmacStrength = 192
Vn.padLength = 64
Vn.prototype._update = function (e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i]
    for (; i < n.length; i++) n[i] = KE(QE(n[i - 2]), n[i - 7], ZE(n[i - 15]), n[i - 16])
    var s = this.h[0],
        o = this.h[1],
        a = this.h[2],
        l = this.h[3],
        c = this.h[4],
        f = this.h[5],
        u = this.h[6],
        p = this.h[7]
    for (zE(this.k.length === n.length), i = 0; i < n.length; i++) {
        var m = GE(p, YE(c), WE(c, f, u), this.k[i], n[i]),
            y = Qr(XE(s), JE(s, o, a))
        ;(p = u), (u = f), (f = c), (c = Qr(l, m)), (l = a), (a = o), (o = s), (s = Qr(m, y))
    }
    ;(this.h[0] = Qr(this.h[0], s)),
        (this.h[1] = Qr(this.h[1], o)),
        (this.h[2] = Qr(this.h[2], a)),
        (this.h[3] = Qr(this.h[3], l)),
        (this.h[4] = Qr(this.h[4], c)),
        (this.h[5] = Qr(this.h[5], f)),
        (this.h[6] = Qr(this.h[6], u)),
        (this.h[7] = Qr(this.h[7], p))
}
Vn.prototype._digest = function (e) {
    return e === "hex" ? ko.toHex32(this.h, "big") : ko.split32(this.h, "big")
}
var ld = Ke,
    L1 = R1
function si() {
    if (!(this instanceof si)) return new si()
    L1.call(this), (this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
}
ld.inherits(si, L1)
var t4 = si
si.blockSize = 512
si.outSize = 224
si.hmacStrength = 192
si.padLength = 64
si.prototype._digest = function (e) {
    return e === "hex" ? ld.toHex32(this.h.slice(0, 7), "big") : ld.split32(this.h.slice(0, 7), "big")
}
var Cr = Ke,
    r4 = qo,
    n4 = cl,
    Bn = Cr.rotr64_hi,
    On = Cr.rotr64_lo,
    D1 = Cr.shr64_hi,
    F1 = Cr.shr64_lo,
    Si = Cr.sum64,
    su = Cr.sum64_hi,
    ou = Cr.sum64_lo,
    i4 = Cr.sum64_4_hi,
    s4 = Cr.sum64_4_lo,
    o4 = Cr.sum64_5_hi,
    a4 = Cr.sum64_5_lo,
    V1 = r4.BlockHash,
    l4 = [
        1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993,
        3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764,
        1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401,
        2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235,
        1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671,
        3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
        773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350,
        1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008,
        3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616,
        1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995,
        1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474,
        593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
        3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269,
        320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158,
        1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
    ]
function an() {
    if (!(this instanceof an)) return new an()
    V1.call(this),
        (this.h = [
            1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924,
            725511199, 528734635, 4215389547, 1541459225, 327033209,
        ]),
        (this.k = l4),
        (this.W = new Array(160))
}
Cr.inherits(an, V1)
var U1 = an
an.blockSize = 1024
an.outSize = 512
an.hmacStrength = 192
an.padLength = 128
an.prototype._prepareBlock = function (e, r) {
    for (var n = this.W, i = 0; i < 32; i++) n[i] = e[r + i]
    for (; i < n.length; i += 2) {
        var s = v4(n[i - 4], n[i - 3]),
            o = y4(n[i - 4], n[i - 3]),
            a = n[i - 14],
            l = n[i - 13],
            c = b4(n[i - 30], n[i - 29]),
            f = x4(n[i - 30], n[i - 29]),
            u = n[i - 32],
            p = n[i - 31]
        ;(n[i] = i4(s, o, a, l, c, f, u, p)), (n[i + 1] = s4(s, o, a, l, c, f, u, p))
    }
}
an.prototype._update = function (e, r) {
    this._prepareBlock(e, r)
    var n = this.W,
        i = this.h[0],
        s = this.h[1],
        o = this.h[2],
        a = this.h[3],
        l = this.h[4],
        c = this.h[5],
        f = this.h[6],
        u = this.h[7],
        p = this.h[8],
        m = this.h[9],
        y = this.h[10],
        v = this.h[11],
        _ = this.h[12],
        C = this.h[13],
        B = this.h[14],
        R = this.h[15]
    n4(this.k.length === n.length)
    for (var U = 0; U < n.length; U += 2) {
        var D = B,
            Y = R,
            J = g4(p, m),
            te = m4(p, m),
            G = c4(p, m, y, v, _),
            de = f4(p, m, y, v, _, C),
            k = this.k[U],
            d = this.k[U + 1],
            b = n[U],
            w = n[U + 1],
            E = o4(D, Y, J, te, G, de, k, d, b, w),
            T = a4(D, Y, J, te, G, de, k, d, b, w)
        ;(D = h4(i, s)), (Y = p4(i, s)), (J = u4(i, s, o, a, l)), (te = d4(i, s, o, a, l, c))
        var A = su(D, Y, J, te),
            $ = ou(D, Y, J, te)
        ;(B = _),
            (R = C),
            (_ = y),
            (C = v),
            (y = p),
            (v = m),
            (p = su(f, u, E, T)),
            (m = ou(u, u, E, T)),
            (f = l),
            (u = c),
            (l = o),
            (c = a),
            (o = i),
            (a = s),
            (i = su(E, T, A, $)),
            (s = ou(E, T, A, $))
    }
    Si(this.h, 0, i, s),
        Si(this.h, 2, o, a),
        Si(this.h, 4, l, c),
        Si(this.h, 6, f, u),
        Si(this.h, 8, p, m),
        Si(this.h, 10, y, v),
        Si(this.h, 12, _, C),
        Si(this.h, 14, B, R)
}
an.prototype._digest = function (e) {
    return e === "hex" ? Cr.toHex32(this.h, "big") : Cr.split32(this.h, "big")
}
function c4(t, e, r, n, i) {
    var s = (t & r) ^ (~t & i)
    return s < 0 && (s += 4294967296), s
}
function f4(t, e, r, n, i, s) {
    var o = (e & n) ^ (~e & s)
    return o < 0 && (o += 4294967296), o
}
function u4(t, e, r, n, i) {
    var s = (t & r) ^ (t & i) ^ (r & i)
    return s < 0 && (s += 4294967296), s
}
function d4(t, e, r, n, i, s) {
    var o = (e & n) ^ (e & s) ^ (n & s)
    return o < 0 && (o += 4294967296), o
}
function h4(t, e) {
    var r = Bn(t, e, 28),
        n = Bn(e, t, 2),
        i = Bn(e, t, 7),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function p4(t, e) {
    var r = On(t, e, 28),
        n = On(e, t, 2),
        i = On(e, t, 7),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function g4(t, e) {
    var r = Bn(t, e, 14),
        n = Bn(t, e, 18),
        i = Bn(e, t, 9),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function m4(t, e) {
    var r = On(t, e, 14),
        n = On(t, e, 18),
        i = On(e, t, 9),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function b4(t, e) {
    var r = Bn(t, e, 1),
        n = Bn(t, e, 8),
        i = D1(t, e, 7),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function x4(t, e) {
    var r = On(t, e, 1),
        n = On(t, e, 8),
        i = F1(t, e, 7),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function v4(t, e) {
    var r = Bn(t, e, 19),
        n = Bn(e, t, 29),
        i = D1(t, e, 6),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function y4(t, e) {
    var r = On(t, e, 19),
        n = On(e, t, 29),
        i = F1(t, e, 6),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
var cd = Ke,
    H1 = U1
function oi() {
    if (!(this instanceof oi)) return new oi()
    H1.call(this),
        (this.h = [
            3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231,
            1750603025, 3675008525, 1694076839, 1203062813, 3204075428,
        ])
}
cd.inherits(oi, H1)
var _4 = oi
oi.blockSize = 1024
oi.outSize = 384
oi.hmacStrength = 192
oi.padLength = 128
oi.prototype._digest = function (e) {
    return e === "hex" ? cd.toHex32(this.h.slice(0, 12), "big") : cd.split32(this.h.slice(0, 12), "big")
}
jo.sha1 = qE
jo.sha224 = t4
jo.sha256 = R1
jo.sha384 = _4
jo.sha512 = U1
var q1 = {},
    Rs = Ke,
    w4 = qo,
    $l = Rs.rotl32,
    Np = Rs.sum32,
    na = Rs.sum32_3,
    Pp = Rs.sum32_4,
    j1 = w4.BlockHash
function Un() {
    if (!(this instanceof Un)) return new Un()
    j1.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.endian = "little")
}
Rs.inherits(Un, j1)
q1.ripemd160 = Un
Un.blockSize = 512
Un.outSize = 160
Un.hmacStrength = 192
Un.padLength = 64
Un.prototype._update = function (e, r) {
    for (var n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], l = n, c = i, f = s, u = o, p = a, m = 0; m < 80; m++) {
        var y = Np($l(Pp(n, Ip(m, i, s, o), e[A4[m] + r], E4(m)), C4[m]), a)
        ;(n = a),
            (a = o),
            (o = $l(s, 10)),
            (s = i),
            (i = y),
            (y = Np($l(Pp(l, Ip(79 - m, c, f, u), e[T4[m] + r], S4(m)), k4[m]), p)),
            (l = p),
            (p = u),
            (u = $l(f, 10)),
            (f = c),
            (c = y)
    }
    ;(y = na(this.h[1], s, u)),
        (this.h[1] = na(this.h[2], o, p)),
        (this.h[2] = na(this.h[3], a, l)),
        (this.h[3] = na(this.h[4], n, c)),
        (this.h[4] = na(this.h[0], i, f)),
        (this.h[0] = y)
}
Un.prototype._digest = function (e) {
    return e === "hex" ? Rs.toHex32(this.h, "little") : Rs.split32(this.h, "little")
}
function Ip(t, e, r, n) {
    return t <= 15 ? e ^ r ^ n : t <= 31 ? (e & r) | (~e & n) : t <= 47 ? (e | ~r) ^ n : t <= 63 ? (e & n) | (r & ~n) : e ^ (r | ~n)
}
function E4(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838
}
function S4(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0
}
var A4 = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2,
        7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
    ],
    T4 = [
        5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11,
        8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
    ],
    C4 = [
        11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13,
        15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8,
        5, 6,
    ],
    k4 = [
        8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6,
        14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13,
        11, 11,
    ],
    N4 = Ke,
    P4 = cl
function No(t, e, r) {
    if (!(this instanceof No)) return new No(t, e, r)
    ;(this.Hash = t),
        (this.blockSize = t.blockSize / 8),
        (this.outSize = t.outSize / 8),
        (this.inner = null),
        (this.outer = null),
        this._init(N4.toArray(e, r))
}
var I4 = No
No.prototype._init = function (e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), P4(e.length <= this.blockSize)
    for (var r = e.length; r < this.blockSize; r++) e.push(0)
    for (r = 0; r < e.length; r++) e[r] ^= 54
    for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++) e[r] ^= 106
    this.outer = new this.Hash().update(e)
}
No.prototype.update = function (e, r) {
    return this.inner.update(e, r), this
}
No.prototype.digest = function (e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e)
}
;(function (t) {
    var e = t
    ;(e.utils = Ke),
        (e.common = qo),
        (e.sha = jo),
        (e.ripemd = q1),
        (e.hmac = I4),
        (e.sha1 = e.sha.sha1),
        (e.sha256 = e.sha.sha256),
        (e.sha224 = e.sha.sha224),
        (e.sha384 = e.sha.sha384),
        (e.sha512 = e.sha.sha512),
        (e.ripemd160 = e.ripemd.ripemd160)
})(hr)
function Ko(t, e, r) {
    return (
        (r = {
            path: e,
            exports: {},
            require: function (n, i) {
                return $4(n, i == null ? r.path : i)
            },
        }),
        t(r, r.exports),
        r.exports
    )
}
function $4() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}
var C0 = z1
function z1(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
z1.equal = function (e, r, n) {
    if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r)
}
var sn = Ko(function (t, e) {
        var r = e
        function n(o, a) {
            if (Array.isArray(o)) return o.slice()
            if (!o) return []
            var l = []
            if (typeof o != "string") {
                for (var c = 0; c < o.length; c++) l[c] = o[c] | 0
                return l
            }
            if (a === "hex") {
                ;(o = o.replace(/[^a-z0-9]+/gi, "")), o.length % 2 !== 0 && (o = "0" + o)
                for (var c = 0; c < o.length; c += 2) l.push(parseInt(o[c] + o[c + 1], 16))
            } else
                for (var c = 0; c < o.length; c++) {
                    var f = o.charCodeAt(c),
                        u = f >> 8,
                        p = f & 255
                    u ? l.push(u, p) : l.push(p)
                }
            return l
        }
        r.toArray = n
        function i(o) {
            return o.length === 1 ? "0" + o : o
        }
        r.zero2 = i
        function s(o) {
            for (var a = "", l = 0; l < o.length; l++) a += i(o[l].toString(16))
            return a
        }
        ;(r.toHex = s),
            (r.encode = function (a, l) {
                return l === "hex" ? s(a) : a
            })
    }),
    Dr = Ko(function (t, e) {
        var r = e
        ;(r.assert = C0), (r.toArray = sn.toArray), (r.zero2 = sn.zero2), (r.toHex = sn.toHex), (r.encode = sn.encode)
        function n(l, c, f) {
            var u = new Array(Math.max(l.bitLength(), f) + 1)
            u.fill(0)
            for (var p = 1 << (c + 1), m = l.clone(), y = 0; y < u.length; y++) {
                var v,
                    _ = m.andln(p - 1)
                m.isOdd() ? (_ > (p >> 1) - 1 ? (v = (p >> 1) - _) : (v = _), m.isubn(v)) : (v = 0), (u[y] = v), m.iushrn(1)
            }
            return u
        }
        r.getNAF = n
        function i(l, c) {
            var f = [[], []]
            ;(l = l.clone()), (c = c.clone())
            for (var u = 0, p = 0, m; l.cmpn(-u) > 0 || c.cmpn(-p) > 0; ) {
                var y = (l.andln(3) + u) & 3,
                    v = (c.andln(3) + p) & 3
                y === 3 && (y = -1), v === 3 && (v = -1)
                var _
                ;(y & 1) === 0 ? (_ = 0) : ((m = (l.andln(7) + u) & 7), (m === 3 || m === 5) && v === 2 ? (_ = -y) : (_ = y)), f[0].push(_)
                var C
                ;(v & 1) === 0 ? (C = 0) : ((m = (c.andln(7) + p) & 7), (m === 3 || m === 5) && y === 2 ? (C = -v) : (C = v)),
                    f[1].push(C),
                    2 * u === _ + 1 && (u = 1 - u),
                    2 * p === C + 1 && (p = 1 - p),
                    l.iushrn(1),
                    c.iushrn(1)
            }
            return f
        }
        r.getJSF = i
        function s(l, c, f) {
            var u = "_" + c
            l.prototype[c] = function () {
                return this[u] !== void 0 ? this[u] : (this[u] = f.call(this))
            }
        }
        r.cachedProperty = s
        function o(l) {
            return typeof l == "string" ? r.toArray(l, "hex") : l
        }
        r.parseBytes = o
        function a(l) {
            return new Oe(l, "hex", "le")
        }
        r.intFromLE = a
    }),
    Ec = Dr.getNAF,
    B4 = Dr.getJSF,
    Sc = Dr.assert
function Yi(t, e) {
    ;(this.type = t),
        (this.p = new Oe(e.p, 16)),
        (this.red = e.prime ? Oe.red(e.prime) : Oe.mont(this.p)),
        (this.zero = new Oe(0).toRed(this.red)),
        (this.one = new Oe(1).toRed(this.red)),
        (this.two = new Oe(2).toRed(this.red)),
        (this.n = e.n && new Oe(e.n, 16)),
        (this.g = e.g && this.pointFromJSON(e.g, e.gRed)),
        (this._wnafT1 = new Array(4)),
        (this._wnafT2 = new Array(4)),
        (this._wnafT3 = new Array(4)),
        (this._wnafT4 = new Array(4)),
        (this._bitLength = this.n ? this.n.bitLength() : 0)
    var r = this.n && this.p.div(this.n)
    !r || r.cmpn(100) > 0 ? (this.redN = null) : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)))
}
var qs = Yi
Yi.prototype.point = function () {
    throw new Error("Not implemented")
}
Yi.prototype.validate = function () {
    throw new Error("Not implemented")
}
Yi.prototype._fixedNafMul = function (e, r) {
    Sc(e.precomputed)
    var n = e._getDoubles(),
        i = Ec(r, 1, this._bitLength),
        s = (1 << (n.step + 1)) - (n.step % 2 === 0 ? 2 : 1)
    s /= 3
    var o = [],
        a,
        l
    for (a = 0; a < i.length; a += n.step) {
        l = 0
        for (var c = a + n.step - 1; c >= a; c--) l = (l << 1) + i[c]
        o.push(l)
    }
    for (var f = this.jpoint(null, null, null), u = this.jpoint(null, null, null), p = s; p > 0; p--) {
        for (a = 0; a < o.length; a++) (l = o[a]), l === p ? (u = u.mixedAdd(n.points[a])) : l === -p && (u = u.mixedAdd(n.points[a].neg()))
        f = f.add(u)
    }
    return f.toP()
}
Yi.prototype._wnafMul = function (e, r) {
    var n = 4,
        i = e._getNAFPoints(n)
    n = i.wnd
    for (var s = i.points, o = Ec(r, n, this._bitLength), a = this.jpoint(null, null, null), l = o.length - 1; l >= 0; l--) {
        for (var c = 0; l >= 0 && o[l] === 0; l--) c++
        if ((l >= 0 && c++, (a = a.dblp(c)), l < 0)) break
        var f = o[l]
        Sc(f !== 0),
            e.type === "affine"
                ? f > 0
                    ? (a = a.mixedAdd(s[(f - 1) >> 1]))
                    : (a = a.mixedAdd(s[(-f - 1) >> 1].neg()))
                : f > 0
                ? (a = a.add(s[(f - 1) >> 1]))
                : (a = a.add(s[(-f - 1) >> 1].neg()))
    }
    return e.type === "affine" ? a.toP() : a
}
Yi.prototype._wnafMulAdd = function (e, r, n, i, s) {
    var o = this._wnafT1,
        a = this._wnafT2,
        l = this._wnafT3,
        c = 0,
        f,
        u,
        p
    for (f = 0; f < i; f++) {
        p = r[f]
        var m = p._getNAFPoints(e)
        ;(o[f] = m.wnd), (a[f] = m.points)
    }
    for (f = i - 1; f >= 1; f -= 2) {
        var y = f - 1,
            v = f
        if (o[y] !== 1 || o[v] !== 1) {
            ;(l[y] = Ec(n[y], o[y], this._bitLength)),
                (l[v] = Ec(n[v], o[v], this._bitLength)),
                (c = Math.max(l[y].length, c)),
                (c = Math.max(l[v].length, c))
            continue
        }
        var _ = [r[y], null, null, r[v]]
        r[y].y.cmp(r[v].y) === 0
            ? ((_[1] = r[y].add(r[v])), (_[2] = r[y].toJ().mixedAdd(r[v].neg())))
            : r[y].y.cmp(r[v].y.redNeg()) === 0
            ? ((_[1] = r[y].toJ().mixedAdd(r[v])), (_[2] = r[y].add(r[v].neg())))
            : ((_[1] = r[y].toJ().mixedAdd(r[v])), (_[2] = r[y].toJ().mixedAdd(r[v].neg())))
        var C = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            B = B4(n[y], n[v])
        for (c = Math.max(B[0].length, c), l[y] = new Array(c), l[v] = new Array(c), u = 0; u < c; u++) {
            var R = B[0][u] | 0,
                U = B[1][u] | 0
            ;(l[y][u] = C[(R + 1) * 3 + (U + 1)]), (l[v][u] = 0), (a[y] = _)
        }
    }
    var D = this.jpoint(null, null, null),
        Y = this._wnafT4
    for (f = c; f >= 0; f--) {
        for (var J = 0; f >= 0; ) {
            var te = !0
            for (u = 0; u < i; u++) (Y[u] = l[u][f] | 0), Y[u] !== 0 && (te = !1)
            if (!te) break
            J++, f--
        }
        if ((f >= 0 && J++, (D = D.dblp(J)), f < 0)) break
        for (u = 0; u < i; u++) {
            var G = Y[u]
            G !== 0 &&
                (G > 0 ? (p = a[u][(G - 1) >> 1]) : G < 0 && (p = a[u][(-G - 1) >> 1].neg()),
                p.type === "affine" ? (D = D.mixedAdd(p)) : (D = D.add(p)))
        }
    }
    for (f = 0; f < i; f++) a[f] = null
    return s ? D : D.toP()
}
function Wr(t, e) {
    ;(this.curve = t), (this.type = e), (this.precomputed = null)
}
Yi.BasePoint = Wr
Wr.prototype.eq = function () {
    throw new Error("Not implemented")
}
Wr.prototype.validate = function () {
    return this.curve.validate(this)
}
Yi.prototype.decodePoint = function (e, r) {
    e = Dr.toArray(e, r)
    var n = this.p.byteLength()
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
        e[0] === 6 ? Sc(e[e.length - 1] % 2 === 0) : e[0] === 7 && Sc(e[e.length - 1] % 2 === 1)
        var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n))
        return i
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n) return this.pointFromX(e.slice(1, 1 + n), e[0] === 3)
    throw new Error("Unknown point format")
}
Wr.prototype.encodeCompressed = function (e) {
    return this.encode(e, !0)
}
Wr.prototype._encode = function (e) {
    var r = this.curve.p.byteLength(),
        n = this.getX().toArray("be", r)
    return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r))
}
Wr.prototype.encode = function (e, r) {
    return Dr.encode(this._encode(r), e)
}
Wr.prototype.precompute = function (e) {
    if (this.precomputed) return this
    var r = { doubles: null, naf: null, beta: null }
    return (r.naf = this._getNAFPoints(8)), (r.doubles = this._getDoubles(4, e)), (r.beta = this._getBeta()), (this.precomputed = r), this
}
Wr.prototype._hasDoubles = function (e) {
    if (!this.precomputed) return !1
    var r = this.precomputed.doubles
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1
}
Wr.prototype._getDoubles = function (e, r) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles
    for (var n = [this], i = this, s = 0; s < r; s += e) {
        for (var o = 0; o < e; o++) i = i.dbl()
        n.push(i)
    }
    return { step: e, points: n }
}
Wr.prototype._getNAFPoints = function (e) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf
    for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++) r[s] = r[s - 1].add(i)
    return { wnd: e, points: r }
}
Wr.prototype._getBeta = function () {
    return null
}
Wr.prototype.dblp = function (e) {
    for (var r = this, n = 0; n < e; n++) r = r.dbl()
    return r
}
var k0 = Ko(function (t) {
        typeof Object.create == "function"
            ? (t.exports = function (r, n) {
                  n &&
                      ((r.super_ = n),
                      (r.prototype = Object.create(n.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } })))
              })
            : (t.exports = function (r, n) {
                  if (n) {
                      r.super_ = n
                      var i = function () {}
                      ;(i.prototype = n.prototype), (r.prototype = new i()), (r.prototype.constructor = r)
                  }
              })
    }),
    O4 = Dr.assert
function Jr(t) {
    qs.call(this, "short", t),
        (this.a = new Oe(t.a, 16).toRed(this.red)),
        (this.b = new Oe(t.b, 16).toRed(this.red)),
        (this.tinv = this.two.redInvm()),
        (this.zeroA = this.a.fromRed().cmpn(0) === 0),
        (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
        (this.endo = this._getEndomorphism(t)),
        (this._endoWnafT1 = new Array(4)),
        (this._endoWnafT2 = new Array(4))
}
k0(Jr, qs)
var M4 = Jr
Jr.prototype._getEndomorphism = function (e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, n
        if (e.beta) r = new Oe(e.beta, 16).toRed(this.red)
        else {
            var i = this._getEndoRoots(this.p)
            ;(r = i[0].cmp(i[1]) < 0 ? i[0] : i[1]), (r = r.toRed(this.red))
        }
        if (e.lambda) n = new Oe(e.lambda, 16)
        else {
            var s = this._getEndoRoots(this.n)
            this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? (n = s[0]) : ((n = s[1]), O4(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0))
        }
        var o
        return (
            e.basis
                ? (o = e.basis.map(function (a) {
                      return { a: new Oe(a.a, 16), b: new Oe(a.b, 16) }
                  }))
                : (o = this._getEndoBasis(n)),
            { beta: r, lambda: n, basis: o }
        )
    }
}
Jr.prototype._getEndoRoots = function (e) {
    var r = e === this.p ? this.red : Oe.mont(e),
        n = new Oe(2).toRed(r).redInvm(),
        i = n.redNeg(),
        s = new Oe(3).toRed(r).redNeg().redSqrt().redMul(n),
        o = i.redAdd(s).fromRed(),
        a = i.redSub(s).fromRed()
    return [o, a]
}
Jr.prototype._getEndoBasis = function (e) {
    for (
        var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
            n = e,
            i = this.n.clone(),
            s = new Oe(1),
            o = new Oe(0),
            a = new Oe(0),
            l = new Oe(1),
            c,
            f,
            u,
            p,
            m,
            y,
            v,
            _ = 0,
            C,
            B;
        n.cmpn(0) !== 0;

    ) {
        var R = i.div(n)
        ;(C = i.sub(R.mul(n))), (B = a.sub(R.mul(s)))
        var U = l.sub(R.mul(o))
        if (!u && C.cmp(r) < 0) (c = v.neg()), (f = s), (u = C.neg()), (p = B)
        else if (u && ++_ === 2) break
        ;(v = C), (i = n), (n = C), (a = s), (s = B), (l = o), (o = U)
    }
    ;(m = C.neg()), (y = B)
    var D = u.sqr().add(p.sqr()),
        Y = m.sqr().add(y.sqr())
    return (
        Y.cmp(D) >= 0 && ((m = c), (y = f)),
        u.negative && ((u = u.neg()), (p = p.neg())),
        m.negative && ((m = m.neg()), (y = y.neg())),
        [
            { a: u, b: p },
            { a: m, b: y },
        ]
    )
}
Jr.prototype._endoSplit = function (e) {
    var r = this.endo.basis,
        n = r[0],
        i = r[1],
        s = i.b.mul(e).divRound(this.n),
        o = n.b.neg().mul(e).divRound(this.n),
        a = s.mul(n.a),
        l = o.mul(i.a),
        c = s.mul(n.b),
        f = o.mul(i.b),
        u = e.sub(a).sub(l),
        p = c.add(f).neg()
    return { k1: u, k2: p }
}
Jr.prototype.pointFromX = function (e, r) {
    ;(e = new Oe(e, 16)), e.red || (e = e.toRed(this.red))
    var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
        i = n.redSqrt()
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0) throw new Error("invalid point")
    var s = i.fromRed().isOdd()
    return ((r && !s) || (!r && s)) && (i = i.redNeg()), this.point(e, i)
}
Jr.prototype.validate = function (e) {
    if (e.inf) return !0
    var r = e.x,
        n = e.y,
        i = this.a.redMul(r),
        s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b)
    return n.redSqr().redISub(s).cmpn(0) === 0
}
Jr.prototype._endoWnafMulAdd = function (e, r, n) {
    for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
        var a = this._endoSplit(r[o]),
            l = e[o],
            c = l._getBeta()
        a.k1.negative && (a.k1.ineg(), (l = l.neg(!0))),
            a.k2.negative && (a.k2.ineg(), (c = c.neg(!0))),
            (i[o * 2] = l),
            (i[o * 2 + 1] = c),
            (s[o * 2] = a.k1),
            (s[o * 2 + 1] = a.k2)
    }
    for (var f = this._wnafMulAdd(1, i, s, o * 2, n), u = 0; u < o * 2; u++) (i[u] = null), (s[u] = null)
    return f
}
function er(t, e, r, n) {
    qs.BasePoint.call(this, t, "affine"),
        e === null && r === null
            ? ((this.x = null), (this.y = null), (this.inf = !0))
            : ((this.x = new Oe(e, 16)),
              (this.y = new Oe(r, 16)),
              n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              (this.inf = !1))
}
k0(er, qs.BasePoint)
Jr.prototype.point = function (e, r, n) {
    return new er(this, e, r, n)
}
Jr.prototype.pointFromJSON = function (e, r) {
    return er.fromJSON(this, e, r)
}
er.prototype._getBeta = function () {
    if (!!this.curve.endo) {
        var e = this.precomputed
        if (e && e.beta) return e.beta
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y)
        if (e) {
            var n = this.curve,
                i = function (s) {
                    return n.point(s.x.redMul(n.endo.beta), s.y)
                }
            ;(e.beta = r),
                (r.precomputed = {
                    beta: null,
                    naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(i) },
                    doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(i) },
                })
        }
        return r
    }
}
er.prototype.toJSON = function () {
    return this.precomputed
        ? [
              this.x,
              this.y,
              this.precomputed && {
                  doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) },
                  naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) },
              },
          ]
        : [this.x, this.y]
}
er.fromJSON = function (e, r, n) {
    typeof r == "string" && (r = JSON.parse(r))
    var i = e.point(r[0], r[1], n)
    if (!r[2]) return i
    function s(a) {
        return e.point(a[0], a[1], n)
    }
    var o = r[2]
    return (
        (i.precomputed = {
            beta: null,
            doubles: o.doubles && { step: o.doubles.step, points: [i].concat(o.doubles.points.map(s)) },
            naf: o.naf && { wnd: o.naf.wnd, points: [i].concat(o.naf.points.map(s)) },
        }),
        i
    )
}
er.prototype.inspect = function () {
    return this.isInfinity()
        ? "<EC Point Infinity>"
        : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
}
er.prototype.isInfinity = function () {
    return this.inf
}
er.prototype.add = function (e) {
    if (this.inf) return e
    if (e.inf) return this
    if (this.eq(e)) return this.dbl()
    if (this.neg().eq(e)) return this.curve.point(null, null)
    if (this.x.cmp(e.x) === 0) return this.curve.point(null, null)
    var r = this.y.redSub(e.y)
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()))
    var n = r.redSqr().redISub(this.x).redISub(e.x),
        i = r.redMul(this.x.redSub(n)).redISub(this.y)
    return this.curve.point(n, i)
}
er.prototype.dbl = function () {
    if (this.inf) return this
    var e = this.y.redAdd(this.y)
    if (e.cmpn(0) === 0) return this.curve.point(null, null)
    var r = this.curve.a,
        n = this.x.redSqr(),
        i = e.redInvm(),
        s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i),
        o = s.redSqr().redISub(this.x.redAdd(this.x)),
        a = s.redMul(this.x.redSub(o)).redISub(this.y)
    return this.curve.point(o, a)
}
er.prototype.getX = function () {
    return this.x.fromRed()
}
er.prototype.getY = function () {
    return this.y.fromRed()
}
er.prototype.mul = function (e) {
    return (
        (e = new Oe(e, 16)),
        this.isInfinity()
            ? this
            : this._hasDoubles(e)
            ? this.curve._fixedNafMul(this, e)
            : this.curve.endo
            ? this.curve._endoWnafMulAdd([this], [e])
            : this.curve._wnafMul(this, e)
    )
}
er.prototype.mulAdd = function (e, r, n) {
    var i = [this, r],
        s = [e, n]
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2)
}
er.prototype.jmulAdd = function (e, r, n) {
    var i = [this, r],
        s = [e, n]
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0)
}
er.prototype.eq = function (e) {
    return this === e || (this.inf === e.inf && (this.inf || (this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)))
}
er.prototype.neg = function (e) {
    if (this.inf) return this
    var r = this.curve.point(this.x, this.y.redNeg())
    if (e && this.precomputed) {
        var n = this.precomputed,
            i = function (s) {
                return s.neg()
            }
        r.precomputed = {
            naf: n.naf && { wnd: n.naf.wnd, points: n.naf.points.map(i) },
            doubles: n.doubles && { step: n.doubles.step, points: n.doubles.points.map(i) },
        }
    }
    return r
}
er.prototype.toJ = function () {
    if (this.inf) return this.curve.jpoint(null, null, null)
    var e = this.curve.jpoint(this.x, this.y, this.curve.one)
    return e
}
function ar(t, e, r, n) {
    qs.BasePoint.call(this, t, "jacobian"),
        e === null && r === null && n === null
            ? ((this.x = this.curve.one), (this.y = this.curve.one), (this.z = new Oe(0)))
            : ((this.x = new Oe(e, 16)), (this.y = new Oe(r, 16)), (this.z = new Oe(n, 16))),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)),
        (this.zOne = this.z === this.curve.one)
}
k0(ar, qs.BasePoint)
Jr.prototype.jpoint = function (e, r, n) {
    return new ar(this, e, r, n)
}
ar.prototype.toP = function () {
    if (this.isInfinity()) return this.curve.point(null, null)
    var e = this.z.redInvm(),
        r = e.redSqr(),
        n = this.x.redMul(r),
        i = this.y.redMul(r).redMul(e)
    return this.curve.point(n, i)
}
ar.prototype.neg = function () {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
}
ar.prototype.add = function (e) {
    if (this.isInfinity()) return e
    if (e.isInfinity()) return this
    var r = e.z.redSqr(),
        n = this.z.redSqr(),
        i = this.x.redMul(r),
        s = e.x.redMul(n),
        o = this.y.redMul(r.redMul(e.z)),
        a = e.y.redMul(n.redMul(this.z)),
        l = i.redSub(s),
        c = o.redSub(a)
    if (l.cmpn(0) === 0) return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
    var f = l.redSqr(),
        u = f.redMul(l),
        p = i.redMul(f),
        m = c.redSqr().redIAdd(u).redISub(p).redISub(p),
        y = c.redMul(p.redISub(m)).redISub(o.redMul(u)),
        v = this.z.redMul(e.z).redMul(l)
    return this.curve.jpoint(m, y, v)
}
ar.prototype.mixedAdd = function (e) {
    if (this.isInfinity()) return e.toJ()
    if (e.isInfinity()) return this
    var r = this.z.redSqr(),
        n = this.x,
        i = e.x.redMul(r),
        s = this.y,
        o = e.y.redMul(r).redMul(this.z),
        a = n.redSub(i),
        l = s.redSub(o)
    if (a.cmpn(0) === 0) return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
    var c = a.redSqr(),
        f = c.redMul(a),
        u = n.redMul(c),
        p = l.redSqr().redIAdd(f).redISub(u).redISub(u),
        m = l.redMul(u.redISub(p)).redISub(s.redMul(f)),
        y = this.z.redMul(a)
    return this.curve.jpoint(p, m, y)
}
ar.prototype.dblp = function (e) {
    if (e === 0) return this
    if (this.isInfinity()) return this
    if (!e) return this.dbl()
    var r
    if (this.curve.zeroA || this.curve.threeA) {
        var n = this
        for (r = 0; r < e; r++) n = n.dbl()
        return n
    }
    var i = this.curve.a,
        s = this.curve.tinv,
        o = this.x,
        a = this.y,
        l = this.z,
        c = l.redSqr().redSqr(),
        f = a.redAdd(a)
    for (r = 0; r < e; r++) {
        var u = o.redSqr(),
            p = f.redSqr(),
            m = p.redSqr(),
            y = u.redAdd(u).redIAdd(u).redIAdd(i.redMul(c)),
            v = o.redMul(p),
            _ = y.redSqr().redISub(v.redAdd(v)),
            C = v.redISub(_),
            B = y.redMul(C)
        B = B.redIAdd(B).redISub(m)
        var R = f.redMul(l)
        r + 1 < e && (c = c.redMul(m)), (o = _), (l = R), (f = B)
    }
    return this.curve.jpoint(o, f.redMul(s), l)
}
ar.prototype.dbl = function () {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
}
ar.prototype._zeroDbl = function () {
    var e, r, n
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            a = this.x.redAdd(s).redSqr().redISub(i).redISub(o)
        a = a.redIAdd(a)
        var l = i.redAdd(i).redIAdd(i),
            c = l.redSqr().redISub(a).redISub(a),
            f = o.redIAdd(o)
        ;(f = f.redIAdd(f)), (f = f.redIAdd(f)), (e = c), (r = l.redMul(a.redISub(c)).redISub(f)), (n = this.y.redAdd(this.y))
    } else {
        var u = this.x.redSqr(),
            p = this.y.redSqr(),
            m = p.redSqr(),
            y = this.x.redAdd(p).redSqr().redISub(u).redISub(m)
        y = y.redIAdd(y)
        var v = u.redAdd(u).redIAdd(u),
            _ = v.redSqr(),
            C = m.redIAdd(m)
        ;(C = C.redIAdd(C)),
            (C = C.redIAdd(C)),
            (e = _.redISub(y).redISub(y)),
            (r = v.redMul(y.redISub(e)).redISub(C)),
            (n = this.y.redMul(this.z)),
            (n = n.redIAdd(n))
    }
    return this.curve.jpoint(e, r, n)
}
ar.prototype._threeDbl = function () {
    var e, r, n
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            a = this.x.redAdd(s).redSqr().redISub(i).redISub(o)
        a = a.redIAdd(a)
        var l = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
            c = l.redSqr().redISub(a).redISub(a)
        e = c
        var f = o.redIAdd(o)
        ;(f = f.redIAdd(f)), (f = f.redIAdd(f)), (r = l.redMul(a.redISub(c)).redISub(f)), (n = this.y.redAdd(this.y))
    } else {
        var u = this.z.redSqr(),
            p = this.y.redSqr(),
            m = this.x.redMul(p),
            y = this.x.redSub(u).redMul(this.x.redAdd(u))
        y = y.redAdd(y).redIAdd(y)
        var v = m.redIAdd(m)
        v = v.redIAdd(v)
        var _ = v.redAdd(v)
        ;(e = y.redSqr().redISub(_)), (n = this.y.redAdd(this.z).redSqr().redISub(p).redISub(u))
        var C = p.redSqr()
        ;(C = C.redIAdd(C)), (C = C.redIAdd(C)), (C = C.redIAdd(C)), (r = y.redMul(v.redISub(e)).redISub(C))
    }
    return this.curve.jpoint(e, r, n)
}
ar.prototype._dbl = function () {
    var e = this.curve.a,
        r = this.x,
        n = this.y,
        i = this.z,
        s = i.redSqr().redSqr(),
        o = r.redSqr(),
        a = n.redSqr(),
        l = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)),
        c = r.redAdd(r)
    c = c.redIAdd(c)
    var f = c.redMul(a),
        u = l.redSqr().redISub(f.redAdd(f)),
        p = f.redISub(u),
        m = a.redSqr()
    ;(m = m.redIAdd(m)), (m = m.redIAdd(m)), (m = m.redIAdd(m))
    var y = l.redMul(p).redISub(m),
        v = n.redAdd(n).redMul(i)
    return this.curve.jpoint(u, y, v)
}
ar.prototype.trpl = function () {
    if (!this.curve.zeroA) return this.dbl().add(this)
    var e = this.x.redSqr(),
        r = this.y.redSqr(),
        n = this.z.redSqr(),
        i = r.redSqr(),
        s = e.redAdd(e).redIAdd(e),
        o = s.redSqr(),
        a = this.x.redAdd(r).redSqr().redISub(e).redISub(i)
    ;(a = a.redIAdd(a)), (a = a.redAdd(a).redIAdd(a)), (a = a.redISub(o))
    var l = a.redSqr(),
        c = i.redIAdd(i)
    ;(c = c.redIAdd(c)), (c = c.redIAdd(c)), (c = c.redIAdd(c))
    var f = s.redIAdd(a).redSqr().redISub(o).redISub(l).redISub(c),
        u = r.redMul(f)
    ;(u = u.redIAdd(u)), (u = u.redIAdd(u))
    var p = this.x.redMul(l).redISub(u)
    ;(p = p.redIAdd(p)), (p = p.redIAdd(p))
    var m = this.y.redMul(f.redMul(c.redISub(f)).redISub(a.redMul(l)))
    ;(m = m.redIAdd(m)), (m = m.redIAdd(m)), (m = m.redIAdd(m))
    var y = this.z.redAdd(a).redSqr().redISub(n).redISub(l)
    return this.curve.jpoint(p, m, y)
}
ar.prototype.mul = function (e, r) {
    return (e = new Oe(e, r)), this.curve._wnafMul(this, e)
}
ar.prototype.eq = function (e) {
    if (e.type === "affine") return this.eq(e.toJ())
    if (this === e) return !0
    var r = this.z.redSqr(),
        n = e.z.redSqr()
    if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0) return !1
    var i = r.redMul(this.z),
        s = n.redMul(e.z)
    return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0
}
ar.prototype.eqXToP = function (e) {
    var r = this.z.redSqr(),
        n = e.toRed(this.curve.red).redMul(r)
    if (this.x.cmp(n) === 0) return !0
    for (var i = e.clone(), s = this.curve.redN.redMul(r); ; ) {
        if ((i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)) return !1
        if ((n.redIAdd(s), this.x.cmp(n) === 0)) return !0
    }
}
ar.prototype.inspect = function () {
    return this.isInfinity()
        ? "<EC JPoint Infinity>"
        : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
}
ar.prototype.isInfinity = function () {
    return this.z.cmpn(0) === 0
}
var ec = Ko(function (t, e) {
        var r = e
        ;(r.base = qs), (r.short = M4), (r.mont = null), (r.edwards = null)
    }),
    tc = Ko(function (t, e) {
        var r = e,
            n = Dr.assert
        function i(a) {
            a.type === "short"
                ? (this.curve = new ec.short(a))
                : a.type === "edwards"
                ? (this.curve = new ec.edwards(a))
                : (this.curve = new ec.mont(a)),
                (this.g = this.curve.g),
                (this.n = this.curve.n),
                (this.hash = a.hash),
                n(this.g.validate(), "Invalid curve"),
                n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        r.PresetCurve = i
        function s(a, l) {
            Object.defineProperty(r, a, {
                configurable: !0,
                enumerable: !0,
                get: function () {
                    var c = new i(l)
                    return Object.defineProperty(r, a, { configurable: !0, enumerable: !0, value: c }), c
                },
            })
        }
        s("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: hr.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"],
        }),
            s("p224", {
                type: "short",
                prime: "p224",
                p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
                a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
                b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
                n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
                hash: hr.sha256,
                gRed: !1,
                g: [
                    "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
                    "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34",
                ],
            }),
            s("p256", {
                type: "short",
                prime: null,
                p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
                a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
                b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
                n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
                hash: hr.sha256,
                gRed: !1,
                g: [
                    "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
                    "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5",
                ],
            }),
            s("p384", {
                type: "short",
                prime: null,
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                hash: hr.sha384,
                gRed: !1,
                g: [
                    "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
                    "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f",
                ],
            }),
            s("p521", {
                type: "short",
                prime: null,
                p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                hash: hr.sha512,
                gRed: !1,
                g: [
                    "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
                    "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650",
                ],
            }),
            s("curve25519", {
                type: "mont",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "76d06",
                b: "1",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: hr.sha256,
                gRed: !1,
                g: ["9"],
            }),
            s("ed25519", {
                type: "edwards",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "-1",
                c: "1",
                d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: hr.sha256,
                gRed: !1,
                g: [
                    "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
                    "6666666666666666666666666666666666666666666666666666666666666658",
                ],
            })
        var o
        try {
            o = null.crash()
        } catch {
            o = void 0
        }
        s("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: hr.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [
                { a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" },
                { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" },
            ],
            gRed: !1,
            g: [
                "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                o,
            ],
        })
    })
function ji(t) {
    if (!(this instanceof ji)) return new ji(t)
    ;(this.hash = t.hash),
        (this.predResist = !!t.predResist),
        (this.outLen = this.hash.outSize),
        (this.minEntropy = t.minEntropy || this.hash.hmacStrength),
        (this._reseed = null),
        (this.reseedInterval = null),
        (this.K = null),
        (this.V = null)
    var e = sn.toArray(t.entropy, t.entropyEnc || "hex"),
        r = sn.toArray(t.nonce, t.nonceEnc || "hex"),
        n = sn.toArray(t.pers, t.persEnc || "hex")
    C0(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n)
}
var K1 = ji
ji.prototype._init = function (e, r, n) {
    var i = e.concat(r).concat(n)
    ;(this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8))
    for (var s = 0; s < this.V.length; s++) (this.K[s] = 0), (this.V[s] = 1)
    this._update(i), (this._reseed = 1), (this.reseedInterval = 281474976710656)
}
ji.prototype._hmac = function () {
    return new hr.hmac(this.hash, this.K)
}
ji.prototype._update = function (e) {
    var r = this._hmac().update(this.V).update([0])
    e && (r = r.update(e)),
        (this.K = r.digest()),
        (this.V = this._hmac().update(this.V).digest()),
        !!e && ((this.K = this._hmac().update(this.V).update([1]).update(e).digest()), (this.V = this._hmac().update(this.V).digest()))
}
ji.prototype.reseed = function (e, r, n, i) {
    typeof r != "string" && ((i = n), (n = r), (r = null)),
        (e = sn.toArray(e, r)),
        (n = sn.toArray(n, i)),
        C0(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
        this._update(e.concat(n || [])),
        (this._reseed = 1)
}
ji.prototype.generate = function (e, r, n, i) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required")
    typeof r != "string" && ((i = n), (n = r), (r = null)), n && ((n = sn.toArray(n, i || "hex")), this._update(n))
    for (var s = []; s.length < e; ) (this.V = this._hmac().update(this.V).digest()), (s = s.concat(this.V))
    var o = s.slice(0, e)
    return this._update(n), this._reseed++, sn.encode(o, r)
}
var fd = Dr.assert
function ur(t, e) {
    ;(this.ec = t),
        (this.priv = null),
        (this.pub = null),
        e.priv && this._importPrivate(e.priv, e.privEnc),
        e.pub && this._importPublic(e.pub, e.pubEnc)
}
var N0 = ur
ur.fromPublic = function (e, r, n) {
    return r instanceof ur ? r : new ur(e, { pub: r, pubEnc: n })
}
ur.fromPrivate = function (e, r, n) {
    return r instanceof ur ? r : new ur(e, { priv: r, privEnc: n })
}
ur.prototype.validate = function () {
    var e = this.getPublic()
    return e.isInfinity()
        ? { result: !1, reason: "Invalid public key" }
        : e.validate()
        ? e.mul(this.ec.curve.n).isInfinity()
            ? { result: !0, reason: null }
            : { result: !1, reason: "Public key * N != O" }
        : { result: !1, reason: "Public key is not a point" }
}
ur.prototype.getPublic = function (e, r) {
    return typeof e == "string" && ((r = e), (e = null)), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub
}
ur.prototype.getPrivate = function (e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv
}
ur.prototype._importPrivate = function (e, r) {
    ;(this.priv = new Oe(e, r || 16)), (this.priv = this.priv.umod(this.ec.curve.n))
}
ur.prototype._importPublic = function (e, r) {
    if (e.x || e.y) {
        this.ec.curve.type === "mont"
            ? fd(e.x, "Need x coordinate")
            : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && fd(e.x && e.y, "Need both x and y coordinate"),
            (this.pub = this.ec.curve.point(e.x, e.y))
        return
    }
    this.pub = this.ec.curve.decodePoint(e, r)
}
ur.prototype.derive = function (e) {
    return e.validate() || fd(e.validate(), "public point not validated"), e.mul(this.priv).getX()
}
ur.prototype.sign = function (e, r, n) {
    return this.ec.sign(e, this, r, n)
}
ur.prototype.verify = function (e, r) {
    return this.ec.verify(e, r, this)
}
ur.prototype.inspect = function () {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
}
var R4 = Dr.assert
function Zc(t, e) {
    if (t instanceof Zc) return t
    this._importDER(t, e) ||
        (R4(t.r && t.s, "Signature without r or s"),
        (this.r = new Oe(t.r, 16)),
        (this.s = new Oe(t.s, 16)),
        t.recoveryParam === void 0 ? (this.recoveryParam = null) : (this.recoveryParam = t.recoveryParam))
}
var Qc = Zc
function L4() {
    this.place = 0
}
function au(t, e) {
    var r = t[e.place++]
    if (!(r & 128)) return r
    var n = r & 15
    if (n === 0 || n > 4) return !1
    for (var i = 0, s = 0, o = e.place; s < n; s++, o++) (i <<= 8), (i |= t[o]), (i >>>= 0)
    return i <= 127 ? !1 : ((e.place = o), i)
}
function $p(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; ) e++
    return e === 0 ? t : t.slice(e)
}
Zc.prototype._importDER = function (e, r) {
    e = Dr.toArray(e, r)
    var n = new L4()
    if (e[n.place++] !== 48) return !1
    var i = au(e, n)
    if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2) return !1
    var s = au(e, n)
    if (s === !1) return !1
    var o = e.slice(n.place, s + n.place)
    if (((n.place += s), e[n.place++] !== 2)) return !1
    var a = au(e, n)
    if (a === !1 || e.length !== a + n.place) return !1
    var l = e.slice(n.place, a + n.place)
    if (o[0] === 0)
        if (o[1] & 128) o = o.slice(1)
        else return !1
    if (l[0] === 0)
        if (l[1] & 128) l = l.slice(1)
        else return !1
    return (this.r = new Oe(o)), (this.s = new Oe(l)), (this.recoveryParam = null), !0
}
function lu(t, e) {
    if (e < 128) {
        t.push(e)
        return
    }
    var r = 1 + ((Math.log(e) / Math.LN2) >>> 3)
    for (t.push(r | 128); --r; ) t.push((e >>> (r << 3)) & 255)
    t.push(e)
}
Zc.prototype.toDER = function (e) {
    var r = this.r.toArray(),
        n = this.s.toArray()
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = $p(r), n = $p(n); !n[0] && !(n[1] & 128); ) n = n.slice(1)
    var i = [2]
    lu(i, r.length), (i = i.concat(r)), i.push(2), lu(i, n.length)
    var s = i.concat(n),
        o = [48]
    return lu(o, s.length), (o = o.concat(s)), Dr.encode(o, e)
}
var D4 = function () {
        throw new Error("unsupported")
    },
    G1 = Dr.assert
function Kr(t) {
    if (!(this instanceof Kr)) return new Kr(t)
    typeof t == "string" && (G1(Object.prototype.hasOwnProperty.call(tc, t), "Unknown curve " + t), (t = tc[t])),
        t instanceof tc.PresetCurve && (t = { curve: t }),
        (this.curve = t.curve.curve),
        (this.n = this.curve.n),
        (this.nh = this.n.ushrn(1)),
        (this.g = this.curve.g),
        (this.g = t.curve.g),
        this.g.precompute(t.curve.n.bitLength() + 1),
        (this.hash = t.hash || t.curve.hash)
}
var F4 = Kr
Kr.prototype.keyPair = function (e) {
    return new N0(this, e)
}
Kr.prototype.keyFromPrivate = function (e, r) {
    return N0.fromPrivate(this, e, r)
}
Kr.prototype.keyFromPublic = function (e, r) {
    return N0.fromPublic(this, e, r)
}
Kr.prototype.genKeyPair = function (e) {
    e || (e = {})
    for (
        var r = new K1({
                hash: this.hash,
                pers: e.pers,
                persEnc: e.persEnc || "utf8",
                entropy: e.entropy || D4(this.hash.hmacStrength),
                entropyEnc: (e.entropy && e.entropyEnc) || "utf8",
                nonce: this.n.toArray(),
            }),
            n = this.n.byteLength(),
            i = this.n.sub(new Oe(2));
        ;

    ) {
        var s = new Oe(r.generate(n))
        if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
    }
}
Kr.prototype._truncateToN = function (e, r) {
    var n = e.byteLength() * 8 - this.n.bitLength()
    return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
}
Kr.prototype.sign = function (e, r, n, i) {
    typeof n == "object" && ((i = n), (n = null)), i || (i = {}), (r = this.keyFromPrivate(r, n)), (e = this._truncateToN(new Oe(e, 16)))
    for (
        var s = this.n.byteLength(),
            o = r.getPrivate().toArray("be", s),
            a = e.toArray("be", s),
            l = new K1({ hash: this.hash, entropy: o, nonce: a, pers: i.pers, persEnc: i.persEnc || "utf8" }),
            c = this.n.sub(new Oe(1)),
            f = 0;
        ;
        f++
    ) {
        var u = i.k ? i.k(f) : new Oe(l.generate(this.n.byteLength()))
        if (((u = this._truncateToN(u, !0)), !(u.cmpn(1) <= 0 || u.cmp(c) >= 0))) {
            var p = this.g.mul(u)
            if (!p.isInfinity()) {
                var m = p.getX(),
                    y = m.umod(this.n)
                if (y.cmpn(0) !== 0) {
                    var v = u.invm(this.n).mul(y.mul(r.getPrivate()).iadd(e))
                    if (((v = v.umod(this.n)), v.cmpn(0) !== 0)) {
                        var _ = (p.getY().isOdd() ? 1 : 0) | (m.cmp(y) !== 0 ? 2 : 0)
                        return i.canonical && v.cmp(this.nh) > 0 && ((v = this.n.sub(v)), (_ ^= 1)), new Qc({ r: y, s: v, recoveryParam: _ })
                    }
                }
            }
        }
    }
}
Kr.prototype.verify = function (e, r, n, i) {
    ;(e = this._truncateToN(new Oe(e, 16))), (n = this.keyFromPublic(n, i)), (r = new Qc(r, "hex"))
    var s = r.r,
        o = r.s
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1
    var a = o.invm(this.n),
        l = a.mul(e).umod(this.n),
        c = a.mul(s).umod(this.n),
        f
    return this.curve._maxwellTrick
        ? ((f = this.g.jmulAdd(l, n.getPublic(), c)), f.isInfinity() ? !1 : f.eqXToP(s))
        : ((f = this.g.mulAdd(l, n.getPublic(), c)), f.isInfinity() ? !1 : f.getX().umod(this.n).cmp(s) === 0)
}
Kr.prototype.recoverPubKey = function (t, e, r, n) {
    G1((3 & r) === r, "The recovery param is more than two bits"), (e = new Qc(e, n))
    var i = this.n,
        s = new Oe(t),
        o = e.r,
        a = e.s,
        l = r & 1,
        c = r >> 1
    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && c) throw new Error("Unable to find sencond key candinate")
    c ? (o = this.curve.pointFromX(o.add(this.curve.n), l)) : (o = this.curve.pointFromX(o, l))
    var f = e.r.invm(i),
        u = i.sub(s).mul(f).umod(i),
        p = a.mul(f).umod(i)
    return this.g.mulAdd(u, o, p)
}
Kr.prototype.getKeyRecoveryParam = function (t, e, r, n) {
    if (((e = new Qc(e, n)), e.recoveryParam !== null)) return e.recoveryParam
    for (var i = 0; i < 4; i++) {
        var s
        try {
            s = this.recoverPubKey(t, e, i)
        } catch {
            continue
        }
        if (s.eq(r)) return i
    }
    throw new Error("Unable to find valid recovery factor")
}
var V4 = Ko(function (t, e) {
        var r = e
        ;(r.version = "6.5.4"),
            (r.utils = Dr),
            (r.rand = function () {
                throw new Error("unsupported")
            }),
            (r.curve = ec),
            (r.curves = tc),
            (r.ec = F4),
            (r.eddsa = null)
    }),
    U4 = V4.ec
const H4 = "signing-key/5.5.0",
    W1 = new F(H4)
let cu = null
function vn() {
    return cu || (cu = new U4("secp256k1")), cu
}
class Ns {
    constructor(e) {
        X(this, "curve", "secp256k1"), X(this, "privateKey", pe(e))
        const r = vn().keyFromPrivate(le(this.privateKey))
        X(this, "publicKey", "0x" + r.getPublic(!1, "hex")),
            X(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")),
            X(this, "_isSigningKey", !0)
    }
    _addPoint(e) {
        const r = vn().keyFromPublic(le(this.publicKey)),
            n = vn().keyFromPublic(le(e))
        return "0x" + r.pub.add(n.pub).encodeCompressed("hex")
    }
    signDigest(e) {
        const r = vn().keyFromPrivate(le(this.privateKey)),
            n = le(e)
        n.length !== 32 && W1.throwArgumentError("bad digest length", "digest", e)
        const i = r.sign(n, { canonical: !0 })
        return Us({ recoveryParam: i.recoveryParam, r: ut("0x" + i.r.toString(16), 32), s: ut("0x" + i.s.toString(16), 32) })
    }
    computeSharedSecret(e) {
        const r = vn().keyFromPrivate(le(this.privateKey)),
            n = vn().keyFromPublic(le(P0(e)))
        return ut("0x" + r.derive(n.getPublic()).toString(16), 32)
    }
    static isSigningKey(e) {
        return !!(e && e._isSigningKey)
    }
}
function J1(t, e) {
    const r = Us(e),
        n = { r: le(r.r), s: le(r.s) }
    return "0x" + vn().recoverPubKey(le(t), n, r.recoveryParam).encode("hex", !1)
}
function P0(t, e) {
    const r = le(t)
    if (r.length === 32) {
        const n = new Ns(r)
        return e ? "0x" + vn().keyFromPrivate(r).getPublic(!0, "hex") : n.publicKey
    } else {
        if (r.length === 33) return e ? pe(r) : "0x" + vn().keyFromPublic(r).getPublic(!1, "hex")
        if (r.length === 65) return e ? "0x" + vn().keyFromPublic(r).getPublic(!0, "hex") : pe(r)
    }
    return W1.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
}
const q4 = "transactions/5.5.0",
    fr = new F(q4)
var ud
;(function (t) {
    ;(t[(t.legacy = 0)] = "legacy"), (t[(t.eip2930 = 1)] = "eip2930"), (t[(t.eip1559 = 2)] = "eip1559")
})(ud || (ud = {}))
function I0(t) {
    return t === "0x" ? null : nt(t)
}
function cr(t) {
    return t === "0x" ? y0 : ce.from(t)
}
const j4 = [
        { name: "nonce", maxLength: 32, numeric: !0 },
        { name: "gasPrice", maxLength: 32, numeric: !0 },
        { name: "gasLimit", maxLength: 32, numeric: !0 },
        { name: "to", length: 20 },
        { name: "value", maxLength: 32, numeric: !0 },
        { name: "data" },
    ],
    z4 = { chainId: !0, data: !0, gasLimit: !0, gasPrice: !0, nonce: !0, to: !0, type: !0, value: !0 }
function Di(t) {
    const e = P0(t)
    return nt(Er(st(Er(e, 1)), 12))
}
function fl(t, e) {
    return Di(J1(le(t), e))
}
function Nr(t, e) {
    const r = In(ce.from(t).toHexString())
    return r.length > 32 && fr.throwArgumentError("invalid length for " + e, "transaction:" + e, t), r
}
function fu(t, e) {
    return {
        address: nt(t),
        storageKeys: (e || []).map(
            (r, n) => (Hi(r) !== 32 && fr.throwArgumentError("invalid access list storageKey", `accessList[${t}:${n}]`, r), r.toLowerCase())
        ),
    }
}
function Zi(t) {
    if (Array.isArray(t))
        return t.map((r, n) =>
            Array.isArray(r)
                ? (r.length > 2 && fr.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${n}]`, r),
                  fu(r[0], r[1]))
                : fu(r.address, r.storageKeys)
        )
    const e = Object.keys(t).map((r) => {
        const n = t[r].reduce((i, s) => ((i[s] = !0), i), {})
        return fu(r, Object.keys(n).sort())
    })
    return e.sort((r, n) => r.address.localeCompare(n.address)), e
}
function X1(t) {
    return Zi(t).map((e) => [e.address, e.storageKeys])
}
function Y1(t, e) {
    if (t.gasPrice != null) {
        const n = ce.from(t.gasPrice),
            i = ce.from(t.maxFeePerGas || 0)
        n.eq(i) || fr.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", { gasPrice: n, maxFeePerGas: i })
    }
    const r = [
        Nr(t.chainId || 0, "chainId"),
        Nr(t.nonce || 0, "nonce"),
        Nr(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        Nr(t.maxFeePerGas || 0, "maxFeePerGas"),
        Nr(t.gasLimit || 0, "gasLimit"),
        t.to != null ? nt(t.to) : "0x",
        Nr(t.value || 0, "value"),
        t.data || "0x",
        X1(t.accessList || []),
    ]
    if (e) {
        const n = Us(e)
        r.push(Nr(n.recoveryParam, "recoveryParam")), r.push(In(n.r)), r.push(In(n.s))
    }
    return qr(["0x02", Ms(r)])
}
function Z1(t, e) {
    const r = [
        Nr(t.chainId || 0, "chainId"),
        Nr(t.nonce || 0, "nonce"),
        Nr(t.gasPrice || 0, "gasPrice"),
        Nr(t.gasLimit || 0, "gasLimit"),
        t.to != null ? nt(t.to) : "0x",
        Nr(t.value || 0, "value"),
        t.data || "0x",
        X1(t.accessList || []),
    ]
    if (e) {
        const n = Us(e)
        r.push(Nr(n.recoveryParam, "recoveryParam")), r.push(In(n.r)), r.push(In(n.s))
    }
    return qr(["0x01", Ms(r)])
}
function K4(t, e) {
    b0(t, z4)
    const r = []
    j4.forEach(function (o) {
        let a = t[o.name] || []
        const l = {}
        o.numeric && (l.hexPad = "left"),
            (a = le(pe(a, l))),
            o.length &&
                a.length !== o.length &&
                a.length > 0 &&
                fr.throwArgumentError("invalid length for " + o.name, "transaction:" + o.name, a),
            o.maxLength &&
                ((a = In(a)), a.length > o.maxLength && fr.throwArgumentError("invalid length for " + o.name, "transaction:" + o.name, a)),
            r.push(pe(a))
    })
    let n = 0
    if (
        (t.chainId != null
            ? ((n = t.chainId), typeof n != "number" && fr.throwArgumentError("invalid transaction.chainId", "transaction", t))
            : e && !ol(e) && e.v > 28 && (n = Math.floor((e.v - 35) / 2)),
        n !== 0 && (r.push(pe(n)), r.push("0x"), r.push("0x")),
        !e)
    )
        return Ms(r)
    const i = Us(e)
    let s = 27 + i.recoveryParam
    return (
        n !== 0
            ? (r.pop(),
              r.pop(),
              r.pop(),
              (s += n * 2 + 8),
              i.v > 28 && i.v !== s && fr.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e))
            : i.v !== s && fr.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e),
        r.push(pe(s)),
        r.push(In(le(i.r))),
        r.push(In(le(i.s))),
        Ms(r)
    )
}
function dd(t, e) {
    if (t.type == null || t.type === 0)
        return (
            t.accessList != null && fr.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", t),
            K4(t, e)
        )
    switch (t.type) {
        case 1:
            return Z1(t, e)
        case 2:
            return Y1(t, e)
    }
    return fr.throwError(`unsupported transaction type: ${t.type}`, F.errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: t.type,
    })
}
function Q1(t, e, r) {
    try {
        const n = cr(e[0]).toNumber()
        if (n !== 0 && n !== 1) throw new Error("bad recid")
        t.v = n
    } catch {
        fr.throwArgumentError("invalid v for transaction type: 1", "v", e[0])
    }
    ;(t.r = ut(e[1], 32)), (t.s = ut(e[2], 32))
    try {
        const n = st(r(t))
        t.from = fl(n, { r: t.r, s: t.s, recoveryParam: t.v })
    } catch (n) {
        console.log(n)
    }
}
function G4(t) {
    const e = Wc(t.slice(1))
    e.length !== 9 && e.length !== 12 && fr.throwArgumentError("invalid component count for transaction type: 2", "payload", pe(t))
    const r = cr(e[2]),
        n = cr(e[3]),
        i = {
            type: 2,
            chainId: cr(e[0]).toNumber(),
            nonce: cr(e[1]).toNumber(),
            maxPriorityFeePerGas: r,
            maxFeePerGas: n,
            gasPrice: null,
            gasLimit: cr(e[4]),
            to: I0(e[5]),
            value: cr(e[6]),
            data: e[7],
            accessList: Zi(e[8]),
        }
    return e.length === 9 || ((i.hash = st(t)), Q1(i, e.slice(9), Y1)), i
}
function W4(t) {
    const e = Wc(t.slice(1))
    e.length !== 8 && e.length !== 11 && fr.throwArgumentError("invalid component count for transaction type: 1", "payload", pe(t))
    const r = {
        type: 1,
        chainId: cr(e[0]).toNumber(),
        nonce: cr(e[1]).toNumber(),
        gasPrice: cr(e[2]),
        gasLimit: cr(e[3]),
        to: I0(e[4]),
        value: cr(e[5]),
        data: e[6],
        accessList: Zi(e[7]),
    }
    return e.length === 8 || ((r.hash = st(t)), Q1(r, e.slice(8), Z1)), r
}
function J4(t) {
    const e = Wc(t)
    e.length !== 9 && e.length !== 6 && fr.throwArgumentError("invalid raw transaction", "rawTransaction", t)
    const r = { nonce: cr(e[0]).toNumber(), gasPrice: cr(e[1]), gasLimit: cr(e[2]), to: I0(e[3]), value: cr(e[4]), data: e[5], chainId: 0 }
    if (e.length === 6) return r
    try {
        r.v = ce.from(e[6]).toNumber()
    } catch (n) {
        return console.log(n), r
    }
    if (((r.r = ut(e[7], 32)), (r.s = ut(e[8], 32)), ce.from(r.r).isZero() && ce.from(r.s).isZero())) (r.chainId = r.v), (r.v = 0)
    else {
        ;(r.chainId = Math.floor((r.v - 35) / 2)), r.chainId < 0 && (r.chainId = 0)
        let n = r.v - 27
        const i = e.slice(0, 6)
        r.chainId !== 0 && (i.push(pe(r.chainId)), i.push("0x"), i.push("0x"), (n -= r.chainId * 2 + 8))
        const s = st(Ms(i))
        try {
            r.from = fl(s, { r: pe(r.r), s: pe(r.s), recoveryParam: n })
        } catch (o) {
            console.log(o)
        }
        r.hash = st(t)
    }
    return (r.type = null), r
}
function ex(t) {
    const e = le(t)
    if (e[0] > 127) return J4(e)
    switch (e[0]) {
        case 1:
            return W4(e)
        case 2:
            return G4(e)
    }
    return fr.throwError(`unsupported transaction type: ${e[0]}`, F.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: e[0],
    })
}
const X4 = "contracts/5.5.0"
var zi =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const rt = new F(X4),
    Y4 = {
        chainId: !0,
        data: !0,
        from: !0,
        gasLimit: !0,
        gasPrice: !0,
        nonce: !0,
        to: !0,
        value: !0,
        type: !0,
        accessList: !0,
        maxFeePerGas: !0,
        maxPriorityFeePerGas: !0,
        customData: !0,
    }
function Ac(t, e) {
    return zi(this, void 0, void 0, function* () {
        const r = yield e
        typeof r != "string" && rt.throwArgumentError("invalid address or ENS name", "name", r)
        try {
            return nt(r)
        } catch {}
        t || rt.throwError("a provider or signer is needed to resolve ENS names", F.errors.UNSUPPORTED_OPERATION, { operation: "resolveName" })
        const n = yield t.resolveName(r)
        return n == null && rt.throwArgumentError("resolver or addr is not configured for ENS name", "name", r), n
    })
}
function Pa(t, e, r) {
    return zi(this, void 0, void 0, function* () {
        return Array.isArray(r)
            ? yield Promise.all(r.map((n, i) => Pa(t, Array.isArray(e) ? e[i] : e[n.name], n)))
            : r.type === "address"
            ? yield Ac(t, e)
            : r.type === "tuple"
            ? yield Pa(t, e, r.components)
            : r.baseType === "array"
            ? Array.isArray(e)
                ? yield Promise.all(e.map((n) => Pa(t, n, r.arrayChildren)))
                : Promise.reject(rt.makeError("invalid value for array", F.errors.INVALID_ARGUMENT, { argument: "value", value: e }))
            : e
    })
}
function ef(t, e, r) {
    return zi(this, void 0, void 0, function* () {
        let n = {}
        r.length === e.inputs.length + 1 && typeof r[r.length - 1] == "object" && (n = Pt(r.pop())),
            rt.checkArgumentCount(r.length, e.inputs.length, "passed to contract"),
            t.signer
                ? n.from
                    ? (n.from = Dt({ override: Ac(t.signer, n.from), signer: t.signer.getAddress() }).then((c) =>
                          zi(this, void 0, void 0, function* () {
                              return (
                                  nt(c.signer) !== c.override &&
                                      rt.throwError("Contract with a Signer cannot override from", F.errors.UNSUPPORTED_OPERATION, {
                                          operation: "overrides.from",
                                      }),
                                  c.override
                              )
                          })
                      ))
                    : (n.from = t.signer.getAddress())
                : n.from && (n.from = Ac(t.provider, n.from))
        const i = yield Dt({ args: Pa(t.signer || t.provider, r, e.inputs), address: t.resolvedAddress, overrides: Dt(n) || {} }),
            s = t.interface.encodeFunctionData(e, i.args),
            o = { data: s, to: i.address },
            a = i.overrides
        if (
            (a.nonce != null && (o.nonce = ce.from(a.nonce).toNumber()),
            a.gasLimit != null && (o.gasLimit = ce.from(a.gasLimit)),
            a.gasPrice != null && (o.gasPrice = ce.from(a.gasPrice)),
            a.maxFeePerGas != null && (o.maxFeePerGas = ce.from(a.maxFeePerGas)),
            a.maxPriorityFeePerGas != null && (o.maxPriorityFeePerGas = ce.from(a.maxPriorityFeePerGas)),
            a.from != null && (o.from = a.from),
            a.type != null && (o.type = a.type),
            a.accessList != null && (o.accessList = Zi(a.accessList)),
            o.gasLimit == null && e.gas != null)
        ) {
            let c = 21e3
            const f = le(s)
            for (let u = 0; u < f.length; u++) (c += 4), f[u] && (c += 64)
            o.gasLimit = ce.from(e.gas).add(c)
        }
        if (a.value) {
            const c = ce.from(a.value)
            !c.isZero() &&
                !e.payable &&
                rt.throwError("non-payable method cannot override value", F.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: n.value,
                }),
                (o.value = c)
        }
        a.customData && (o.customData = Pt(a.customData)),
            delete n.nonce,
            delete n.gasLimit,
            delete n.gasPrice,
            delete n.from,
            delete n.value,
            delete n.type,
            delete n.accessList,
            delete n.maxFeePerGas,
            delete n.maxPriorityFeePerGas,
            delete n.customData
        const l = Object.keys(n).filter((c) => n[c] != null)
        return (
            l.length &&
                rt.throwError(`cannot override ${l.map((c) => JSON.stringify(c)).join(",")}`, F.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides",
                    overrides: l,
                }),
            o
        )
    })
}
function Z4(t, e) {
    return function (...r) {
        return ef(t, e, r)
    }
}
function Q4(t, e) {
    const r = t.signer || t.provider
    return function (...n) {
        return zi(this, void 0, void 0, function* () {
            r || rt.throwError("estimate require a provider or signer", F.errors.UNSUPPORTED_OPERATION, { operation: "estimateGas" })
            const i = yield ef(t, e, n)
            return yield r.estimateGas(i)
        })
    }
}
function tx(t, e) {
    const r = e.wait.bind(e)
    e.wait = (n) =>
        r(n).then(
            (i) => (
                (i.events = i.logs.map((s) => {
                    let o = pr(s),
                        a = null
                    try {
                        a = t.interface.parseLog(s)
                    } catch {}
                    return (
                        a &&
                            ((o.args = a.args),
                            (o.decode = (l, c) => t.interface.decodeEventLog(a.eventFragment, l, c)),
                            (o.event = a.name),
                            (o.eventSignature = a.signature)),
                        (o.removeListener = () => t.provider),
                        (o.getBlock = () => t.provider.getBlock(i.blockHash)),
                        (o.getTransaction = () => t.provider.getTransaction(i.transactionHash)),
                        (o.getTransactionReceipt = () => Promise.resolve(i)),
                        o
                    )
                })),
                i
            )
        )
}
function rx(t, e, r) {
    const n = t.signer || t.provider
    return function (...i) {
        return zi(this, void 0, void 0, function* () {
            let s
            if (i.length === e.inputs.length + 1 && typeof i[i.length - 1] == "object") {
                const l = Pt(i.pop())
                l.blockTag != null && (s = yield l.blockTag), delete l.blockTag, i.push(l)
            }
            t.deployTransaction != null && (yield t._deployed(s))
            const o = yield ef(t, e, i),
                a = yield n.call(o, s)
            try {
                let l = t.interface.decodeFunctionResult(e, a)
                return r && e.outputs.length === 1 && (l = l[0]), l
            } catch (l) {
                throw (l.code === F.errors.CALL_EXCEPTION && ((l.address = t.address), (l.args = i), (l.transaction = o)), l)
            }
        })
    }
}
function e5(t, e) {
    return function (...r) {
        return zi(this, void 0, void 0, function* () {
            t.signer ||
                rt.throwError("sending a transaction requires a signer", F.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction" }),
                t.deployTransaction != null && (yield t._deployed())
            const n = yield ef(t, e, r),
                i = yield t.signer.sendTransaction(n)
            return tx(t, i), i
        })
    }
}
function Bp(t, e, r) {
    return e.constant ? rx(t, e, r) : e5(t, e)
}
function nx(t) {
    return t.address && (t.topics == null || t.topics.length === 0)
        ? "*"
        : (t.address || "*") + "@" + (t.topics ? t.topics.map((e) => (Array.isArray(e) ? e.join("|") : e)).join(":") : "")
}
class Qa {
    constructor(e, r) {
        X(this, "tag", e), X(this, "filter", r), (this._listeners = [])
    }
    addListener(e, r) {
        this._listeners.push({ listener: e, once: r })
    }
    removeListener(e) {
        let r = !1
        this._listeners = this._listeners.filter((n) => (r || n.listener !== e ? !0 : ((r = !0), !1)))
    }
    removeAllListeners() {
        this._listeners = []
    }
    listeners() {
        return this._listeners.map((e) => e.listener)
    }
    listenerCount() {
        return this._listeners.length
    }
    run(e) {
        const r = this.listenerCount()
        return (
            (this._listeners = this._listeners.filter((n) => {
                const i = e.slice()
                return (
                    setTimeout(() => {
                        n.listener.apply(this, i)
                    }, 0),
                    !n.once
                )
            })),
            r
        )
    }
    prepareEvent(e) {}
    getEmit(e) {
        return [e]
    }
}
class t5 extends Qa {
    constructor() {
        super("error", null)
    }
}
class Op extends Qa {
    constructor(e, r, n, i) {
        const s = { address: e }
        let o = r.getEventTopic(n)
        i ? (o !== i[0] && rt.throwArgumentError("topic mismatch", "topics", i), (s.topics = i.slice())) : (s.topics = [o])
        super(nx(s), s)
        X(this, "address", e), X(this, "interface", r), X(this, "fragment", n)
    }
    prepareEvent(e) {
        super.prepareEvent(e),
            (e.event = this.fragment.name),
            (e.eventSignature = this.fragment.format()),
            (e.decode = (r, n) => this.interface.decodeEventLog(this.fragment, r, n))
        try {
            e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics)
        } catch (r) {
            ;(e.args = null), (e.decodeError = r)
        }
    }
    getEmit(e) {
        const r = r1(e.args)
        if (r.length) throw r[0].error
        const n = (e.args || []).slice()
        return n.push(e), n
    }
}
class Mp extends Qa {
    constructor(e, r) {
        super("*", { address: e })
        X(this, "address", e), X(this, "interface", r)
    }
    prepareEvent(e) {
        super.prepareEvent(e)
        try {
            const r = this.interface.parseLog(e)
            ;(e.event = r.name),
                (e.eventSignature = r.signature),
                (e.decode = (n, i) => this.interface.decodeEventLog(r.eventFragment, n, i)),
                (e.args = r.args)
        } catch {}
    }
}
class $0 {
    constructor(e, r, n) {
        rt.checkNew(new.target, el),
            X(this, "interface", Yt(new.target, "getInterface")(r)),
            n == null
                ? (X(this, "provider", null), X(this, "signer", null))
                : di.isSigner(n)
                ? (X(this, "provider", n.provider || null), X(this, "signer", n))
                : qi.isProvider(n)
                ? (X(this, "provider", n), X(this, "signer", null))
                : rt.throwArgumentError("invalid signer or provider", "signerOrProvider", n),
            X(this, "callStatic", {}),
            X(this, "estimateGas", {}),
            X(this, "functions", {}),
            X(this, "populateTransaction", {}),
            X(this, "filters", {})
        {
            const o = {}
            Object.keys(this.interface.events).forEach((a) => {
                const l = this.interface.events[a]
                X(this.filters, a, (...c) => ({ address: this.address, topics: this.interface.encodeFilterTopics(l, c) })),
                    o[l.name] || (o[l.name] = []),
                    o[l.name].push(a)
            }),
                Object.keys(o).forEach((a) => {
                    const l = o[a]
                    l.length === 1 ? X(this.filters, a, this.filters[l[0]]) : rt.warn(`Duplicate definition of ${a} (${l.join(", ")})`)
                })
        }
        if (
            (X(this, "_runningEvents", {}),
            X(this, "_wrappedEmits", {}),
            e == null && rt.throwArgumentError("invalid contract address or ENS name", "addressOrName", e),
            X(this, "address", e),
            this.provider)
        )
            X(this, "resolvedAddress", Ac(this.provider, e))
        else
            try {
                X(this, "resolvedAddress", Promise.resolve(nt(e)))
            } catch {
                rt.throwError("provider is required to use ENS name as contract address", F.errors.UNSUPPORTED_OPERATION, {
                    operation: "new Contract",
                })
            }
        const i = {},
            s = {}
        Object.keys(this.interface.functions).forEach((o) => {
            const a = this.interface.functions[o]
            if (s[o]) {
                rt.warn(`Duplicate ABI entry for ${JSON.stringify(o)}`)
                return
            }
            s[o] = !0
            {
                const l = a.name
                i[`%${l}`] || (i[`%${l}`] = []), i[`%${l}`].push(o)
            }
            this[o] == null && X(this, o, Bp(this, a, !0)),
                this.functions[o] == null && X(this.functions, o, Bp(this, a, !1)),
                this.callStatic[o] == null && X(this.callStatic, o, rx(this, a, !0)),
                this.populateTransaction[o] == null && X(this.populateTransaction, o, Z4(this, a)),
                this.estimateGas[o] == null && X(this.estimateGas, o, Q4(this, a))
        }),
            Object.keys(i).forEach((o) => {
                const a = i[o]
                if (a.length > 1) return
                o = o.substring(1)
                const l = a[0]
                try {
                    this[o] == null && X(this, o, this[l])
                } catch {}
                this.functions[o] == null && X(this.functions, o, this.functions[l]),
                    this.callStatic[o] == null && X(this.callStatic, o, this.callStatic[l]),
                    this.populateTransaction[o] == null && X(this.populateTransaction, o, this.populateTransaction[l]),
                    this.estimateGas[o] == null && X(this.estimateGas, o, this.estimateGas[l])
            })
    }
    static getContractAddress(e) {
        return Jc(e)
    }
    static getInterface(e) {
        return Za.isInterface(e) ? e : new Za(e)
    }
    deployed() {
        return this._deployed()
    }
    _deployed(e) {
        return (
            this._deployedPromise ||
                (this.deployTransaction
                    ? (this._deployedPromise = this.deployTransaction.wait().then(() => this))
                    : (this._deployedPromise = this.provider
                          .getCode(this.address, e)
                          .then(
                              (r) => (
                                  r === "0x" &&
                                      rt.throwError("contract not deployed", F.errors.UNSUPPORTED_OPERATION, {
                                          contractAddress: this.address,
                                          operation: "getDeployed",
                                      }),
                                  this
                              )
                          ))),
            this._deployedPromise
        )
    }
    fallback(e) {
        this.signer ||
            rt.throwError("sending a transactions require a signer", F.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" })
        const r = Pt(e || {})
        return (
            ["from", "to"].forEach(function (n) {
                r[n] != null && rt.throwError("cannot override " + n, F.errors.UNSUPPORTED_OPERATION, { operation: n })
            }),
            (r.to = this.resolvedAddress),
            this.deployed().then(() => this.signer.sendTransaction(r))
        )
    }
    connect(e) {
        typeof e == "string" && (e = new To(e, this.provider))
        const r = new this.constructor(this.address, this.interface, e)
        return this.deployTransaction && X(r, "deployTransaction", this.deployTransaction), r
    }
    attach(e) {
        return new this.constructor(e, this.interface, this.signer || this.provider)
    }
    static isIndexed(e) {
        return wc.isIndexed(e)
    }
    _normalizeRunningEvent(e) {
        return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e
    }
    _getRunningEvent(e) {
        if (typeof e == "string") {
            if (e === "error") return this._normalizeRunningEvent(new t5())
            if (e === "event") return this._normalizeRunningEvent(new Qa("event", null))
            if (e === "*") return this._normalizeRunningEvent(new Mp(this.address, this.interface))
            const r = this.interface.getEvent(e)
            return this._normalizeRunningEvent(new Op(this.address, this.interface, r))
        }
        if (e.topics && e.topics.length > 0) {
            try {
                const n = e.topics[0]
                if (typeof n != "string") throw new Error("invalid topic")
                const i = this.interface.getEvent(n)
                return this._normalizeRunningEvent(new Op(this.address, this.interface, i, e.topics))
            } catch {}
            const r = { address: this.address, topics: e.topics }
            return this._normalizeRunningEvent(new Qa(nx(r), r))
        }
        return this._normalizeRunningEvent(new Mp(this.address, this.interface))
    }
    _checkRunningEvents(e) {
        if (e.listenerCount() === 0) {
            delete this._runningEvents[e.tag]
            const r = this._wrappedEmits[e.tag]
            r && e.filter && (this.provider.off(e.filter, r), delete this._wrappedEmits[e.tag])
        }
    }
    _wrapEvent(e, r, n) {
        const i = pr(r)
        return (
            (i.removeListener = () => {
                !n || (e.removeListener(n), this._checkRunningEvents(e))
            }),
            (i.getBlock = () => this.provider.getBlock(r.blockHash)),
            (i.getTransaction = () => this.provider.getTransaction(r.transactionHash)),
            (i.getTransactionReceipt = () => this.provider.getTransactionReceipt(r.transactionHash)),
            e.prepareEvent(i),
            i
        )
    }
    _addEventListener(e, r, n) {
        if (
            (this.provider ||
                rt.throwError("events require a provider or a signer with a provider", F.errors.UNSUPPORTED_OPERATION, { operation: "once" }),
            e.addListener(r, n),
            (this._runningEvents[e.tag] = e),
            !this._wrappedEmits[e.tag])
        ) {
            const i = (s) => {
                let o = this._wrapEvent(e, s, r)
                if (o.decodeError == null)
                    try {
                        const a = e.getEmit(o)
                        this.emit(e.filter, ...a)
                    } catch (a) {
                        o.decodeError = a.error
                    }
                e.filter != null && this.emit("event", o), o.decodeError != null && this.emit("error", o.decodeError, o)
            }
            ;(this._wrappedEmits[e.tag] = i), e.filter != null && this.provider.on(e.filter, i)
        }
    }
    queryFilter(e, r, n) {
        const i = this._getRunningEvent(e),
            s = Pt(i.filter)
        return (
            typeof r == "string" && Le(r, 32)
                ? (n != null && rt.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", n), (s.blockHash = r))
                : ((s.fromBlock = r != null ? r : 0), (s.toBlock = n != null ? n : "latest")),
            this.provider.getLogs(s).then((o) => o.map((a) => this._wrapEvent(i, a, null)))
        )
    }
    on(e, r) {
        return this._addEventListener(this._getRunningEvent(e), r, !1), this
    }
    once(e, r) {
        return this._addEventListener(this._getRunningEvent(e), r, !0), this
    }
    emit(e, ...r) {
        if (!this.provider) return !1
        const n = this._getRunningEvent(e),
            i = n.run(r) > 0
        return this._checkRunningEvents(n), i
    }
    listenerCount(e) {
        return this.provider
            ? e == null
                ? Object.keys(this._runningEvents).reduce((r, n) => r + this._runningEvents[n].listenerCount(), 0)
                : this._getRunningEvent(e).listenerCount()
            : 0
    }
    listeners(e) {
        if (!this.provider) return []
        if (e == null) {
            const r = []
            for (let n in this._runningEvents)
                this._runningEvents[n].listeners().forEach((i) => {
                    r.push(i)
                })
            return r
        }
        return this._getRunningEvent(e).listeners()
    }
    removeAllListeners(e) {
        if (!this.provider) return this
        if (e == null) {
            for (const n in this._runningEvents) {
                const i = this._runningEvents[n]
                i.removeAllListeners(), this._checkRunningEvents(i)
            }
            return this
        }
        const r = this._getRunningEvent(e)
        return r.removeAllListeners(), this._checkRunningEvents(r), this
    }
    off(e, r) {
        if (!this.provider) return this
        const n = this._getRunningEvent(e)
        return n.removeListener(r), this._checkRunningEvents(n), this
    }
    removeListener(e, r) {
        return this.off(e, r)
    }
}
class el extends $0 {}
class ix {
    constructor(e, r, n) {
        let i = null
        typeof r == "string" ? (i = r) : Ji(r) ? (i = pe(r)) : r && typeof r.object == "string" ? (i = r.object) : (i = "!"),
            i.substring(0, 2) !== "0x" && (i = "0x" + i),
            (!Le(i) || i.length % 2) && rt.throwArgumentError("invalid bytecode", "bytecode", r),
            n && !di.isSigner(n) && rt.throwArgumentError("invalid signer", "signer", n),
            X(this, "bytecode", i),
            X(this, "interface", Yt(new.target, "getInterface")(e)),
            X(this, "signer", n || null)
    }
    getDeployTransaction(...e) {
        let r = {}
        if (e.length === this.interface.deploy.inputs.length + 1 && typeof e[e.length - 1] == "object") {
            r = Pt(e.pop())
            for (const n in r) if (!Y4[n]) throw new Error("unknown transaction override " + n)
        }
        return (
            ["data", "from", "to"].forEach((n) => {
                r[n] != null && rt.throwError("cannot override " + n, F.errors.UNSUPPORTED_OPERATION, { operation: n })
            }),
            r.value &&
                !ce.from(r.value).isZero() &&
                !this.interface.deploy.payable &&
                rt.throwError("non-payable constructor cannot override value", F.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: r.value,
                }),
            rt.checkArgumentCount(e.length, this.interface.deploy.inputs.length, " in Contract constructor"),
            (r.data = pe(ft([this.bytecode, this.interface.encodeDeploy(e)]))),
            r
        )
    }
    deploy(...e) {
        return zi(this, void 0, void 0, function* () {
            let r = {}
            e.length === this.interface.deploy.inputs.length + 1 && (r = e.pop()),
                rt.checkArgumentCount(e.length, this.interface.deploy.inputs.length, " in Contract constructor")
            const n = yield Pa(this.signer, e, this.interface.deploy.inputs)
            n.push(r)
            const i = this.getDeployTransaction(...n),
                s = yield this.signer.sendTransaction(i),
                o = Yt(this.constructor, "getContractAddress")(s),
                a = Yt(this.constructor, "getContract")(o, this.interface, this.signer)
            return tx(a, s), X(a, "deployTransaction", s), a
        })
    }
    attach(e) {
        return this.constructor.getContract(e, this.interface, this.signer)
    }
    connect(e) {
        return new this.constructor(this.interface, this.bytecode, e)
    }
    static fromSolidity(e, r) {
        e == null && rt.throwError("missing compiler output", F.errors.MISSING_ARGUMENT, { argument: "compilerOutput" }),
            typeof e == "string" && (e = JSON.parse(e))
        const n = e.abi
        let i = null
        return e.bytecode ? (i = e.bytecode) : e.evm && e.evm.bytecode && (i = e.evm.bytecode), new this(n, i, r)
    }
    static getInterface(e) {
        return el.getInterface(e)
    }
    static getContractAddress(e) {
        return Jc(e)
    }
    static getContract(e, r, n) {
        return new el(e, r, n)
    }
}
class sx {
    constructor(e) {
        X(this, "alphabet", e), X(this, "base", e.length), X(this, "_alphabetMap", {}), X(this, "_leader", e.charAt(0))
        for (let r = 0; r < e.length; r++) this._alphabetMap[e.charAt(r)] = r
    }
    encode(e) {
        let r = le(e)
        if (r.length === 0) return ""
        let n = [0]
        for (let s = 0; s < r.length; ++s) {
            let o = r[s]
            for (let a = 0; a < n.length; ++a) (o += n[a] << 8), (n[a] = o % this.base), (o = (o / this.base) | 0)
            for (; o > 0; ) n.push(o % this.base), (o = (o / this.base) | 0)
        }
        let i = ""
        for (let s = 0; r[s] === 0 && s < r.length - 1; ++s) i += this._leader
        for (let s = n.length - 1; s >= 0; --s) i += this.alphabet[n[s]]
        return i
    }
    decode(e) {
        if (typeof e != "string") throw new TypeError("Expected String")
        let r = []
        if (e.length === 0) return new Uint8Array(r)
        r.push(0)
        for (let n = 0; n < e.length; n++) {
            let i = this._alphabetMap[e[n]]
            if (i === void 0) throw new Error("Non-base" + this.base + " character")
            let s = i
            for (let o = 0; o < r.length; ++o) (s += r[o] * this.base), (r[o] = s & 255), (s >>= 8)
            for (; s > 0; ) r.push(s & 255), (s >>= 8)
        }
        for (let n = 0; e[n] === this._leader && n < e.length - 1; ++n) r.push(0)
        return le(new Uint8Array(r.reverse()))
    }
}
new sx("abcdefghijklmnopqrstuvwxyz234567")
const ul = new sx("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
var Po
;(function (t) {
    ;(t.sha256 = "sha256"), (t.sha512 = "sha512")
})(Po || (Po = {}))
const r5 = "sha2/5.5.0",
    n5 = new F(r5)
function ox(t) {
    return "0x" + hr.ripemd160().update(le(t)).digest("hex")
}
function ai(t) {
    return "0x" + hr.sha256().update(le(t)).digest("hex")
}
function i5(t) {
    return "0x" + hr.sha512().update(le(t)).digest("hex")
}
function tl(t, e, r) {
    return (
        Po[t] || n5.throwError("unsupported algorithm " + t, F.errors.UNSUPPORTED_OPERATION, { operation: "hmac", algorithm: t }),
        "0x" + hr.hmac(hr[t], le(e)).update(le(r)).digest("hex")
    )
}
function B0(t, e, r, n, i) {
    ;(t = le(t)), (e = le(e))
    let s,
        o = 1
    const a = new Uint8Array(n),
        l = new Uint8Array(e.length + 4)
    l.set(e)
    let c, f
    for (let u = 1; u <= o; u++) {
        ;(l[e.length] = (u >> 24) & 255), (l[e.length + 1] = (u >> 16) & 255), (l[e.length + 2] = (u >> 8) & 255), (l[e.length + 3] = u & 255)
        let p = le(tl(i, t, l))
        s || ((s = p.length), (f = new Uint8Array(s)), (o = Math.ceil(n / s)), (c = n - (o - 1) * s)), f.set(p)
        for (let v = 1; v < r; v++) {
            p = le(tl(i, t, p))
            for (let _ = 0; _ < s; _++) f[_] ^= p[_]
        }
        const m = (u - 1) * s,
            y = u === o ? c : s
        a.set(le(f).slice(0, y), m)
    }
    return pe(a)
}
const s5 = "wordlists/5.5.0",
    o5 = new F(s5)
class js {
    constructor(e) {
        o5.checkAbstract(new.target, js), X(this, "locale", e)
    }
    split(e) {
        return e.toLowerCase().split(/ +/g)
    }
    join(e) {
        return e.join(" ")
    }
    static check(e) {
        const r = []
        for (let n = 0; n < 2048; n++) {
            const i = e.getWord(n)
            if (n !== e.getWordIndex(i)) return "0x"
            r.push(i)
        }
        return Bi(
            r.join(`
`) +
                `
`
        )
    }
    static register(e, r) {}
}
const a5 =
    "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo"
let Ia = null
function Rp(t) {
    if (
        Ia == null &&
        ((Ia = a5
            .replace(/([A-Z])/g, " $1")
            .toLowerCase()
            .substring(1)
            .split(" ")),
        js.check(t) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60")
    )
        throw ((Ia = null), new Error("BIP39 Wordlist for en (English) FAILED"))
}
class l5 extends js {
    constructor() {
        super("en")
    }
    getWord(e) {
        return Rp(this), Ia[e]
    }
    getWordIndex(e) {
        return Rp(this), Ia.indexOf(e)
    }
}
const ax = new l5()
js.register(ax)
const Tc = { en: ax },
    c5 = "hdnode/5.5.0",
    vo = new F(c5),
    f5 = ce.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    u5 = zt("Bitcoin seed"),
    so = 2147483648
function lx(t) {
    return ((1 << t) - 1) << (8 - t)
}
function d5(t) {
    return (1 << t) - 1
}
function Bl(t) {
    return ut(pe(t), 32)
}
function Lp(t) {
    return ul.encode(ft([t, Er(ai(ai(t)), 0, 4)]))
}
function O0(t) {
    if (t == null) return Tc.en
    if (typeof t == "string") {
        const e = Tc[t]
        return e == null && vo.throwArgumentError("unknown locale", "wordlist", t), e
    }
    return t
}
const Js = {},
    Io = "m/44'/60'/0'/0/0"
class yr {
    constructor(e, r, n, i, s, o, a, l) {
        if ((vo.checkNew(new.target, yr), e !== Js)) throw new Error("HDNode constructor cannot be called directly")
        if (r) {
            const c = new Ns(r)
            X(this, "privateKey", c.privateKey), X(this, "publicKey", c.compressedPublicKey)
        } else X(this, "privateKey", null), X(this, "publicKey", pe(n))
        X(this, "parentFingerprint", i),
            X(this, "fingerprint", Er(ox(ai(this.publicKey)), 0, 4)),
            X(this, "address", Di(this.publicKey)),
            X(this, "chainCode", s),
            X(this, "index", o),
            X(this, "depth", a),
            l == null
                ? (X(this, "mnemonic", null), X(this, "path", null))
                : typeof l == "string"
                ? (X(this, "mnemonic", null), X(this, "path", l))
                : (X(this, "mnemonic", l), X(this, "path", l.path))
    }
    get extendedKey() {
        if (this.depth >= 256) throw new Error("Depth too large!")
        return Lp(
            ft([
                this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
                pe(this.depth),
                this.parentFingerprint,
                ut(pe(this.index), 4),
                this.chainCode,
                this.privateKey != null ? ft(["0x00", this.privateKey]) : this.publicKey,
            ])
        )
    }
    neuter() {
        return new yr(Js, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path)
    }
    _derive(e) {
        if (e > 4294967295) throw new Error("invalid index - " + String(e))
        let r = this.path
        r && (r += "/" + (e & ~so))
        const n = new Uint8Array(37)
        if (e & so) {
            if (!this.privateKey) throw new Error("cannot derive child of neutered node")
            n.set(le(this.privateKey), 1), r && (r += "'")
        } else n.set(le(this.publicKey))
        for (let u = 24; u >= 0; u -= 8) n[33 + (u >> 3)] = (e >> (24 - u)) & 255
        const i = le(tl(Po.sha512, this.chainCode, n)),
            s = i.slice(0, 32),
            o = i.slice(32)
        let a = null,
            l = null
        this.privateKey ? (a = Bl(ce.from(s).add(this.privateKey).mod(f5))) : (l = new Ns(pe(s))._addPoint(this.publicKey))
        let c = r
        const f = this.mnemonic
        return (
            f && (c = Object.freeze({ phrase: f.phrase, path: r, locale: f.locale || "en" })),
            new yr(Js, a, l, this.fingerprint, Bl(o), e, this.depth + 1, c)
        )
    }
    derivePath(e) {
        const r = e.split("/")
        if (r.length === 0 || (r[0] === "m" && this.depth !== 0)) throw new Error("invalid path - " + e)
        r[0] === "m" && r.shift()
        let n = this
        for (let i = 0; i < r.length; i++) {
            const s = r[i]
            if (s.match(/^[0-9]+'$/)) {
                const o = parseInt(s.substring(0, s.length - 1))
                if (o >= so) throw new Error("invalid path index - " + s)
                n = n._derive(so + o)
            } else if (s.match(/^[0-9]+$/)) {
                const o = parseInt(s)
                if (o >= so) throw new Error("invalid path index - " + s)
                n = n._derive(o)
            } else throw new Error("invalid path component - " + s)
        }
        return n
    }
    static _fromSeed(e, r) {
        const n = le(e)
        if (n.length < 16 || n.length > 64) throw new Error("invalid seed")
        const i = le(tl(Po.sha512, u5, n))
        return new yr(Js, Bl(i.slice(0, 32)), null, "0x00000000", Bl(i.slice(32)), 0, 0, r)
    }
    static fromMnemonic(e, r, n) {
        return (n = O0(n)), (e = rf(tf(e, n), n)), yr._fromSeed(cx(e, r), { phrase: e, path: "m", locale: n.locale })
    }
    static fromSeed(e) {
        return yr._fromSeed(e, null)
    }
    static fromExtendedKey(e) {
        const r = ul.decode(e)
        ;(r.length !== 82 || Lp(r.slice(0, 78)) !== e) && vo.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]")
        const n = r[4],
            i = pe(r.slice(5, 9)),
            s = parseInt(pe(r.slice(9, 13)).substring(2), 16),
            o = pe(r.slice(13, 45)),
            a = r.slice(45, 78)
        switch (pe(r.slice(0, 4))) {
            case "0x0488b21e":
            case "0x043587cf":
                return new yr(Js, null, pe(a), i, o, s, n, null)
            case "0x0488ade4":
            case "0x04358394 ":
                if (a[0] !== 0) break
                return new yr(Js, pe(a.slice(1)), null, i, o, s, n, null)
        }
        return vo.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]")
    }
}
function cx(t, e) {
    e || (e = "")
    const r = zt("mnemonic" + e, Dn.NFKD)
    return B0(zt(t, Dn.NFKD), r, 2048, 64, "sha512")
}
function tf(t, e) {
    ;(e = O0(e)), vo.checkNormalize()
    const r = e.split(t)
    if (r.length % 3 !== 0) throw new Error("invalid mnemonic")
    const n = le(new Uint8Array(Math.ceil((11 * r.length) / 8)))
    let i = 0
    for (let c = 0; c < r.length; c++) {
        let f = e.getWordIndex(r[c].normalize("NFKD"))
        if (f === -1) throw new Error("invalid mnemonic")
        for (let u = 0; u < 11; u++) f & (1 << (10 - u)) && (n[i >> 3] |= 1 << (7 - (i % 8))), i++
    }
    const s = (32 * r.length) / 3,
        o = r.length / 3,
        a = lx(o)
    if ((le(ai(n.slice(0, s / 8)))[0] & a) !== (n[n.length - 1] & a)) throw new Error("invalid checksum")
    return pe(n.slice(0, s / 8))
}
function rf(t, e) {
    if (((e = O0(e)), (t = le(t)), t.length % 4 !== 0 || t.length < 16 || t.length > 32)) throw new Error("invalid entropy")
    const r = [0]
    let n = 11
    for (let o = 0; o < t.length; o++)
        n > 8
            ? ((r[r.length - 1] <<= 8), (r[r.length - 1] |= t[o]), (n -= 8))
            : ((r[r.length - 1] <<= n), (r[r.length - 1] |= t[o] >> (8 - n)), r.push(t[o] & d5(8 - n)), (n += 3))
    const i = t.length / 4,
        s = le(ai(t))[0] & lx(i)
    return (r[r.length - 1] <<= i), (r[r.length - 1] |= s >> (8 - i)), e.join(r.map((o) => e.getWord(o)))
}
function h5(t, e) {
    try {
        return tf(t, e), !0
    } catch {}
    return !1
}
function p5(t) {
    return (
        (typeof t != "number" || t < 0 || t >= so || t % 1) && vo.throwArgumentError("invalid account index", "index", t), `m/44'/60'/${t}'/0/0`
    )
}
const g5 = "random/5.5.1",
    hd = new F(g5)
function m5() {
    if (typeof self != "undefined") return self
    if (typeof window != "undefined") return window
    if (typeof global != "undefined") return global
    throw new Error("unable to locate global object")
}
const Dp = m5()
let rc = Dp.crypto || Dp.msCrypto
;(!rc || !rc.getRandomValues) &&
    (hd.warn("WARNING: Missing strong random number source"),
    (rc = {
        getRandomValues: function (t) {
            return hd.throwError("no secure random source avaialble", F.errors.UNSUPPORTED_OPERATION, { operation: "crypto.getRandomValues" })
        },
    }))
function fo(t) {
    ;(t <= 0 || t > 1024 || t % 1 || t != t) && hd.throwArgumentError("invalid length", "length", t)
    const e = new Uint8Array(t)
    return rc.getRandomValues(e), le(e)
}
function fx(t) {
    t = t.slice()
    for (let e = t.length - 1; e > 0; e--) {
        const r = Math.floor(Math.random() * (e + 1)),
            n = t[e]
        ;(t[e] = t[r]), (t[r] = n)
    }
    return t
}
var ux = { exports: {} }
;(function (t, e) {
    ;(function (r) {
        function n(x) {
            return parseInt(x) === x
        }
        function i(x) {
            if (!n(x.length)) return !1
            for (var O = 0; O < x.length; O++) if (!n(x[O]) || x[O] < 0 || x[O] > 255) return !1
            return !0
        }
        function s(x, O) {
            if (x.buffer && ArrayBuffer.isView(x) && x.name === "Uint8Array")
                return O && (x.slice ? (x = x.slice()) : (x = Array.prototype.slice.call(x))), x
            if (Array.isArray(x)) {
                if (!i(x)) throw new Error("Array contains invalid value: " + x)
                return new Uint8Array(x)
            }
            if (n(x.length) && i(x)) return new Uint8Array(x)
            throw new Error("unsupported array-like object")
        }
        function o(x) {
            return new Uint8Array(x)
        }
        function a(x, O, j, L, h) {
            ;(L != null || h != null) && (x.slice ? (x = x.slice(L, h)) : (x = Array.prototype.slice.call(x, L, h))), O.set(x, j)
        }
        var l = (function () {
                function x(j) {
                    var L = [],
                        h = 0
                    for (j = encodeURI(j); h < j.length; ) {
                        var P = j.charCodeAt(h++)
                        P === 37 ? (L.push(parseInt(j.substr(h, 2), 16)), (h += 2)) : L.push(P)
                    }
                    return s(L)
                }
                function O(j) {
                    for (var L = [], h = 0; h < j.length; ) {
                        var P = j[h]
                        P < 128
                            ? (L.push(String.fromCharCode(P)), h++)
                            : P > 191 && P < 224
                            ? (L.push(String.fromCharCode(((P & 31) << 6) | (j[h + 1] & 63))), (h += 2))
                            : (L.push(String.fromCharCode(((P & 15) << 12) | ((j[h + 1] & 63) << 6) | (j[h + 2] & 63))), (h += 3))
                    }
                    return L.join("")
                }
                return { toBytes: x, fromBytes: O }
            })(),
            c = (function () {
                function x(L) {
                    for (var h = [], P = 0; P < L.length; P += 2) h.push(parseInt(L.substr(P, 2), 16))
                    return h
                }
                var O = "0123456789abcdef"
                function j(L) {
                    for (var h = [], P = 0; P < L.length; P++) {
                        var M = L[P]
                        h.push(O[(M & 240) >> 4] + O[M & 15])
                    }
                    return h.join("")
                }
                return { toBytes: x, fromBytes: j }
            })(),
            f = { 16: 10, 24: 12, 32: 14 },
            u = [
                1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197,
                145,
            ],
            p = [
                99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162,
                175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5,
                154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237,
                32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81,
                163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100,
                93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211,
                172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28,
                166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225,
                248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15,
                176, 84, 187, 22,
            ],
            m = [
                82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68,
                196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178,
                118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72,
                80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69,
                6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206,
                240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197,
                137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168,
                51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239,
                160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99,
                85, 33, 12, 125,
            ],
            y = [
                3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241,
                1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645,
                2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686,
                2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740,
                1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446,
                806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613,
                3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293,
                3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264,
                3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944,
                2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663,
                3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474,
                1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118,
                3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866,
                4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718,
                1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934,
                3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935,
                3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028,
                2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816,
                1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932,
                3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344,
                100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745,
                3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602,
                3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649,
                2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986,
            ],
            v = [
                2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391,
                2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041,
                3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080,
                3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109,
                150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806,
                252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793,
                2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499,
                2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545,
                3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800,
                717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647,
                4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645,
                1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245,
                337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405,
                2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034,
                2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696,
                1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098,
                2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022,
                3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856,
                1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411,
                3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494,
                2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776,
                857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045,
                2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505,
                2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766,
            ],
            _ = [
                1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671,
                729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690,
                1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506,
                3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325,
                3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936,
                2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517,
                152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278,
                3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412,
                2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631,
                3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674,
                2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538,
                2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890,
                3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534,
                1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154,
                2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296,
                844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418,
                2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133,
                1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696,
                3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180,
                522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867,
                4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393,
                4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169,
                3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242,
                1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126,
            ],
            C = [
                1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926,
                724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615,
                1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356,
                3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625,
                3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336,
                2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922,
                151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943,
                3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667,
                2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741,
                3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044,
                2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143,
                2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015,
                3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284,
                1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924,
                2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771,
                842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388,
                2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953,
                1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176,
                3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400,
                522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542,
                4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753,
                4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609,
                3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452,
                1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436,
            ],
            B = [
                1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073,
                4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058,
                2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434,
                4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184,
                1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627,
                1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356,
                2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698,
                2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621,
                1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,
                2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415,
                168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529,
                470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380,
                4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747,
                3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860,
                2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585,
                2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698,
                4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182,
                3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889,
                1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845,
                4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075,
                3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476,
                933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775,
                1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627,
                4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890,
            ],
            R = [
                1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181,
                2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101,
                310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456,
                1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459,
                1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122,
                1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276,
                2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387,
                957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868,
                4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703,
                3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017,
                560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394,
                182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349,
                4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309,
                1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222,
                2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419,
                3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799,
                4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672,
                4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380,
                2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656,
                790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517,
                1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127,
                901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891,
                2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780,
                2422494913, 1635502980, 1893020342, 1950903388, 1120974935,
            ],
            U = [
                2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228,
                1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588,
                2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201,
                2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209,
                2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827,
                2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631,
                3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818,
                3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892,
                3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556,
                266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085,
                3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639,
                437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165,
                3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881,
                2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177,
                376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178,
                188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176,
                4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262,
                418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160,
                2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356,
                1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974,
                895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571,
                669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845,
                3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716,
                3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600,
            ],
            D = [
                4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568,
                38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793,
                1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166,
                3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559,
                1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067,
                1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221,
                3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213,
                4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201,
                3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953,
                2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493,
                758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241,
                2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591,
                1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952,
                836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325,
                3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745,
                3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908,
                2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152,
                1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730,
                2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521,
                3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417,
                1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495,
                4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219,
                4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567,
                2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480,
            ],
            Y = [
                0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237,
                1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327,
                3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889,
                3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904,
                3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847,
                226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226,
                2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269,
                3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739,
                1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164,
                395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206,
                437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865,
                2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751,
                3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231,
                1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386,
                2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648,
                4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453,
                3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047,
                1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592,
                1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144,
                2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487,
                504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510,
                1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858,
                1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516,
                3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150,
                2438237621, 2203032232, 2370213795,
            ],
            J = [
                0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807,
                1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937,
                2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859,
                2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569,
                1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330,
                4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336,
                4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824,
                3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514,
                1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339,
                790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694,
                3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369,
                296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296,
                1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226,
                2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976,
                1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403,
                636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929,
                3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590,
                272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799,
                1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242,
                1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696,
                2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630,
                3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239,
                575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486,
                3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200,
                3046200461, 2827177882, 2743944855,
            ],
            te = [
                0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587,
                1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237,
                4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639,
                3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754,
                3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160,
                1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933,
                547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239,
                532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554,
                2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064,
                4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749,
                3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814,
                840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571,
                1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956,
                3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431,
                1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970,
                1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910,
                331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299,
                2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569,
                4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018,
                3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632,
                1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135,
                567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233,
                1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691,
                3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285,
                2377486676, 2594734927, 2544078150,
            ],
            G = [
                0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762,
                1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582,
                2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714,
                1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439,
                1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947,
                2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503,
                3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837,
                923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159,
                3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395,
                2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454,
                213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204,
                4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480,
                2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835,
                2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655,
                1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841,
                425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048,
                2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812,
                1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802,
                585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454,
                3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952,
                292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730,
                1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549,
                3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211,
                718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201,
                1335535747, 1184342925,
            ]
        function de(x) {
            for (var O = [], j = 0; j < x.length; j += 4) O.push((x[j] << 24) | (x[j + 1] << 16) | (x[j + 2] << 8) | x[j + 3])
            return O
        }
        var k = function (x) {
            if (!(this instanceof k)) throw Error("AES must be instanitated with `new`")
            Object.defineProperty(this, "key", { value: s(x, !0) }), this._prepare()
        }
        ;(k.prototype._prepare = function () {
            var x = f[this.key.length]
            if (x == null) throw new Error("invalid key size (must be 16, 24 or 32 bytes)")
            ;(this._Ke = []), (this._Kd = [])
            for (var O = 0; O <= x; O++) this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0])
            for (var j = (x + 1) * 4, L = this.key.length / 4, h = de(this.key), P, O = 0; O < L; O++)
                (P = O >> 2), (this._Ke[P][O % 4] = h[O]), (this._Kd[x - P][O % 4] = h[O])
            for (var M = 0, V = L, z; V < j; ) {
                if (
                    ((z = h[L - 1]),
                    (h[0] ^= (p[(z >> 16) & 255] << 24) ^ (p[(z >> 8) & 255] << 16) ^ (p[z & 255] << 8) ^ p[(z >> 24) & 255] ^ (u[M] << 24)),
                    (M += 1),
                    L != 8)
                )
                    for (var O = 1; O < L; O++) h[O] ^= h[O - 1]
                else {
                    for (var O = 1; O < L / 2; O++) h[O] ^= h[O - 1]
                    ;(z = h[L / 2 - 1]),
                        (h[L / 2] ^= p[z & 255] ^ (p[(z >> 8) & 255] << 8) ^ (p[(z >> 16) & 255] << 16) ^ (p[(z >> 24) & 255] << 24))
                    for (var O = L / 2 + 1; O < L; O++) h[O] ^= h[O - 1]
                }
                for (var O = 0, ee, ne; O < L && V < j; )
                    (ee = V >> 2), (ne = V % 4), (this._Ke[ee][ne] = h[O]), (this._Kd[x - ee][ne] = h[O++]), V++
            }
            for (var ee = 1; ee < x; ee++)
                for (var ne = 0; ne < 4; ne++)
                    (z = this._Kd[ee][ne]), (this._Kd[ee][ne] = Y[(z >> 24) & 255] ^ J[(z >> 16) & 255] ^ te[(z >> 8) & 255] ^ G[z & 255])
        }),
            (k.prototype.encrypt = function (x) {
                if (x.length != 16) throw new Error("invalid plaintext size (must be 16 bytes)")
                for (var O = this._Ke.length - 1, j = [0, 0, 0, 0], L = de(x), h = 0; h < 4; h++) L[h] ^= this._Ke[0][h]
                for (var P = 1; P < O; P++) {
                    for (var h = 0; h < 4; h++)
                        j[h] =
                            y[(L[h] >> 24) & 255] ^
                            v[(L[(h + 1) % 4] >> 16) & 255] ^
                            _[(L[(h + 2) % 4] >> 8) & 255] ^
                            C[L[(h + 3) % 4] & 255] ^
                            this._Ke[P][h]
                    L = j.slice()
                }
                for (var M = o(16), V, h = 0; h < 4; h++)
                    (V = this._Ke[O][h]),
                        (M[4 * h] = (p[(L[h] >> 24) & 255] ^ (V >> 24)) & 255),
                        (M[4 * h + 1] = (p[(L[(h + 1) % 4] >> 16) & 255] ^ (V >> 16)) & 255),
                        (M[4 * h + 2] = (p[(L[(h + 2) % 4] >> 8) & 255] ^ (V >> 8)) & 255),
                        (M[4 * h + 3] = (p[L[(h + 3) % 4] & 255] ^ V) & 255)
                return M
            }),
            (k.prototype.decrypt = function (x) {
                if (x.length != 16) throw new Error("invalid ciphertext size (must be 16 bytes)")
                for (var O = this._Kd.length - 1, j = [0, 0, 0, 0], L = de(x), h = 0; h < 4; h++) L[h] ^= this._Kd[0][h]
                for (var P = 1; P < O; P++) {
                    for (var h = 0; h < 4; h++)
                        j[h] =
                            B[(L[h] >> 24) & 255] ^
                            R[(L[(h + 3) % 4] >> 16) & 255] ^
                            U[(L[(h + 2) % 4] >> 8) & 255] ^
                            D[L[(h + 1) % 4] & 255] ^
                            this._Kd[P][h]
                    L = j.slice()
                }
                for (var M = o(16), V, h = 0; h < 4; h++)
                    (V = this._Kd[O][h]),
                        (M[4 * h] = (m[(L[h] >> 24) & 255] ^ (V >> 24)) & 255),
                        (M[4 * h + 1] = (m[(L[(h + 3) % 4] >> 16) & 255] ^ (V >> 16)) & 255),
                        (M[4 * h + 2] = (m[(L[(h + 2) % 4] >> 8) & 255] ^ (V >> 8)) & 255),
                        (M[4 * h + 3] = (m[L[(h + 1) % 4] & 255] ^ V) & 255)
                return M
            })
        var d = function (x) {
            if (!(this instanceof d)) throw Error("AES must be instanitated with `new`")
            ;(this.description = "Electronic Code Block"), (this.name = "ecb"), (this._aes = new k(x))
        }
        ;(d.prototype.encrypt = function (x) {
            if (((x = s(x)), x.length % 16 !== 0)) throw new Error("invalid plaintext size (must be multiple of 16 bytes)")
            for (var O = o(x.length), j = o(16), L = 0; L < x.length; L += 16) a(x, j, 0, L, L + 16), (j = this._aes.encrypt(j)), a(j, O, L)
            return O
        }),
            (d.prototype.decrypt = function (x) {
                if (((x = s(x)), x.length % 16 !== 0)) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)")
                for (var O = o(x.length), j = o(16), L = 0; L < x.length; L += 16) a(x, j, 0, L, L + 16), (j = this._aes.decrypt(j)), a(j, O, L)
                return O
            })
        var b = function (x, O) {
            if (!(this instanceof b)) throw Error("AES must be instanitated with `new`")
            if (((this.description = "Cipher Block Chaining"), (this.name = "cbc"), !O)) O = o(16)
            else if (O.length != 16) throw new Error("invalid initialation vector size (must be 16 bytes)")
            ;(this._lastCipherblock = s(O, !0)), (this._aes = new k(x))
        }
        ;(b.prototype.encrypt = function (x) {
            if (((x = s(x)), x.length % 16 !== 0)) throw new Error("invalid plaintext size (must be multiple of 16 bytes)")
            for (var O = o(x.length), j = o(16), L = 0; L < x.length; L += 16) {
                a(x, j, 0, L, L + 16)
                for (var h = 0; h < 16; h++) j[h] ^= this._lastCipherblock[h]
                ;(this._lastCipherblock = this._aes.encrypt(j)), a(this._lastCipherblock, O, L)
            }
            return O
        }),
            (b.prototype.decrypt = function (x) {
                if (((x = s(x)), x.length % 16 !== 0)) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)")
                for (var O = o(x.length), j = o(16), L = 0; L < x.length; L += 16) {
                    a(x, j, 0, L, L + 16), (j = this._aes.decrypt(j))
                    for (var h = 0; h < 16; h++) O[L + h] = j[h] ^ this._lastCipherblock[h]
                    a(x, this._lastCipherblock, 0, L, L + 16)
                }
                return O
            })
        var w = function (x, O, j) {
            if (!(this instanceof w)) throw Error("AES must be instanitated with `new`")
            if (((this.description = "Cipher Feedback"), (this.name = "cfb"), !O)) O = o(16)
            else if (O.length != 16) throw new Error("invalid initialation vector size (must be 16 size)")
            j || (j = 1), (this.segmentSize = j), (this._shiftRegister = s(O, !0)), (this._aes = new k(x))
        }
        ;(w.prototype.encrypt = function (x) {
            if (x.length % this.segmentSize != 0) throw new Error("invalid plaintext size (must be segmentSize bytes)")
            for (var O = s(x, !0), j, L = 0; L < O.length; L += this.segmentSize) {
                j = this._aes.encrypt(this._shiftRegister)
                for (var h = 0; h < this.segmentSize; h++) O[L + h] ^= j[h]
                a(this._shiftRegister, this._shiftRegister, 0, this.segmentSize),
                    a(O, this._shiftRegister, 16 - this.segmentSize, L, L + this.segmentSize)
            }
            return O
        }),
            (w.prototype.decrypt = function (x) {
                if (x.length % this.segmentSize != 0) throw new Error("invalid ciphertext size (must be segmentSize bytes)")
                for (var O = s(x, !0), j, L = 0; L < O.length; L += this.segmentSize) {
                    j = this._aes.encrypt(this._shiftRegister)
                    for (var h = 0; h < this.segmentSize; h++) O[L + h] ^= j[h]
                    a(this._shiftRegister, this._shiftRegister, 0, this.segmentSize),
                        a(x, this._shiftRegister, 16 - this.segmentSize, L, L + this.segmentSize)
                }
                return O
            })
        var E = function (x, O) {
            if (!(this instanceof E)) throw Error("AES must be instanitated with `new`")
            if (((this.description = "Output Feedback"), (this.name = "ofb"), !O)) O = o(16)
            else if (O.length != 16) throw new Error("invalid initialation vector size (must be 16 bytes)")
            ;(this._lastPrecipher = s(O, !0)), (this._lastPrecipherIndex = 16), (this._aes = new k(x))
        }
        ;(E.prototype.encrypt = function (x) {
            for (var O = s(x, !0), j = 0; j < O.length; j++)
                this._lastPrecipherIndex === 16 &&
                    ((this._lastPrecipher = this._aes.encrypt(this._lastPrecipher)), (this._lastPrecipherIndex = 0)),
                    (O[j] ^= this._lastPrecipher[this._lastPrecipherIndex++])
            return O
        }),
            (E.prototype.decrypt = E.prototype.encrypt)
        var T = function (x) {
            if (!(this instanceof T)) throw Error("Counter must be instanitated with `new`")
            x !== 0 && !x && (x = 1), typeof x == "number" ? ((this._counter = o(16)), this.setValue(x)) : this.setBytes(x)
        }
        ;(T.prototype.setValue = function (x) {
            if (typeof x != "number" || parseInt(x) != x) throw new Error("invalid counter value (must be an integer)")
            for (var O = 15; O >= 0; --O) (this._counter[O] = x % 256), (x = x >> 8)
        }),
            (T.prototype.setBytes = function (x) {
                if (((x = s(x, !0)), x.length != 16)) throw new Error("invalid counter bytes size (must be 16 bytes)")
                this._counter = x
            }),
            (T.prototype.increment = function () {
                for (var x = 15; x >= 0; x--)
                    if (this._counter[x] === 255) this._counter[x] = 0
                    else {
                        this._counter[x]++
                        break
                    }
            })
        var A = function (x, O) {
            if (!(this instanceof A)) throw Error("AES must be instanitated with `new`")
            ;(this.description = "Counter"),
                (this.name = "ctr"),
                O instanceof T || (O = new T(O)),
                (this._counter = O),
                (this._remainingCounter = null),
                (this._remainingCounterIndex = 16),
                (this._aes = new k(x))
        }
        ;(A.prototype.encrypt = function (x) {
            for (var O = s(x, !0), j = 0; j < O.length; j++)
                this._remainingCounterIndex === 16 &&
                    ((this._remainingCounter = this._aes.encrypt(this._counter._counter)),
                    (this._remainingCounterIndex = 0),
                    this._counter.increment()),
                    (O[j] ^= this._remainingCounter[this._remainingCounterIndex++])
            return O
        }),
            (A.prototype.decrypt = A.prototype.encrypt)
        function $(x) {
            x = s(x, !0)
            var O = 16 - (x.length % 16),
                j = o(x.length + O)
            a(x, j)
            for (var L = x.length; L < j.length; L++) j[L] = O
            return j
        }
        function S(x) {
            if (((x = s(x, !0)), x.length < 16)) throw new Error("PKCS#7 invalid length")
            var O = x[x.length - 1]
            if (O > 16) throw new Error("PKCS#7 padding byte out of range")
            for (var j = x.length - O, L = 0; L < O; L++) if (x[j + L] !== O) throw new Error("PKCS#7 invalid padding byte")
            var h = o(j)
            return a(x, h, 0, 0, j), h
        }
        var g = {
            AES: k,
            Counter: T,
            ModeOfOperation: { ecb: d, cbc: b, cfb: w, ofb: E, ctr: A },
            utils: { hex: c, utf8: l },
            padding: { pkcs7: { pad: $, strip: S } },
            _arrayTest: { coerceArray: s, createArray: o, copyArray: a },
        }
        t.exports = g
    })()
})(ux)
var Sn = ux.exports
const dx = "json-wallets/5.5.0"
function Ps(t) {
    return typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), le(t)
}
function ia(t, e) {
    for (t = String(t); t.length < e; ) t = "0" + t
    return t
}
function M0(t) {
    return typeof t == "string" ? zt(t, Dn.NFKC) : le(t)
}
function Ft(t, e) {
    let r = t
    const n = e.toLowerCase().split("/")
    for (let i = 0; i < n.length; i++) {
        let s = null
        for (const o in r)
            if (o.toLowerCase() === n[i]) {
                s = r[o]
                break
            }
        if (s === null) return null
        r = s
    }
    return r
}
function b5(t) {
    const e = le(t)
    ;(e[6] = (e[6] & 15) | 64), (e[8] = (e[8] & 63) | 128)
    const r = pe(e)
    return [r.substring(2, 10), r.substring(10, 14), r.substring(14, 18), r.substring(18, 22), r.substring(22, 34)].join("-")
}
const x5 = new F(dx)
class v5 extends Hs {
    isCrowdsaleAccount(e) {
        return !!(e && e._isCrowdsaleAccount)
    }
}
function hx(t, e) {
    const r = JSON.parse(t)
    e = M0(e)
    const n = nt(Ft(r, "ethaddr")),
        i = Ps(Ft(r, "encseed"))
    ;(!i || i.length % 16 !== 0) && x5.throwArgumentError("invalid encseed", "json", t)
    const s = le(B0(e, e, 2e3, 32, "sha256")).slice(0, 16),
        o = i.slice(0, 16),
        a = i.slice(16),
        l = new Sn.ModeOfOperation.cbc(s, o),
        c = Sn.padding.pkcs7.strip(le(l.decrypt(a)))
    let f = ""
    for (let m = 0; m < c.length; m++) f += String.fromCharCode(c[m])
    const u = zt(f),
        p = st(u)
    return new v5({ _isCrowdsaleAccount: !0, address: n, privateKey: p })
}
function R0(t) {
    let e = null
    try {
        e = JSON.parse(t)
    } catch {
        return !1
    }
    return e.encseed && e.ethaddr
}
function L0(t) {
    let e = null
    try {
        e = JSON.parse(t)
    } catch {
        return !1
    }
    return !(!e.version || parseInt(e.version) !== e.version || parseInt(e.version) !== 3)
}
function y5(t) {
    if (R0(t))
        try {
            return nt(JSON.parse(t).ethaddr)
        } catch {
            return null
        }
    if (L0(t))
        try {
            return nt(JSON.parse(t).address)
        } catch {
            return null
        }
    return null
}
var px = { exports: {} }
;(function (t, e) {
    ;(function (r) {
        function i(v) {
            const _ = new Uint32Array([
                1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278,
                1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122,
                1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205,
                773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800,
                3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
                1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
            ])
            let C = 1779033703,
                B = 3144134277,
                R = 1013904242,
                U = 2773480762,
                D = 1359893119,
                Y = 2600822924,
                J = 528734635,
                te = 1541459225
            const G = new Uint32Array(64)
            function de(A) {
                let $ = 0,
                    S = A.length
                for (; S >= 64; ) {
                    let g = C,
                        x = B,
                        O = R,
                        j = U,
                        L = D,
                        h = Y,
                        P = J,
                        M = te,
                        V,
                        z,
                        ee,
                        ne,
                        W
                    for (z = 0; z < 16; z++)
                        (ee = $ + z * 4),
                            (G[z] = ((A[ee] & 255) << 24) | ((A[ee + 1] & 255) << 16) | ((A[ee + 2] & 255) << 8) | (A[ee + 3] & 255))
                    for (z = 16; z < 64; z++)
                        (V = G[z - 2]),
                            (ne = ((V >>> 17) | (V << (32 - 17))) ^ ((V >>> 19) | (V << (32 - 19))) ^ (V >>> 10)),
                            (V = G[z - 15]),
                            (W = ((V >>> 7) | (V << (32 - 7))) ^ ((V >>> 18) | (V << (32 - 18))) ^ (V >>> 3)),
                            (G[z] = (((ne + G[z - 7]) | 0) + ((W + G[z - 16]) | 0)) | 0)
                    for (z = 0; z < 64; z++)
                        (ne =
                            ((((((L >>> 6) | (L << (32 - 6))) ^ ((L >>> 11) | (L << (32 - 11))) ^ ((L >>> 25) | (L << (32 - 25)))) +
                                ((L & h) ^ (~L & P))) |
                                0) +
                                ((M + ((_[z] + G[z]) | 0)) | 0)) |
                            0),
                            (W =
                                ((((g >>> 2) | (g << (32 - 2))) ^ ((g >>> 13) | (g << (32 - 13))) ^ ((g >>> 22) | (g << (32 - 22)))) +
                                    ((g & x) ^ (g & O) ^ (x & O))) |
                                0),
                            (M = P),
                            (P = h),
                            (h = L),
                            (L = (j + ne) | 0),
                            (j = O),
                            (O = x),
                            (x = g),
                            (g = (ne + W) | 0)
                    ;(C = (C + g) | 0),
                        (B = (B + x) | 0),
                        (R = (R + O) | 0),
                        (U = (U + j) | 0),
                        (D = (D + L) | 0),
                        (Y = (Y + h) | 0),
                        (J = (J + P) | 0),
                        (te = (te + M) | 0),
                        ($ += 64),
                        (S -= 64)
                }
            }
            de(v)
            let k,
                d = v.length % 64,
                b = (v.length / 536870912) | 0,
                w = v.length << 3,
                E = d < 56 ? 56 : 120,
                T = v.slice(v.length - d, v.length)
            for (T.push(128), k = d + 1; k < E; k++) T.push(0)
            return (
                T.push((b >>> 24) & 255),
                T.push((b >>> 16) & 255),
                T.push((b >>> 8) & 255),
                T.push((b >>> 0) & 255),
                T.push((w >>> 24) & 255),
                T.push((w >>> 16) & 255),
                T.push((w >>> 8) & 255),
                T.push((w >>> 0) & 255),
                de(T),
                [
                    (C >>> 24) & 255,
                    (C >>> 16) & 255,
                    (C >>> 8) & 255,
                    (C >>> 0) & 255,
                    (B >>> 24) & 255,
                    (B >>> 16) & 255,
                    (B >>> 8) & 255,
                    (B >>> 0) & 255,
                    (R >>> 24) & 255,
                    (R >>> 16) & 255,
                    (R >>> 8) & 255,
                    (R >>> 0) & 255,
                    (U >>> 24) & 255,
                    (U >>> 16) & 255,
                    (U >>> 8) & 255,
                    (U >>> 0) & 255,
                    (D >>> 24) & 255,
                    (D >>> 16) & 255,
                    (D >>> 8) & 255,
                    (D >>> 0) & 255,
                    (Y >>> 24) & 255,
                    (Y >>> 16) & 255,
                    (Y >>> 8) & 255,
                    (Y >>> 0) & 255,
                    (J >>> 24) & 255,
                    (J >>> 16) & 255,
                    (J >>> 8) & 255,
                    (J >>> 0) & 255,
                    (te >>> 24) & 255,
                    (te >>> 16) & 255,
                    (te >>> 8) & 255,
                    (te >>> 0) & 255,
                ]
            )
        }
        function s(v, _, C) {
            v = v.length <= 64 ? v : i(v)
            const B = 64 + _.length + 4,
                R = new Array(B),
                U = new Array(64)
            let D,
                Y = []
            for (D = 0; D < 64; D++) R[D] = 54
            for (D = 0; D < v.length; D++) R[D] ^= v[D]
            for (D = 0; D < _.length; D++) R[64 + D] = _[D]
            for (D = B - 4; D < B; D++) R[D] = 0
            for (D = 0; D < 64; D++) U[D] = 92
            for (D = 0; D < v.length; D++) U[D] ^= v[D]
            function J() {
                for (let te = B - 1; te >= B - 4; te--) {
                    if ((R[te]++, R[te] <= 255)) return
                    R[te] = 0
                }
            }
            for (; C >= 32; ) J(), (Y = Y.concat(i(U.concat(i(R))))), (C -= 32)
            return C > 0 && (J(), (Y = Y.concat(i(U.concat(i(R))).slice(0, C)))), Y
        }
        function o(v, _, C, B, R) {
            let U
            for (f(v, (2 * C - 1) * 16, R, 0, 16), U = 0; U < 2 * C; U++) c(v, U * 16, R, 16), l(R, B), f(R, 0, v, _ + U * 16, 16)
            for (U = 0; U < C; U++) f(v, _ + U * 2 * 16, v, U * 16, 16)
            for (U = 0; U < C; U++) f(v, _ + (U * 2 + 1) * 16, v, (U + C) * 16, 16)
        }
        function a(v, _) {
            return (v << _) | (v >>> (32 - _))
        }
        function l(v, _) {
            f(v, 0, _, 0, 16)
            for (let C = 8; C > 0; C -= 2)
                (_[4] ^= a(_[0] + _[12], 7)),
                    (_[8] ^= a(_[4] + _[0], 9)),
                    (_[12] ^= a(_[8] + _[4], 13)),
                    (_[0] ^= a(_[12] + _[8], 18)),
                    (_[9] ^= a(_[5] + _[1], 7)),
                    (_[13] ^= a(_[9] + _[5], 9)),
                    (_[1] ^= a(_[13] + _[9], 13)),
                    (_[5] ^= a(_[1] + _[13], 18)),
                    (_[14] ^= a(_[10] + _[6], 7)),
                    (_[2] ^= a(_[14] + _[10], 9)),
                    (_[6] ^= a(_[2] + _[14], 13)),
                    (_[10] ^= a(_[6] + _[2], 18)),
                    (_[3] ^= a(_[15] + _[11], 7)),
                    (_[7] ^= a(_[3] + _[15], 9)),
                    (_[11] ^= a(_[7] + _[3], 13)),
                    (_[15] ^= a(_[11] + _[7], 18)),
                    (_[1] ^= a(_[0] + _[3], 7)),
                    (_[2] ^= a(_[1] + _[0], 9)),
                    (_[3] ^= a(_[2] + _[1], 13)),
                    (_[0] ^= a(_[3] + _[2], 18)),
                    (_[6] ^= a(_[5] + _[4], 7)),
                    (_[7] ^= a(_[6] + _[5], 9)),
                    (_[4] ^= a(_[7] + _[6], 13)),
                    (_[5] ^= a(_[4] + _[7], 18)),
                    (_[11] ^= a(_[10] + _[9], 7)),
                    (_[8] ^= a(_[11] + _[10], 9)),
                    (_[9] ^= a(_[8] + _[11], 13)),
                    (_[10] ^= a(_[9] + _[8], 18)),
                    (_[12] ^= a(_[15] + _[14], 7)),
                    (_[13] ^= a(_[12] + _[15], 9)),
                    (_[14] ^= a(_[13] + _[12], 13)),
                    (_[15] ^= a(_[14] + _[13], 18))
            for (let C = 0; C < 16; ++C) v[C] += _[C]
        }
        function c(v, _, C, B) {
            for (let R = 0; R < B; R++) C[R] ^= v[_ + R]
        }
        function f(v, _, C, B, R) {
            for (; R--; ) C[B++] = v[_++]
        }
        function u(v) {
            if (!v || typeof v.length != "number") return !1
            for (let _ = 0; _ < v.length; _++) {
                const C = v[_]
                if (typeof C != "number" || C % 1 || C < 0 || C >= 256) return !1
            }
            return !0
        }
        function p(v, _) {
            if (typeof v != "number" || v % 1) throw new Error("invalid " + _)
            return v
        }
        function m(v, _, C, B, R, U, D) {
            if (((C = p(C, "N")), (B = p(B, "r")), (R = p(R, "p")), (U = p(U, "dkLen")), C === 0 || (C & (C - 1)) !== 0))
                throw new Error("N must be power of 2")
            if (C > 2147483647 / 128 / B) throw new Error("N too large")
            if (B > 2147483647 / 128 / R) throw new Error("r too large")
            if (!u(v)) throw new Error("password must be an array or buffer")
            if (((v = Array.prototype.slice.call(v)), !u(_))) throw new Error("salt must be an array or buffer")
            _ = Array.prototype.slice.call(_)
            let Y = s(v, _, R * 128 * B)
            const J = new Uint32Array(R * 32 * B)
            for (let L = 0; L < J.length; L++) {
                const h = L * 4
                J[L] = ((Y[h + 3] & 255) << 24) | ((Y[h + 2] & 255) << 16) | ((Y[h + 1] & 255) << 8) | ((Y[h + 0] & 255) << 0)
            }
            const te = new Uint32Array(64 * B),
                G = new Uint32Array(32 * B * C),
                de = 32 * B,
                k = new Uint32Array(16),
                d = new Uint32Array(16),
                b = R * C * 2
            let w = 0,
                E = null,
                T = !1,
                A = 0,
                $ = 0,
                S,
                g
            const x = D ? parseInt(1e3 / B) : 4294967295,
                O = typeof setImmediate != "undefined" ? setImmediate : setTimeout,
                j = function () {
                    if (T) return D(new Error("cancelled"), w / b)
                    let L
                    switch (A) {
                        case 0:
                            ;(g = $ * 32 * B), f(J, g, te, 0, de), (A = 1), (S = 0)
                        case 1:
                            ;(L = C - S), L > x && (L = x)
                            for (let P = 0; P < L; P++) f(te, 0, G, (S + P) * de, de), o(te, de, B, k, d)
                            if (((S += L), (w += L), D)) {
                                const P = parseInt((1e3 * w) / b)
                                if (P !== E) {
                                    if (((T = D(null, w / b)), T)) break
                                    E = P
                                }
                            }
                            if (S < C) break
                            ;(S = 0), (A = 2)
                        case 2:
                            ;(L = C - S), L > x && (L = x)
                            for (let P = 0; P < L; P++) {
                                const M = (2 * B - 1) * 16,
                                    V = te[M] & (C - 1)
                                c(G, V * de, te, de), o(te, de, B, k, d)
                            }
                            if (((S += L), (w += L), D)) {
                                const P = parseInt((1e3 * w) / b)
                                if (P !== E) {
                                    if (((T = D(null, w / b)), T)) break
                                    E = P
                                }
                            }
                            if (S < C) break
                            if ((f(te, 0, J, g, de), $++, $ < R)) {
                                A = 0
                                break
                            }
                            Y = []
                            for (let P = 0; P < J.length; P++)
                                Y.push((J[P] >> 0) & 255), Y.push((J[P] >> 8) & 255), Y.push((J[P] >> 16) & 255), Y.push((J[P] >> 24) & 255)
                            const h = s(v, Y, U)
                            return D && D(null, 1, h), h
                    }
                    D && O(j)
                }
            if (!D)
                for (;;) {
                    const L = j()
                    if (L != null) return L
                }
            j()
        }
        const y = {
            scrypt: function (v, _, C, B, R, U, D) {
                return new Promise(function (Y, J) {
                    let te = 0
                    D && D(0),
                        m(v, _, C, B, R, U, function (G, de, k) {
                            if (G) J(G)
                            else if (k) D && te !== 1 && D(1), Y(new Uint8Array(k))
                            else if (D && de !== te) return (te = de), D(de)
                        })
                })
            },
            syncScrypt: function (v, _, C, B, R, U) {
                return new Uint8Array(m(v, _, C, B, R, U))
            },
        }
        t.exports = y
    })()
})(px)
var D0 = px.exports,
    _5 =
        (globalThis && globalThis.__awaiter) ||
        function (t, e, r, n) {
            function i(s) {
                return s instanceof r
                    ? s
                    : new r(function (o) {
                          o(s)
                      })
            }
            return new (r || (r = Promise))(function (s, o) {
                function a(f) {
                    try {
                        c(n.next(f))
                    } catch (u) {
                        o(u)
                    }
                }
                function l(f) {
                    try {
                        c(n.throw(f))
                    } catch (u) {
                        o(u)
                    }
                }
                function c(f) {
                    f.done ? s(f.value) : i(f.value).then(a, l)
                }
                c((n = n.apply(t, e || [])).next())
            })
        }
const pd = new F(dx)
function Fp(t) {
    return t != null && t.mnemonic && t.mnemonic.phrase
}
class w5 extends Hs {
    isKeystoreAccount(e) {
        return !!(e && e._isKeystoreAccount)
    }
}
function E5(t, e, r) {
    if (Ft(t, "crypto/cipher") === "aes-128-ctr") {
        const i = Ps(Ft(t, "crypto/cipherparams/iv")),
            s = new Sn.Counter(i),
            o = new Sn.ModeOfOperation.ctr(e, s)
        return le(o.decrypt(r))
    }
    return null
}
function gx(t, e) {
    const r = Ps(Ft(t, "crypto/ciphertext"))
    if (pe(st(ft([e.slice(16, 32), r]))).substring(2) !== Ft(t, "crypto/mac").toLowerCase()) throw new Error("invalid password")
    const i = E5(t, e.slice(0, 16), r)
    i || pd.throwError("unsupported cipher", F.errors.UNSUPPORTED_OPERATION, { operation: "decrypt" })
    const s = e.slice(32, 64),
        o = Di(i)
    if (t.address) {
        let l = t.address.toLowerCase()
        if ((l.substring(0, 2) !== "0x" && (l = "0x" + l), nt(l) !== o)) throw new Error("address mismatch")
    }
    const a = { _isKeystoreAccount: !0, address: o, privateKey: pe(i) }
    if (Ft(t, "x-ethers/version") === "0.1") {
        const l = Ps(Ft(t, "x-ethers/mnemonicCiphertext")),
            c = Ps(Ft(t, "x-ethers/mnemonicCounter")),
            f = new Sn.Counter(c),
            u = new Sn.ModeOfOperation.ctr(s, f),
            p = Ft(t, "x-ethers/path") || Io,
            m = Ft(t, "x-ethers/locale") || "en",
            y = le(u.decrypt(l))
        try {
            const v = rf(y, m),
                _ = yr.fromMnemonic(v, null, m).derivePath(p)
            if (_.privateKey != a.privateKey) throw new Error("mnemonic mismatch")
            a.mnemonic = _.mnemonic
        } catch (v) {
            if (v.code !== F.errors.INVALID_ARGUMENT || v.argument !== "wordlist") throw v
        }
    }
    return new w5(a)
}
function mx(t, e, r, n, i) {
    return le(B0(t, e, r, n, i))
}
function S5(t, e, r, n, i) {
    return Promise.resolve(mx(t, e, r, n, i))
}
function bx(t, e, r, n, i) {
    const s = M0(e),
        o = Ft(t, "crypto/kdf")
    if (o && typeof o == "string") {
        const a = function (l, c) {
            return pd.throwArgumentError("invalid key-derivation function parameters", l, c)
        }
        if (o.toLowerCase() === "scrypt") {
            const l = Ps(Ft(t, "crypto/kdfparams/salt")),
                c = parseInt(Ft(t, "crypto/kdfparams/n")),
                f = parseInt(Ft(t, "crypto/kdfparams/r")),
                u = parseInt(Ft(t, "crypto/kdfparams/p"))
            ;(!c || !f || !u) && a("kdf", o), (c & (c - 1)) !== 0 && a("N", c)
            const p = parseInt(Ft(t, "crypto/kdfparams/dklen"))
            return p !== 32 && a("dklen", p), n(s, l, c, f, u, 64, i)
        } else if (o.toLowerCase() === "pbkdf2") {
            const l = Ps(Ft(t, "crypto/kdfparams/salt"))
            let c = null
            const f = Ft(t, "crypto/kdfparams/prf")
            f === "hmac-sha256" ? (c = "sha256") : f === "hmac-sha512" ? (c = "sha512") : a("prf", f)
            const u = parseInt(Ft(t, "crypto/kdfparams/c")),
                p = parseInt(Ft(t, "crypto/kdfparams/dklen"))
            return p !== 32 && a("dklen", p), r(s, l, u, p, c)
        }
    }
    return pd.throwArgumentError("unsupported key-derivation function", "kdf", o)
}
function A5(t, e) {
    const r = JSON.parse(t),
        n = bx(r, e, mx, D0.syncScrypt)
    return gx(r, n)
}
function T5(t, e, r) {
    return _5(this, void 0, void 0, function* () {
        const n = JSON.parse(t),
            i = yield bx(n, e, S5, D0.scrypt, r)
        return gx(n, i)
    })
}
function C5(t, e, r, n) {
    try {
        if (nt(t.address) !== Di(t.privateKey)) throw new Error("address/privateKey mismatch")
        if (Fp(t)) {
            const _ = t.mnemonic
            if (yr.fromMnemonic(_.phrase, null, _.locale).derivePath(_.path || Io).privateKey != t.privateKey)
                throw new Error("mnemonic mismatch")
        }
    } catch (_) {
        return Promise.reject(_)
    }
    typeof r == "function" && !n && ((n = r), (r = {})), r || (r = {})
    const i = le(t.privateKey),
        s = M0(e)
    let o = null,
        a = null,
        l = null
    if (Fp(t)) {
        const _ = t.mnemonic
        ;(o = le(tf(_.phrase, _.locale || "en"))), (a = _.path || Io), (l = _.locale || "en")
    }
    let c = r.client
    c || (c = "ethers.js")
    let f = null
    r.salt ? (f = le(r.salt)) : (f = fo(32))
    let u = null
    if (r.iv) {
        if (((u = le(r.iv)), u.length !== 16)) throw new Error("invalid iv")
    } else u = fo(16)
    let p = null
    if (r.uuid) {
        if (((p = le(r.uuid)), p.length !== 16)) throw new Error("invalid uuid")
    } else p = fo(16)
    let m = 1 << 17,
        y = 8,
        v = 1
    return (
        r.scrypt && (r.scrypt.N && (m = r.scrypt.N), r.scrypt.r && (y = r.scrypt.r), r.scrypt.p && (v = r.scrypt.p)),
        D0.scrypt(s, f, m, y, v, 64, n).then((_) => {
            _ = le(_)
            const C = _.slice(0, 16),
                B = _.slice(16, 32),
                R = _.slice(32, 64),
                U = new Sn.Counter(u),
                D = new Sn.ModeOfOperation.ctr(C, U),
                Y = le(D.encrypt(i)),
                J = st(ft([B, Y])),
                te = {
                    address: t.address.substring(2).toLowerCase(),
                    id: b5(p),
                    version: 3,
                    Crypto: {
                        cipher: "aes-128-ctr",
                        cipherparams: { iv: pe(u).substring(2) },
                        ciphertext: pe(Y).substring(2),
                        kdf: "scrypt",
                        kdfparams: { salt: pe(f).substring(2), n: m, dklen: 32, p: v, r: y },
                        mac: J.substring(2),
                    },
                }
            if (o) {
                const G = fo(16),
                    de = new Sn.Counter(G),
                    k = new Sn.ModeOfOperation.ctr(R, de),
                    d = le(k.encrypt(o)),
                    b = new Date(),
                    w =
                        b.getUTCFullYear() +
                        "-" +
                        ia(b.getUTCMonth() + 1, 2) +
                        "-" +
                        ia(b.getUTCDate(), 2) +
                        "T" +
                        ia(b.getUTCHours(), 2) +
                        "-" +
                        ia(b.getUTCMinutes(), 2) +
                        "-" +
                        ia(b.getUTCSeconds(), 2) +
                        ".0Z"
                te["x-ethers"] = {
                    client: c,
                    gethFilename: "UTC--" + w + "--" + te.address,
                    mnemonicCounter: pe(G).substring(2),
                    mnemonicCiphertext: pe(d).substring(2),
                    path: a,
                    locale: l,
                    version: "0.1",
                }
            }
            return JSON.stringify(te)
        })
    )
}
function k5(t, e, r) {
    if (R0(t)) {
        r && r(0)
        const n = hx(t, e)
        return r && r(1), Promise.resolve(n)
    }
    return L0(t) ? T5(t, e, r) : Promise.reject(new Error("invalid JSON wallet"))
}
function N5(t, e) {
    if (R0(t)) return hx(t, e)
    if (L0(t)) return A5(t, e)
    throw new Error("invalid JSON wallet")
}
const P5 = "wallet/5.5.0"
var Vp =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const ps = new F(P5)
function I5(t) {
    return t != null && Le(t.privateKey, 32) && t.address != null
}
function $5(t) {
    const e = t.mnemonic
    return e && e.phrase
}
class Jn extends di {
    constructor(e, r) {
        ps.checkNew(new.target, Jn)
        super()
        if (I5(e)) {
            const n = new Ns(e.privateKey)
            if (
                (X(this, "_signingKey", () => n),
                X(this, "address", Di(this.publicKey)),
                this.address !== nt(e.address) && ps.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"),
                $5(e))
            ) {
                const i = e.mnemonic
                X(this, "_mnemonic", () => ({ phrase: i.phrase, path: i.path || Io, locale: i.locale || "en" }))
                const s = this.mnemonic,
                    o = yr.fromMnemonic(s.phrase, null, s.locale).derivePath(s.path)
                Di(o.privateKey) !== this.address && ps.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]")
            } else X(this, "_mnemonic", () => null)
        } else {
            if (Ns.isSigningKey(e))
                e.curve !== "secp256k1" && ps.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"),
                    X(this, "_signingKey", () => e)
            else {
                typeof e == "string" && e.match(/^[0-9a-f]*$/i) && e.length === 64 && (e = "0x" + e)
                const n = new Ns(e)
                X(this, "_signingKey", () => n)
            }
            X(this, "_mnemonic", () => null), X(this, "address", Di(this.publicKey))
        }
        r && !qi.isProvider(r) && ps.throwArgumentError("invalid provider", "provider", r), X(this, "provider", r || null)
    }
    get mnemonic() {
        return this._mnemonic()
    }
    get privateKey() {
        return this._signingKey().privateKey
    }
    get publicKey() {
        return this._signingKey().publicKey
    }
    getAddress() {
        return Promise.resolve(this.address)
    }
    connect(e) {
        return new Jn(this, e)
    }
    signTransaction(e) {
        return Dt(e).then((r) => {
            r.from != null &&
                (nt(r.from) !== this.address && ps.throwArgumentError("transaction from address mismatch", "transaction.from", e.from),
                delete r.from)
            const n = this._signingKey().signDigest(st(dd(r)))
            return dd(r, n)
        })
    }
    signMessage(e) {
        return Vp(this, void 0, void 0, function* () {
            return nd(this._signingKey().signDigest(T0(e)))
        })
    }
    _signTypedData(e, r, n) {
        return Vp(this, void 0, void 0, function* () {
            const i = yield tr.resolveNames(
                e,
                r,
                n,
                (s) => (
                    this.provider == null &&
                        ps.throwError("cannot resolve ENS names without a provider", F.errors.UNSUPPORTED_OPERATION, {
                            operation: "resolveName",
                            value: s,
                        }),
                    this.provider.resolveName(s)
                )
            )
            return nd(this._signingKey().signDigest(tr.hash(i.domain, r, i.value)))
        })
    }
    encrypt(e, r, n) {
        if ((typeof r == "function" && !n && ((n = r), (r = {})), n && typeof n != "function")) throw new Error("invalid callback")
        return r || (r = {}), C5(this, e, r, n)
    }
    static createRandom(e) {
        let r = fo(16)
        e || (e = {}), e.extraEntropy && (r = le(Er(st(ft([r, e.extraEntropy])), 0, 16)))
        const n = rf(r, e.locale)
        return Jn.fromMnemonic(n, e.path, e.locale)
    }
    static fromEncryptedJson(e, r, n) {
        return k5(e, r, n).then((i) => new Jn(i))
    }
    static fromEncryptedJsonSync(e, r) {
        return new Jn(N5(e, r))
    }
    static fromMnemonic(e, r, n) {
        return r || (r = Io), new Jn(yr.fromMnemonic(e, null, n).derivePath(r))
    }
}
function B5(t, e) {
    return fl(T0(t), e)
}
function O5(t, e, r, n) {
    return fl(tr.hash(t, e, r), n)
}
const M5 = "networks/5.5.2",
    Up = new F(M5)
function R5(t) {
    return t && typeof t.renetwork == "function"
}
function yo(t) {
    const e = function (r, n) {
        n == null && (n = {})
        const i = []
        if (r.InfuraProvider)
            try {
                i.push(new r.InfuraProvider(t, n.infura))
            } catch {}
        if (r.EtherscanProvider)
            try {
                i.push(new r.EtherscanProvider(t, n.etherscan))
            } catch {}
        if (r.AlchemyProvider)
            try {
                i.push(new r.AlchemyProvider(t, n.alchemy))
            } catch {}
        if (r.PocketProvider) {
            const s = ["goerli", "ropsten", "rinkeby"]
            try {
                const o = new r.PocketProvider(t)
                o.network && s.indexOf(o.network.name) === -1 && i.push(o)
            } catch {}
        }
        if (r.CloudflareProvider)
            try {
                i.push(new r.CloudflareProvider(t))
            } catch {}
        if (i.length === 0) return null
        if (r.FallbackProvider) {
            let s = 1
            return n.quorum != null ? (s = n.quorum) : t === "homestead" && (s = 2), new r.FallbackProvider(i, s)
        }
        return i[0]
    }
    return (
        (e.renetwork = function (r) {
            return yo(r)
        }),
        e
    )
}
function Cc(t, e) {
    const r = function (n, i) {
        return n.JsonRpcProvider ? new n.JsonRpcProvider(t, e) : null
    }
    return (
        (r.renetwork = function (n) {
            return Cc(t, n)
        }),
        r
    )
}
const Hp = { chainId: 1, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "homestead", _defaultProvider: yo("homestead") },
    qp = { chainId: 3, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "ropsten", _defaultProvider: yo("ropsten") },
    jp = { chainId: 63, name: "classicMordor", _defaultProvider: Cc("https://www.ethercluster.com/mordor", "classicMordor") },
    Ol = {
        unspecified: { chainId: 0, name: "unspecified" },
        homestead: Hp,
        mainnet: Hp,
        morden: { chainId: 2, name: "morden" },
        ropsten: qp,
        testnet: qp,
        rinkeby: { chainId: 4, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "rinkeby", _defaultProvider: yo("rinkeby") },
        kovan: { chainId: 42, name: "kovan", _defaultProvider: yo("kovan") },
        goerli: { chainId: 5, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "goerli", _defaultProvider: yo("goerli") },
        kintsugi: { chainId: 1337702, name: "kintsugi" },
        classic: { chainId: 61, name: "classic", _defaultProvider: Cc("https://www.ethercluster.com/etc", "classic") },
        classicMorden: { chainId: 62, name: "classicMorden" },
        classicMordor: jp,
        classicTestnet: jp,
        classicKotti: { chainId: 6, name: "classicKotti", _defaultProvider: Cc("https://www.ethercluster.com/kotti", "classicKotti") },
        xdai: { chainId: 100, name: "xdai" },
        matic: { chainId: 137, name: "matic" },
        maticmum: { chainId: 80001, name: "maticmum" },
        optimism: { chainId: 10, name: "optimism" },
        "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
        "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
        arbitrum: { chainId: 42161, name: "arbitrum" },
        "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
        bnb: { chainId: 56, name: "bnb" },
        bnbt: { chainId: 97, name: "bnbt" },
    }
function F0(t) {
    if (t == null) return null
    if (typeof t == "number") {
        for (const n in Ol) {
            const i = Ol[n]
            if (i.chainId === t)
                return { name: i.name, chainId: i.chainId, ensAddress: i.ensAddress || null, _defaultProvider: i._defaultProvider || null }
        }
        return { chainId: t, name: "unknown" }
    }
    if (typeof t == "string") {
        const n = Ol[t]
        return n == null ? null : { name: n.name, chainId: n.chainId, ensAddress: n.ensAddress, _defaultProvider: n._defaultProvider || null }
    }
    const e = Ol[t.name]
    if (!e) return typeof t.chainId != "number" && Up.throwArgumentError("invalid network chainId", "network", t), t
    t.chainId !== 0 && t.chainId !== e.chainId && Up.throwArgumentError("network chainId mismatch", "network", t)
    let r = t._defaultProvider || null
    return (
        r == null && e._defaultProvider && (R5(e._defaultProvider) ? (r = e._defaultProvider.renetwork(t)) : (r = e._defaultProvider)),
        { name: t.name, chainId: e.chainId, ensAddress: t.ensAddress || e.ensAddress || null, _defaultProvider: r }
    )
}
function xx(t) {
    t = atob(t)
    const e = []
    for (let r = 0; r < t.length; r++) e.push(t.charCodeAt(r))
    return le(e)
}
function vx(t) {
    t = le(t)
    let e = ""
    for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r])
    return btoa(e)
}
var L5 = Object.freeze({ __proto__: null, [Symbol.toStringTag]: "Module", decode: xx, encode: vx })
const D5 = "web/5.5.1"
var F5 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
function V5(t, e) {
    return F5(this, void 0, void 0, function* () {
        e == null && (e = {})
        const r = { method: e.method || "GET", headers: e.headers || {}, body: e.body || void 0 }
        e.skipFetchSetup !== !0 &&
            ((r.mode = "cors"), (r.cache = "no-cache"), (r.credentials = "same-origin"), (r.redirect = "follow"), (r.referrer = "client"))
        const n = yield fetch(t, r),
            i = yield n.arrayBuffer(),
            s = {}
        return (
            n.headers.forEach
                ? n.headers.forEach((o, a) => {
                      s[a.toLowerCase()] = o
                  })
                : n.headers.keys().forEach((o) => {
                      s[o.toLowerCase()] = n.headers.get(o)
                  }),
            { headers: s, statusCode: n.status, statusMessage: n.statusText, body: le(new Uint8Array(i)) }
        )
    })
}
var U5 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const en = new F(D5)
function zp(t) {
    return new Promise((e) => {
        setTimeout(e, t)
    })
}
function Ai(t, e) {
    if (t == null) return null
    if (typeof t == "string") return t
    if (ol(t)) {
        if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json"))
            try {
                return Xi(t)
            } catch {}
        return pe(t)
    }
    return t
}
function yx(t, e, r) {
    const n = typeof t == "object" && t.throttleLimit != null ? t.throttleLimit : 12
    en.assertArgument(n > 0 && n % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", n)
    const i = typeof t == "object" ? t.throttleCallback : null,
        s = typeof t == "object" && typeof t.throttleSlotInterval == "number" ? t.throttleSlotInterval : 100
    en.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s)
    const o = {}
    let a = null
    const l = { method: "GET" }
    let c = !1,
        f = 2 * 60 * 1e3
    if (typeof t == "string") a = t
    else if (typeof t == "object") {
        if (
            ((t == null || t.url == null) && en.throwArgumentError("missing URL", "connection.url", t),
            (a = t.url),
            typeof t.timeout == "number" && t.timeout > 0 && (f = t.timeout),
            t.headers)
        )
            for (const _ in t.headers)
                (o[_.toLowerCase()] = { key: _, value: String(t.headers[_]) }),
                    ["if-none-match", "if-modified-since"].indexOf(_.toLowerCase()) >= 0 && (c = !0)
        if (((l.allowGzip = !!t.allowGzip), t.user != null && t.password != null)) {
            a.substring(0, 6) !== "https:" &&
                t.allowInsecureAuthentication !== !0 &&
                en.throwError("basic authentication requires a secure https url", F.errors.INVALID_ARGUMENT, {
                    argument: "url",
                    url: a,
                    user: t.user,
                    password: "[REDACTED]",
                })
            const _ = t.user + ":" + t.password
            o.authorization = { key: "Authorization", value: "Basic " + vx(zt(_)) }
        }
    }
    const u = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i"),
        p = a ? a.match(u) : null
    if (p)
        try {
            const _ = { statusCode: 200, statusMessage: "OK", headers: { "content-type": p[1] }, body: xx(p[2]) }
            let C = _.body
            return r && (C = r(_.body, _)), Promise.resolve(C)
        } catch (_) {
            en.throwError("processing response error", F.errors.SERVER_ERROR, {
                body: Ai(p[1], p[2]),
                error: _,
                requestBody: null,
                requestMethod: "GET",
                url: a,
            })
        }
    e &&
        ((l.method = "POST"),
        (l.body = e),
        o["content-type"] == null && (o["content-type"] = { key: "Content-Type", value: "application/octet-stream" }),
        o["content-length"] == null && (o["content-length"] = { key: "Content-Length", value: String(e.length) }))
    const m = {}
    Object.keys(o).forEach((_) => {
        const C = o[_]
        m[C.key] = C.value
    }),
        (l.headers = m)
    const y = (function () {
            let _ = null
            return {
                promise: new Promise(function (R, U) {
                    f &&
                        (_ = setTimeout(() => {
                            _ != null &&
                                ((_ = null),
                                U(
                                    en.makeError("timeout", F.errors.TIMEOUT, {
                                        requestBody: Ai(l.body, m["content-type"]),
                                        requestMethod: l.method,
                                        timeout: f,
                                        url: a,
                                    })
                                ))
                        }, f))
                }),
                cancel: function () {
                    _ != null && (clearTimeout(_), (_ = null))
                },
            }
        })(),
        v = (function () {
            return U5(this, void 0, void 0, function* () {
                for (let _ = 0; _ < n; _++) {
                    let C = null
                    try {
                        if (((C = yield V5(a, l)), _ < n)) {
                            if (C.statusCode === 301 || C.statusCode === 302) {
                                const R = C.headers.location || ""
                                if (l.method === "GET" && R.match(/^https:/)) {
                                    a = C.headers.location
                                    continue
                                }
                            } else if (C.statusCode === 429) {
                                let R = !0
                                if ((i && (R = yield i(_, a)), R)) {
                                    let U = 0
                                    const D = C.headers["retry-after"]
                                    typeof D == "string" && D.match(/^[1-9][0-9]*$/)
                                        ? (U = parseInt(D) * 1e3)
                                        : (U = s * parseInt(String(Math.random() * Math.pow(2, _)))),
                                        yield zp(U)
                                    continue
                                }
                            }
                        }
                    } catch (R) {
                        ;(C = R.response),
                            C == null &&
                                (y.cancel(),
                                en.throwError("missing response", F.errors.SERVER_ERROR, {
                                    requestBody: Ai(l.body, m["content-type"]),
                                    requestMethod: l.method,
                                    serverError: R,
                                    url: a,
                                }))
                    }
                    let B = C.body
                    if (
                        (c && C.statusCode === 304
                            ? (B = null)
                            : (C.statusCode < 200 || C.statusCode >= 300) &&
                              (y.cancel(),
                              en.throwError("bad response", F.errors.SERVER_ERROR, {
                                  status: C.statusCode,
                                  headers: C.headers,
                                  body: Ai(B, C.headers ? C.headers["content-type"] : null),
                                  requestBody: Ai(l.body, m["content-type"]),
                                  requestMethod: l.method,
                                  url: a,
                              })),
                        r)
                    )
                        try {
                            const R = yield r(B, C)
                            return y.cancel(), R
                        } catch (R) {
                            if (R.throttleRetry && _ < n) {
                                let U = !0
                                if ((i && (U = yield i(_, a)), U)) {
                                    const D = s * parseInt(String(Math.random() * Math.pow(2, _)))
                                    yield zp(D)
                                    continue
                                }
                            }
                            y.cancel(),
                                en.throwError("processing response error", F.errors.SERVER_ERROR, {
                                    body: Ai(B, C.headers ? C.headers["content-type"] : null),
                                    error: R,
                                    requestBody: Ai(l.body, m["content-type"]),
                                    requestMethod: l.method,
                                    url: a,
                                })
                        }
                    return y.cancel(), B
                }
                return en.throwError("failed response", F.errors.SERVER_ERROR, {
                    requestBody: Ai(l.body, m["content-type"]),
                    requestMethod: l.method,
                    url: a,
                })
            })
        })()
    return Promise.race([y.promise, v])
}
function dl(t, e, r) {
    let n = (s, o) => {
            let a = null
            if (s != null)
                try {
                    a = JSON.parse(Xi(s))
                } catch (l) {
                    en.throwError("invalid JSON", F.errors.SERVER_ERROR, { body: s, error: l })
                }
            return r && (a = r(a, o)), a
        },
        i = null
    if (e != null) {
        i = zt(e)
        const s = typeof t == "string" ? { url: t } : Pt(t)
        s.headers
            ? Object.keys(s.headers).filter((a) => a.toLowerCase() === "content-type").length !== 0 ||
              ((s.headers = Pt(s.headers)), (s.headers["content-type"] = "application/json"))
            : (s.headers = { "content-type": "application/json" }),
            (t = s)
    }
    return yx(t, i, n)
}
function Ts(t, e) {
    return (
        e || (e = {}),
        (e = Pt(e)),
        e.floor == null && (e.floor = 0),
        e.ceiling == null && (e.ceiling = 1e4),
        e.interval == null && (e.interval = 250),
        new Promise(function (r, n) {
            let i = null,
                s = !1
            const o = () => (s ? !1 : ((s = !0), i && clearTimeout(i), !0))
            e.timeout &&
                (i = setTimeout(() => {
                    o() && n(new Error("timeout"))
                }, e.timeout))
            const a = e.retryLimit
            let l = 0
            function c() {
                return t().then(
                    function (f) {
                        if (f !== void 0) o() && r(f)
                        else if (e.oncePoll) e.oncePoll.once("poll", c)
                        else if (e.onceBlock) e.onceBlock.once("block", c)
                        else if (!s) {
                            if ((l++, l > a)) {
                                o() && n(new Error("retry limit reached"))
                                return
                            }
                            let u = e.interval * parseInt(String(Math.random() * Math.pow(2, l)))
                            u < e.floor && (u = e.floor), u > e.ceiling && (u = e.ceiling), setTimeout(c, u)
                        }
                        return null
                    },
                    function (f) {
                        o() && n(f)
                    }
                )
            }
            c()
        })
    )
}
var kc = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
    gd = {}
for (var Ml = 0; Ml < kc.length; Ml++) {
    var uu = kc.charAt(Ml)
    if (gd[uu] !== void 0) throw new TypeError(uu + " is ambiguous")
    gd[uu] = Ml
}
function _o(t) {
    var e = t >> 25
    return (
        ((t & 33554431) << 5) ^
        (-((e >> 0) & 1) & 996825010) ^
        (-((e >> 1) & 1) & 642813549) ^
        (-((e >> 2) & 1) & 513874426) ^
        (-((e >> 3) & 1) & 1027748829) ^
        (-((e >> 4) & 1) & 705979059)
    )
}
function _x(t) {
    for (var e = 1, r = 0; r < t.length; ++r) {
        var n = t.charCodeAt(r)
        if (n < 33 || n > 126) return "Invalid prefix (" + t + ")"
        e = _o(e) ^ (n >> 5)
    }
    for (e = _o(e), r = 0; r < t.length; ++r) {
        var i = t.charCodeAt(r)
        e = _o(e) ^ (i & 31)
    }
    return e
}
function H5(t, e, r) {
    if (((r = r || 90), t.length + 7 + e.length > r)) throw new TypeError("Exceeds length limit")
    t = t.toLowerCase()
    var n = _x(t)
    if (typeof n == "string") throw new Error(n)
    for (var i = t + "1", s = 0; s < e.length; ++s) {
        var o = e[s]
        if (o >> 5 !== 0) throw new Error("Non 5-bit word")
        ;(n = _o(n) ^ o), (i += kc.charAt(o))
    }
    for (s = 0; s < 6; ++s) n = _o(n)
    for (n ^= 1, s = 0; s < 6; ++s) {
        var a = (n >> ((5 - s) * 5)) & 31
        i += kc.charAt(a)
    }
    return i
}
function wx(t, e) {
    if (((e = e || 90), t.length < 8)) return t + " too short"
    if (t.length > e) return "Exceeds length limit"
    var r = t.toLowerCase(),
        n = t.toUpperCase()
    if (t !== r && t !== n) return "Mixed-case string " + t
    t = r
    var i = t.lastIndexOf("1")
    if (i === -1) return "No separator character for " + t
    if (i === 0) return "Missing prefix for " + t
    var s = t.slice(0, i),
        o = t.slice(i + 1)
    if (o.length < 6) return "Data too short"
    var a = _x(s)
    if (typeof a == "string") return a
    for (var l = [], c = 0; c < o.length; ++c) {
        var f = o.charAt(c),
            u = gd[f]
        if (u === void 0) return "Unknown character " + f
        ;(a = _o(a) ^ u), !(c + 6 >= o.length) && l.push(u)
    }
    return a !== 1 ? "Invalid checksum for " + t : { prefix: s, words: l }
}
function q5() {
    var t = wx.apply(null, arguments)
    if (typeof t == "object") return t
}
function j5(t) {
    var e = wx.apply(null, arguments)
    if (typeof e == "object") return e
    throw new Error(e)
}
function nf(t, e, r, n) {
    for (var i = 0, s = 0, o = (1 << r) - 1, a = [], l = 0; l < t.length; ++l)
        for (i = (i << e) | t[l], s += e; s >= r; ) (s -= r), a.push((i >> s) & o)
    if (n) s > 0 && a.push((i << (r - s)) & o)
    else {
        if (s >= e) return "Excess padding"
        if ((i << (r - s)) & o) return "Non-zero padding"
    }
    return a
}
function z5(t) {
    var e = nf(t, 8, 5, !0)
    if (Array.isArray(e)) return e
}
function K5(t) {
    var e = nf(t, 8, 5, !0)
    if (Array.isArray(e)) return e
    throw new Error(e)
}
function G5(t) {
    var e = nf(t, 5, 8, !1)
    if (Array.isArray(e)) return e
}
function W5(t) {
    var e = nf(t, 5, 8, !1)
    if (Array.isArray(e)) return e
    throw new Error(e)
}
var J5 = { decodeUnsafe: q5, decode: j5, encode: H5, toWordsUnsafe: z5, toWords: K5, fromWordsUnsafe: G5, fromWords: W5 },
    Kp = J5
const mr = "providers/5.5.3",
    Xs = new F(mr)
class _e {
    constructor() {
        Xs.checkNew(new.target, _e), (this.formats = this.getDefaultFormats())
    }
    getDefaultFormats() {
        const e = {},
            r = this.address.bind(this),
            n = this.bigNumber.bind(this),
            i = this.blockTag.bind(this),
            s = this.data.bind(this),
            o = this.hash.bind(this),
            a = this.hex.bind(this),
            l = this.number.bind(this),
            c = this.type.bind(this),
            f = (u) => this.data(u, !0)
        return (
            (e.transaction = {
                hash: o,
                type: c,
                accessList: _e.allowNull(this.accessList.bind(this), null),
                blockHash: _e.allowNull(o, null),
                blockNumber: _e.allowNull(l, null),
                transactionIndex: _e.allowNull(l, null),
                confirmations: _e.allowNull(l, null),
                from: r,
                gasPrice: _e.allowNull(n),
                maxPriorityFeePerGas: _e.allowNull(n),
                maxFeePerGas: _e.allowNull(n),
                gasLimit: n,
                to: _e.allowNull(r, null),
                value: n,
                nonce: l,
                data: s,
                r: _e.allowNull(this.uint256),
                s: _e.allowNull(this.uint256),
                v: _e.allowNull(l),
                creates: _e.allowNull(r, null),
                raw: _e.allowNull(s),
            }),
            (e.transactionRequest = {
                from: _e.allowNull(r),
                nonce: _e.allowNull(l),
                gasLimit: _e.allowNull(n),
                gasPrice: _e.allowNull(n),
                maxPriorityFeePerGas: _e.allowNull(n),
                maxFeePerGas: _e.allowNull(n),
                to: _e.allowNull(r),
                value: _e.allowNull(n),
                data: _e.allowNull(f),
                type: _e.allowNull(l),
                accessList: _e.allowNull(this.accessList.bind(this), null),
            }),
            (e.receiptLog = {
                transactionIndex: l,
                blockNumber: l,
                transactionHash: o,
                address: r,
                topics: _e.arrayOf(o),
                data: s,
                logIndex: l,
                blockHash: o,
            }),
            (e.receipt = {
                to: _e.allowNull(this.address, null),
                from: _e.allowNull(this.address, null),
                contractAddress: _e.allowNull(r, null),
                transactionIndex: l,
                root: _e.allowNull(a),
                gasUsed: n,
                logsBloom: _e.allowNull(s),
                blockHash: o,
                transactionHash: o,
                logs: _e.arrayOf(this.receiptLog.bind(this)),
                blockNumber: l,
                confirmations: _e.allowNull(l, null),
                cumulativeGasUsed: n,
                effectiveGasPrice: _e.allowNull(n),
                status: _e.allowNull(l),
                type: c,
            }),
            (e.block = {
                hash: o,
                parentHash: o,
                number: l,
                timestamp: l,
                nonce: _e.allowNull(a),
                difficulty: this.difficulty.bind(this),
                gasLimit: n,
                gasUsed: n,
                miner: r,
                extraData: s,
                transactions: _e.allowNull(_e.arrayOf(o)),
                baseFeePerGas: _e.allowNull(n),
            }),
            (e.blockWithTransactions = Pt(e.block)),
            (e.blockWithTransactions.transactions = _e.allowNull(_e.arrayOf(this.transactionResponse.bind(this)))),
            (e.filter = {
                fromBlock: _e.allowNull(i, void 0),
                toBlock: _e.allowNull(i, void 0),
                blockHash: _e.allowNull(o, void 0),
                address: _e.allowNull(r, void 0),
                topics: _e.allowNull(this.topics.bind(this), void 0),
            }),
            (e.filterLog = {
                blockNumber: _e.allowNull(l),
                blockHash: _e.allowNull(o),
                transactionIndex: l,
                removed: _e.allowNull(this.boolean.bind(this)),
                address: r,
                data: _e.allowFalsish(s, "0x"),
                topics: _e.arrayOf(o),
                transactionHash: o,
                logIndex: l,
            }),
            e
        )
    }
    accessList(e) {
        return Zi(e || [])
    }
    number(e) {
        return e === "0x" ? 0 : ce.from(e).toNumber()
    }
    type(e) {
        return e === "0x" || e == null ? 0 : ce.from(e).toNumber()
    }
    bigNumber(e) {
        return ce.from(e)
    }
    boolean(e) {
        if (typeof e == "boolean") return e
        if (typeof e == "string") {
            if (((e = e.toLowerCase()), e === "true")) return !0
            if (e === "false") return !1
        }
        throw new Error("invalid boolean - " + e)
    }
    hex(e, r) {
        return typeof e == "string" && (!r && e.substring(0, 2) !== "0x" && (e = "0x" + e), Le(e))
            ? e.toLowerCase()
            : Xs.throwArgumentError("invalid hash", "value", e)
    }
    data(e, r) {
        const n = this.hex(e, r)
        if (n.length % 2 !== 0) throw new Error("invalid data; odd-length - " + e)
        return n
    }
    address(e) {
        return nt(e)
    }
    callAddress(e) {
        if (!Le(e, 32)) return null
        const r = nt(Er(e, 12))
        return r === f1 ? null : r
    }
    contractAddress(e) {
        return Jc(e)
    }
    blockTag(e) {
        if (e == null) return "latest"
        if (e === "earliest") return "0x0"
        if (e === "latest" || e === "pending") return e
        if (typeof e == "number" || Le(e)) return al(e)
        throw new Error("invalid blockTag")
    }
    hash(e, r) {
        const n = this.hex(e, r)
        return Hi(n) !== 32 ? Xs.throwArgumentError("invalid hash", "value", e) : n
    }
    difficulty(e) {
        if (e == null) return null
        const r = ce.from(e)
        try {
            return r.toNumber()
        } catch {}
        return null
    }
    uint256(e) {
        if (!Le(e)) throw new Error("invalid uint256")
        return ut(e, 32)
    }
    _block(e, r) {
        e.author != null && e.miner == null && (e.miner = e.author)
        const n = e._difficulty != null ? e._difficulty : e.difficulty,
            i = _e.check(r, e)
        return (i._difficulty = n == null ? null : ce.from(n)), i
    }
    block(e) {
        return this._block(e, this.formats.block)
    }
    blockWithTransactions(e) {
        return this._block(e, this.formats.blockWithTransactions)
    }
    transactionRequest(e) {
        return _e.check(this.formats.transactionRequest, e)
    }
    transactionResponse(e) {
        e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas),
            e.to && ce.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"),
            e.input != null && e.data == null && (e.data = e.input),
            e.to == null && e.creates == null && (e.creates = this.contractAddress(e)),
            (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = [])
        const r = _e.check(this.formats.transaction, e)
        if (e.chainId != null) {
            let n = e.chainId
            Le(n) && (n = ce.from(n).toNumber()), (r.chainId = n)
        } else {
            let n = e.networkId
            n == null && r.v == null && (n = e.chainId),
                Le(n) && (n = ce.from(n).toNumber()),
                typeof n != "number" && r.v != null && ((n = (r.v - 35) / 2), n < 0 && (n = 0), (n = parseInt(n))),
                typeof n != "number" && (n = 0),
                (r.chainId = n)
        }
        return r.blockHash && r.blockHash.replace(/0/g, "") === "x" && (r.blockHash = null), r
    }
    transaction(e) {
        return ex(e)
    }
    receiptLog(e) {
        return _e.check(this.formats.receiptLog, e)
    }
    receipt(e) {
        const r = _e.check(this.formats.receipt, e)
        if (r.root != null)
            if (r.root.length <= 4) {
                const n = ce.from(r.root).toNumber()
                n === 0 || n === 1
                    ? (r.status != null &&
                          r.status !== n &&
                          Xs.throwArgumentError("alt-root-status/status mismatch", "value", { root: r.root, status: r.status }),
                      (r.status = n),
                      delete r.root)
                    : Xs.throwArgumentError("invalid alt-root-status", "value.root", r.root)
            } else r.root.length !== 66 && Xs.throwArgumentError("invalid root hash", "value.root", r.root)
        return r.status != null && (r.byzantium = !0), r
    }
    topics(e) {
        return Array.isArray(e) ? e.map((r) => this.topics(r)) : e != null ? this.hash(e, !0) : null
    }
    filter(e) {
        return _e.check(this.formats.filter, e)
    }
    filterLog(e) {
        return _e.check(this.formats.filterLog, e)
    }
    static check(e, r) {
        const n = {}
        for (const i in e)
            try {
                const s = e[i](r[i])
                s !== void 0 && (n[i] = s)
            } catch (s) {
                throw ((s.checkKey = i), (s.checkValue = r[i]), s)
            }
        return n
    }
    static allowNull(e, r) {
        return function (n) {
            return n == null ? r : e(n)
        }
    }
    static allowFalsish(e, r) {
        return function (n) {
            return n ? e(n) : r
        }
    }
    static arrayOf(e) {
        return function (r) {
            if (!Array.isArray(r)) throw new Error("not an array")
            const n = []
            return (
                r.forEach(function (i) {
                    n.push(e(i))
                }),
                n
            )
        }
    }
}
function Ex(t) {
    return t && typeof t.isCommunityResource == "function"
}
function md(t) {
    return Ex(t) && t.isCommunityResource()
}
let Gp = !1
function sf() {
    Gp ||
        ((Gp = !0),
        console.log("========= NOTICE ========="),
        console.log("Request-Rate Exceeded  (this message will not be repeated)"),
        console.log(""),
        console.log("The default API keys for each service are provided as a highly-throttled,"),
        console.log("community resource for low-traffic projects and early prototyping."),
        console.log(""),
        console.log("While your application will continue to function, we highly recommended"),
        console.log("signing up for your own API keys to improve performance, increase your"),
        console.log("request rate/limit and enable other perks, such as metrics and advanced APIs."),
        console.log(""),
        console.log("For more details: https://docs.ethers.io/api-keys/"),
        console.log("=========================="))
}
var De =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const Qe = new F(mr)
function Wp(t) {
    return t == null ? "null" : (Hi(t) !== 32 && Qe.throwArgumentError("invalid topic", "topic", t), t.toLowerCase())
}
function Jp(t) {
    for (t = t.slice(); t.length > 0 && t[t.length - 1] == null; ) t.pop()
    return t
        .map((e) => {
            if (Array.isArray(e)) {
                const r = {}
                e.forEach((i) => {
                    r[Wp(i)] = !0
                })
                const n = Object.keys(r)
                return n.sort(), n.join("|")
            } else return Wp(e)
        })
        .join("&")
}
function X5(t) {
    return t === ""
        ? []
        : t.split(/&/g).map((e) => {
              if (e === "") return []
              const r = e.split("|").map((n) => (n === "null" ? null : n))
              return r.length === 1 ? r[0] : r
          })
}
function Ys(t) {
    if (typeof t == "string") {
        if (((t = t.toLowerCase()), Hi(t) === 32)) return "tx:" + t
        if (t.indexOf(":") === -1) return t
    } else {
        if (Array.isArray(t)) return "filter:*:" + Jp(t)
        if (rE.isForkEvent(t)) throw (Qe.warn("not implemented"), new Error("not implemented"))
        if (t && typeof t == "object") return "filter:" + (t.address || "*") + ":" + Jp(t.topics || [])
    }
    throw new Error("invalid event - " + t)
}
function sa() {
    return new Date().getTime()
}
function Xp(t) {
    return new Promise((e) => {
        setTimeout(e, t)
    })
}
const Y5 = ["block", "network", "pending", "poll"]
class Z5 {
    constructor(e, r, n) {
        X(this, "tag", e), X(this, "listener", r), X(this, "once", n)
    }
    get event() {
        switch (this.type) {
            case "tx":
                return this.hash
            case "filter":
                return this.filter
        }
        return this.tag
    }
    get type() {
        return this.tag.split(":")[0]
    }
    get hash() {
        const e = this.tag.split(":")
        return e[0] !== "tx" ? null : e[1]
    }
    get filter() {
        const e = this.tag.split(":")
        if (e[0] !== "filter") return null
        const r = e[1],
            n = X5(e[2]),
            i = {}
        return n.length > 0 && (i.topics = n), r && r !== "*" && (i.address = r), i
    }
    pollable() {
        return this.tag.indexOf(":") >= 0 || Y5.indexOf(this.tag) >= 0
    }
}
const Q5 = {
    0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
    2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
    3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
    60: { symbol: "eth", ilk: "eth" },
    61: { symbol: "etc", ilk: "eth" },
    700: { symbol: "xdai", ilk: "eth" },
}
function du(t) {
    return ut(ce.from(t).toHexString(), 32)
}
function Yp(t) {
    return ul.encode(ft([t, Er(ai(ai(t)), 0, 4)]))
}
const Sx = new RegExp("^(ipfs)://(.*)$", "i"),
    Zp = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), Sx, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")]
function e8(t) {
    try {
        return Xi(Ax(t))
    } catch {}
    return null
}
function Ax(t) {
    if (t === "0x") return null
    const e = ce.from(Er(t, 0, 32)).toNumber(),
        r = ce.from(Er(t, e, e + 32)).toNumber()
    return Er(t, e + 32, e + 32 + r)
}
function hu(t) {
    return (
        t.match(/^ipfs:\/\/ipfs\//i)
            ? (t = t.substring(12))
            : t.match(/^ipfs:\/\//i)
            ? (t = t.substring(7))
            : Qe.throwArgumentError("unsupported IPFS format", "link", t),
        `https://gateway.ipfs.io/ipfs/${t}`
    )
}
class bd {
    constructor(e, r, n, i) {
        X(this, "provider", e), X(this, "name", n), X(this, "address", e.formatter.address(r)), X(this, "_resolvedAddress", i)
    }
    _fetchBytes(e, r) {
        return De(this, void 0, void 0, function* () {
            const n = { to: this.address, data: qr([e, Ya(this.name), r || "0x"]) }
            try {
                return Ax(yield this.provider.call(n))
            } catch (i) {
                return i.code === F.errors.CALL_EXCEPTION, null
            }
        })
    }
    _getAddress(e, r) {
        const n = Q5[String(e)]
        if (
            (n == null && Qe.throwError(`unsupported coin type: ${e}`, F.errors.UNSUPPORTED_OPERATION, { operation: `getAddress(${e})` }),
            n.ilk === "eth")
        )
            return this.provider.formatter.address(r)
        const i = le(r)
        if (n.p2pkh != null) {
            const s = r.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/)
            if (s) {
                const o = parseInt(s[1], 16)
                if (s[2].length === o * 2 && o >= 1 && o <= 75) return Yp(ft([[n.p2pkh], "0x" + s[2]]))
            }
        }
        if (n.p2sh != null) {
            const s = r.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/)
            if (s) {
                const o = parseInt(s[1], 16)
                if (s[2].length === o * 2 && o >= 1 && o <= 75) return Yp(ft([[n.p2sh], "0x" + s[2]]))
            }
        }
        if (n.prefix != null) {
            const s = i[1]
            let o = i[0]
            if ((o === 0 ? s !== 20 && s !== 32 && (o = -1) : (o = -1), o >= 0 && i.length === 2 + s && s >= 1 && s <= 75)) {
                const a = Kp.toWords(i.slice(2))
                return a.unshift(o), Kp.encode(n.prefix, a)
            }
        }
        return null
    }
    getAddress(e) {
        return De(this, void 0, void 0, function* () {
            if ((e == null && (e = 60), e === 60))
                try {
                    const i = { to: this.address, data: "0x3b3b57de" + Ya(this.name).substring(2) },
                        s = yield this.provider.call(i)
                    return s === "0x" || s === _0 ? null : this.provider.formatter.callAddress(s)
                } catch (i) {
                    if (i.code === F.errors.CALL_EXCEPTION) return null
                    throw i
                }
            const r = yield this._fetchBytes("0xf1cb7e06", du(e))
            if (r == null || r === "0x") return null
            const n = this._getAddress(e, r)
            return (
                n == null &&
                    Qe.throwError("invalid or unsupported coin data", F.errors.UNSUPPORTED_OPERATION, {
                        operation: `getAddress(${e})`,
                        coinType: e,
                        data: r,
                    }),
                n
            )
        })
    }
    getAvatar() {
        return De(this, void 0, void 0, function* () {
            const e = [{ type: "name", content: this.name }]
            try {
                const r = yield this.getText("avatar")
                if (r == null) return null
                for (let n = 0; n < Zp.length; n++) {
                    const i = r.match(Zp[n])
                    if (i == null) continue
                    const s = i[1].toLowerCase()
                    switch (s) {
                        case "https":
                            return e.push({ type: "url", content: r }), { linkage: e, url: r }
                        case "data":
                            return e.push({ type: "data", content: r }), { linkage: e, url: r }
                        case "ipfs":
                            return e.push({ type: "ipfs", content: r }), { linkage: e, url: hu(r) }
                        case "erc721":
                        case "erc1155": {
                            const o = s === "erc721" ? "0xc87b56dd" : "0x0e89341c"
                            e.push({ type: s, content: r })
                            const a = this._resolvedAddress || (yield this.getAddress()),
                                l = (i[2] || "").split("/")
                            if (l.length !== 2) return null
                            const c = yield this.provider.formatter.address(l[0]),
                                f = ut(ce.from(l[1]).toHexString(), 32)
                            if (s === "erc721") {
                                const v = this.provider.formatter.callAddress(yield this.provider.call({ to: c, data: qr(["0x6352211e", f]) }))
                                if (a !== v) return null
                                e.push({ type: "owner", content: v })
                            } else if (s === "erc1155") {
                                const v = ce.from(yield this.provider.call({ to: c, data: qr(["0x00fdd58e", ut(a, 32), f]) }))
                                if (v.isZero()) return null
                                e.push({ type: "balance", content: v.toString() })
                            }
                            const u = { to: this.provider.formatter.address(l[0]), data: qr([o, f]) }
                            let p = e8(yield this.provider.call(u))
                            if (p == null) return null
                            e.push({ type: "metadata-url-base", content: p }),
                                s === "erc1155" &&
                                    ((p = p.replace("{id}", f.substring(2))), e.push({ type: "metadata-url-expanded", content: p })),
                                p.match(/^ipfs:/i) && (p = hu(p)),
                                e.push({ type: "metadata-url", content: p })
                            const m = yield dl(p)
                            if (!m) return null
                            e.push({ type: "metadata", content: JSON.stringify(m) })
                            let y = m.image
                            if (typeof y != "string") return null
                            if (!y.match(/^(https:\/\/|data:)/i)) {
                                if (y.match(Sx) == null) return null
                                e.push({ type: "url-ipfs", content: y }), (y = hu(y))
                            }
                            return e.push({ type: "url", content: y }), { linkage: e, url: y }
                        }
                    }
                }
            } catch {}
            return null
        })
    }
    getContentHash() {
        return De(this, void 0, void 0, function* () {
            const e = yield this._fetchBytes("0xbc1c58d1")
            if (e == null || e === "0x") return null
            const r = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/)
            if (r) {
                const i = parseInt(r[3], 16)
                if (r[4].length === i * 2) return "ipfs://" + ul.encode("0x" + r[1])
            }
            const n = e.match(/^0xe40101fa011b20([0-9a-f]*)$/)
            return n && n[1].length === 32 * 2
                ? "bzz://" + n[1]
                : Qe.throwError("invalid or unsupported content hash data", F.errors.UNSUPPORTED_OPERATION, {
                      operation: "getContentHash()",
                      data: e,
                  })
        })
    }
    getText(e) {
        return De(this, void 0, void 0, function* () {
            let r = zt(e)
            ;(r = ft([du(64), du(r.length), r])), r.length % 32 !== 0 && (r = ft([r, ut("0x", 32 - (e.length % 32))]))
            const n = yield this._fetchBytes("0x59d1d43c", pe(r))
            return n == null || n === "0x" ? null : Xi(n)
        })
    }
}
let pu = null,
    t8 = 1
class of extends qi {
    constructor(e) {
        Qe.checkNew(new.target, qi)
        super()
        if (
            ((this._events = []),
            (this._emitted = { block: -2 }),
            (this.formatter = new.target.getFormatter()),
            X(this, "anyNetwork", e === "any"),
            this.anyNetwork && (e = this.detectNetwork()),
            e instanceof Promise)
        )
            (this._networkPromise = e), e.catch((r) => {}), this._ready().catch((r) => {})
        else {
            const r = Yt(new.target, "getNetwork")(e)
            r ? (X(this, "_network", r), this.emit("network", r, null)) : Qe.throwArgumentError("invalid network", "network", e)
        }
        ;(this._maxInternalBlockNumber = -1024), (this._lastBlockNumber = -2), (this._pollingInterval = 4e3), (this._fastQueryDate = 0)
    }
    _ready() {
        return De(this, void 0, void 0, function* () {
            if (this._network == null) {
                let e = null
                if (this._networkPromise)
                    try {
                        e = yield this._networkPromise
                    } catch {}
                e == null && (e = yield this.detectNetwork()),
                    e || Qe.throwError("no network detected", F.errors.UNKNOWN_ERROR, {}),
                    this._network == null && (this.anyNetwork ? (this._network = e) : X(this, "_network", e), this.emit("network", e, null))
            }
            return this._network
        })
    }
    get ready() {
        return Ts(() =>
            this._ready().then(
                (e) => e,
                (e) => {
                    if (!(e.code === F.errors.NETWORK_ERROR && e.event === "noNetwork")) throw e
                }
            )
        )
    }
    static getFormatter() {
        return pu == null && (pu = new _e()), pu
    }
    static getNetwork(e) {
        return F0(e == null ? "homestead" : e)
    }
    _getInternalBlockNumber(e) {
        return De(this, void 0, void 0, function* () {
            if ((yield this._ready(), e > 0))
                for (; this._internalBlockNumber; ) {
                    const i = this._internalBlockNumber
                    try {
                        const s = yield i
                        if (sa() - s.respTime <= e) return s.blockNumber
                        break
                    } catch {
                        if (this._internalBlockNumber === i) break
                    }
                }
            const r = sa(),
                n = Dt({
                    blockNumber: this.perform("getBlockNumber", {}),
                    networkError: this.getNetwork().then(
                        (i) => null,
                        (i) => i
                    ),
                }).then(({ blockNumber: i, networkError: s }) => {
                    if (s) throw (this._internalBlockNumber === n && (this._internalBlockNumber = null), s)
                    const o = sa()
                    return (
                        (i = ce.from(i).toNumber()),
                        i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber),
                        (this._maxInternalBlockNumber = i),
                        this._setFastBlockNumber(i),
                        { blockNumber: i, reqTime: r, respTime: o }
                    )
                })
            return (
                (this._internalBlockNumber = n),
                n.catch((i) => {
                    this._internalBlockNumber === n && (this._internalBlockNumber = null)
                }),
                (yield n).blockNumber
            )
        })
    }
    poll() {
        return De(this, void 0, void 0, function* () {
            const e = t8++,
                r = []
            let n = null
            try {
                n = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2)
            } catch (i) {
                this.emit("error", i)
                return
            }
            if ((this._setFastBlockNumber(n), this.emit("poll", e, n), n === this._lastBlockNumber)) {
                this.emit("didPoll", e)
                return
            }
            if ((this._emitted.block === -2 && (this._emitted.block = n - 1), Math.abs(this._emitted.block - n) > 1e3))
                Qe.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${n})`),
                    this.emit(
                        "error",
                        Qe.makeError("network block skew detected", F.errors.NETWORK_ERROR, {
                            blockNumber: n,
                            event: "blockSkew",
                            previousBlockNumber: this._emitted.block,
                        })
                    ),
                    this.emit("block", n)
            else for (let i = this._emitted.block + 1; i <= n; i++) this.emit("block", i)
            this._emitted.block !== n &&
                ((this._emitted.block = n),
                Object.keys(this._emitted).forEach((i) => {
                    if (i === "block") return
                    const s = this._emitted[i]
                    s !== "pending" && n - s > 12 && delete this._emitted[i]
                })),
                this._lastBlockNumber === -2 && (this._lastBlockNumber = n - 1),
                this._events.forEach((i) => {
                    switch (i.type) {
                        case "tx": {
                            const s = i.hash
                            let o = this.getTransactionReceipt(s)
                                .then((a) => (!a || a.blockNumber == null || ((this._emitted["t:" + s] = a.blockNumber), this.emit(s, a)), null))
                                .catch((a) => {
                                    this.emit("error", a)
                                })
                            r.push(o)
                            break
                        }
                        case "filter": {
                            const s = i.filter
                            ;(s.fromBlock = this._lastBlockNumber + 1), (s.toBlock = n)
                            const o = this.getLogs(s)
                                .then((a) => {
                                    a.length !== 0 &&
                                        a.forEach((l) => {
                                            ;(this._emitted["b:" + l.blockHash] = l.blockNumber),
                                                (this._emitted["t:" + l.transactionHash] = l.blockNumber),
                                                this.emit(s, l)
                                        })
                                })
                                .catch((a) => {
                                    this.emit("error", a)
                                })
                            r.push(o)
                            break
                        }
                    }
                }),
                (this._lastBlockNumber = n),
                Promise.all(r)
                    .then(() => {
                        this.emit("didPoll", e)
                    })
                    .catch((i) => {
                        this.emit("error", i)
                    })
        })
    }
    resetEventsBlock(e) {
        ;(this._lastBlockNumber = e - 1), this.polling && this.poll()
    }
    get network() {
        return this._network
    }
    detectNetwork() {
        return De(this, void 0, void 0, function* () {
            return Qe.throwError("provider does not support network detection", F.errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork",
            })
        })
    }
    getNetwork() {
        return De(this, void 0, void 0, function* () {
            const e = yield this._ready(),
                r = yield this.detectNetwork()
            if (e.chainId !== r.chainId) {
                if (this.anyNetwork)
                    return (
                        (this._network = r),
                        (this._lastBlockNumber = -2),
                        (this._fastBlockNumber = null),
                        (this._fastBlockNumberPromise = null),
                        (this._fastQueryDate = 0),
                        (this._emitted.block = -2),
                        (this._maxInternalBlockNumber = -1024),
                        (this._internalBlockNumber = null),
                        this.emit("network", r, e),
                        yield Xp(0),
                        this._network
                    )
                const n = Qe.makeError("underlying network changed", F.errors.NETWORK_ERROR, {
                    event: "changed",
                    network: e,
                    detectedNetwork: r,
                })
                throw (this.emit("error", n), n)
            }
            return e
        })
    }
    get blockNumber() {
        return (
            this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(
                (e) => {
                    this._setFastBlockNumber(e)
                },
                (e) => {}
            ),
            this._fastBlockNumber != null ? this._fastBlockNumber : -1
        )
    }
    get polling() {
        return this._poller != null
    }
    set polling(e) {
        e && !this._poller
            ? ((this._poller = setInterval(() => {
                  this.poll()
              }, this.pollingInterval)),
              this._bootstrapPoll ||
                  (this._bootstrapPoll = setTimeout(() => {
                      this.poll(),
                          (this._bootstrapPoll = setTimeout(() => {
                              this._poller || this.poll(), (this._bootstrapPoll = null)
                          }, this.pollingInterval))
                  }, 0)))
            : !e && this._poller && (clearInterval(this._poller), (this._poller = null))
    }
    get pollingInterval() {
        return this._pollingInterval
    }
    set pollingInterval(e) {
        if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e) throw new Error("invalid polling interval")
        ;(this._pollingInterval = e),
            this._poller &&
                (clearInterval(this._poller),
                (this._poller = setInterval(() => {
                    this.poll()
                }, this._pollingInterval)))
    }
    _getFastBlockNumber() {
        const e = sa()
        return (
            e - this._fastQueryDate > 2 * this._pollingInterval &&
                ((this._fastQueryDate = e),
                (this._fastBlockNumberPromise = this.getBlockNumber().then(
                    (r) => ((this._fastBlockNumber == null || r > this._fastBlockNumber) && (this._fastBlockNumber = r), this._fastBlockNumber)
                ))),
            this._fastBlockNumberPromise
        )
    }
    _setFastBlockNumber(e) {
        ;(this._fastBlockNumber != null && e < this._fastBlockNumber) ||
            ((this._fastQueryDate = sa()),
            (this._fastBlockNumber == null || e > this._fastBlockNumber) &&
                ((this._fastBlockNumber = e), (this._fastBlockNumberPromise = Promise.resolve(e))))
    }
    waitForTransaction(e, r, n) {
        return De(this, void 0, void 0, function* () {
            return this._waitForTransaction(e, r == null ? 1 : r, n || 0, null)
        })
    }
    _waitForTransaction(e, r, n, i) {
        return De(this, void 0, void 0, function* () {
            const s = yield this.getTransactionReceipt(e)
            return (s ? s.confirmations : 0) >= r
                ? s
                : new Promise((o, a) => {
                      const l = []
                      let c = !1
                      const f = function () {
                              return c
                                  ? !0
                                  : ((c = !0),
                                    l.forEach((p) => {
                                        p()
                                    }),
                                    !1)
                          },
                          u = (p) => {
                              p.confirmations < r || f() || o(p)
                          }
                      if (
                          (this.on(e, u),
                          l.push(() => {
                              this.removeListener(e, u)
                          }),
                          i)
                      ) {
                          let p = i.startBlock,
                              m = null
                          const y = (v) =>
                              De(this, void 0, void 0, function* () {
                                  c ||
                                      (yield Xp(1e3),
                                      this.getTransactionCount(i.from).then(
                                          (_) =>
                                              De(this, void 0, void 0, function* () {
                                                  if (!c) {
                                                      if (_ <= i.nonce) p = v
                                                      else {
                                                          {
                                                              const C = yield this.getTransaction(e)
                                                              if (C && C.blockNumber != null) return
                                                          }
                                                          for (m == null && ((m = p - 3), m < i.startBlock && (m = i.startBlock)); m <= v; ) {
                                                              if (c) return
                                                              const C = yield this.getBlockWithTransactions(m)
                                                              for (let B = 0; B < C.transactions.length; B++) {
                                                                  const R = C.transactions[B]
                                                                  if (R.hash === e) return
                                                                  if (R.from === i.from && R.nonce === i.nonce) {
                                                                      if (c) return
                                                                      const U = yield this.waitForTransaction(R.hash, r)
                                                                      if (f()) return
                                                                      let D = "replaced"
                                                                      R.data === i.data && R.to === i.to && R.value.eq(i.value)
                                                                          ? (D = "repriced")
                                                                          : R.data === "0x" &&
                                                                            R.from === R.to &&
                                                                            R.value.isZero() &&
                                                                            (D = "cancelled"),
                                                                          a(
                                                                              Qe.makeError(
                                                                                  "transaction was replaced",
                                                                                  F.errors.TRANSACTION_REPLACED,
                                                                                  {
                                                                                      cancelled: D === "replaced" || D === "cancelled",
                                                                                      reason: D,
                                                                                      replacement: this._wrapTransaction(R),
                                                                                      hash: e,
                                                                                      receipt: U,
                                                                                  }
                                                                              )
                                                                          )
                                                                      return
                                                                  }
                                                              }
                                                              m++
                                                          }
                                                      }
                                                      c || this.once("block", y)
                                                  }
                                              }),
                                          (_) => {
                                              c || this.once("block", y)
                                          }
                                      ))
                              })
                          if (c) return
                          this.once("block", y),
                              l.push(() => {
                                  this.removeListener("block", y)
                              })
                      }
                      if (typeof n == "number" && n > 0) {
                          const p = setTimeout(() => {
                              f() || a(Qe.makeError("timeout exceeded", F.errors.TIMEOUT, { timeout: n }))
                          }, n)
                          p.unref && p.unref(),
                              l.push(() => {
                                  clearTimeout(p)
                              })
                      }
                  })
        })
    }
    getBlockNumber() {
        return De(this, void 0, void 0, function* () {
            return this._getInternalBlockNumber(0)
        })
    }
    getGasPrice() {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const e = yield this.perform("getGasPrice", {})
            try {
                return ce.from(e)
            } catch (r) {
                return Qe.throwError("bad result from backend", F.errors.SERVER_ERROR, { method: "getGasPrice", result: e, error: r })
            }
        })
    }
    getBalance(e, r) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield Dt({ address: this._getAddress(e), blockTag: this._getBlockTag(r) }),
                i = yield this.perform("getBalance", n)
            try {
                return ce.from(i)
            } catch (s) {
                return Qe.throwError("bad result from backend", F.errors.SERVER_ERROR, { method: "getBalance", params: n, result: i, error: s })
            }
        })
    }
    getTransactionCount(e, r) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield Dt({ address: this._getAddress(e), blockTag: this._getBlockTag(r) }),
                i = yield this.perform("getTransactionCount", n)
            try {
                return ce.from(i).toNumber()
            } catch (s) {
                return Qe.throwError("bad result from backend", F.errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params: n,
                    result: i,
                    error: s,
                })
            }
        })
    }
    getCode(e, r) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield Dt({ address: this._getAddress(e), blockTag: this._getBlockTag(r) }),
                i = yield this.perform("getCode", n)
            try {
                return pe(i)
            } catch (s) {
                return Qe.throwError("bad result from backend", F.errors.SERVER_ERROR, { method: "getCode", params: n, result: i, error: s })
            }
        })
    }
    getStorageAt(e, r, n) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const i = yield Dt({
                    address: this._getAddress(e),
                    blockTag: this._getBlockTag(n),
                    position: Promise.resolve(r).then((o) => al(o)),
                }),
                s = yield this.perform("getStorageAt", i)
            try {
                return pe(s)
            } catch (o) {
                return Qe.throwError("bad result from backend", F.errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params: i,
                    result: s,
                    error: o,
                })
            }
        })
    }
    _wrapTransaction(e, r, n) {
        if (r != null && Hi(r) !== 32) throw new Error("invalid response - sendTransaction")
        const i = e
        return (
            r != null &&
                e.hash !== r &&
                Qe.throwError("Transaction hash mismatch from Provider.sendTransaction.", F.errors.UNKNOWN_ERROR, {
                    expectedHash: e.hash,
                    returnedHash: r,
                }),
            (i.wait = (s, o) =>
                De(this, void 0, void 0, function* () {
                    s == null && (s = 1), o == null && (o = 0)
                    let a
                    s !== 0 && n != null && (a = { data: e.data, from: e.from, nonce: e.nonce, to: e.to, value: e.value, startBlock: n })
                    const l = yield this._waitForTransaction(e.hash, s, o, a)
                    return l == null && s === 0
                        ? null
                        : ((this._emitted["t:" + e.hash] = l.blockNumber),
                          l.status === 0 &&
                              Qe.throwError("transaction failed", F.errors.CALL_EXCEPTION, {
                                  transactionHash: e.hash,
                                  transaction: e,
                                  receipt: l,
                              }),
                          l)
                })),
            i
        )
    }
    sendTransaction(e) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const r = yield Promise.resolve(e).then((s) => pe(s)),
                n = this.formatter.transaction(e)
            n.confirmations == null && (n.confirmations = 0)
            const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)
            try {
                const s = yield this.perform("sendTransaction", { signedTransaction: r })
                return this._wrapTransaction(n, s, i)
            } catch (s) {
                throw ((s.transaction = n), (s.transactionHash = n.hash), s)
            }
        })
    }
    _getTransactionRequest(e) {
        return De(this, void 0, void 0, function* () {
            const r = yield e,
                n = {}
            return (
                ["from", "to"].forEach((i) => {
                    r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => (s ? this._getAddress(s) : null)))
                }),
                ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((i) => {
                    r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => (s ? ce.from(s) : null)))
                }),
                ["type"].forEach((i) => {
                    r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => (s != null ? s : null)))
                }),
                r.accessList && (n.accessList = this.formatter.accessList(r.accessList)),
                ["data"].forEach((i) => {
                    r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => (s ? pe(s) : null)))
                }),
                this.formatter.transactionRequest(yield Dt(n))
            )
        })
    }
    _getFilter(e) {
        return De(this, void 0, void 0, function* () {
            e = yield e
            const r = {}
            return (
                e.address != null && (r.address = this._getAddress(e.address)),
                ["blockHash", "topics"].forEach((n) => {
                    e[n] != null && (r[n] = e[n])
                }),
                ["fromBlock", "toBlock"].forEach((n) => {
                    e[n] != null && (r[n] = this._getBlockTag(e[n]))
                }),
                this.formatter.filter(yield Dt(r))
            )
        })
    }
    call(e, r) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield Dt({ transaction: this._getTransactionRequest(e), blockTag: this._getBlockTag(r) }),
                i = yield this.perform("call", n)
            try {
                return pe(i)
            } catch (s) {
                return Qe.throwError("bad result from backend", F.errors.SERVER_ERROR, { method: "call", params: n, result: i, error: s })
            }
        })
    }
    estimateGas(e) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const r = yield Dt({ transaction: this._getTransactionRequest(e) }),
                n = yield this.perform("estimateGas", r)
            try {
                return ce.from(n)
            } catch (i) {
                return Qe.throwError("bad result from backend", F.errors.SERVER_ERROR, { method: "estimateGas", params: r, result: n, error: i })
            }
        })
    }
    _getAddress(e) {
        return De(this, void 0, void 0, function* () {
            ;(e = yield e), typeof e != "string" && Qe.throwArgumentError("invalid address or ENS name", "name", e)
            const r = yield this.resolveName(e)
            return (
                r == null &&
                    Qe.throwError("ENS name not configured", F.errors.UNSUPPORTED_OPERATION, { operation: `resolveName(${JSON.stringify(e)})` }),
                r
            )
        })
    }
    _getBlock(e, r) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork(), (e = yield e)
            let n = -128
            const i = { includeTransactions: !!r }
            if (Le(e, 32)) i.blockHash = e
            else
                try {
                    ;(i.blockTag = yield this._getBlockTag(e)), Le(i.blockTag) && (n = parseInt(i.blockTag.substring(2), 16))
                } catch {
                    Qe.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e)
                }
            return Ts(
                () =>
                    De(this, void 0, void 0, function* () {
                        const s = yield this.perform("getBlock", i)
                        if (s == null)
                            return (i.blockHash != null && this._emitted["b:" + i.blockHash] == null) ||
                                (i.blockTag != null && n > this._emitted.block)
                                ? null
                                : void 0
                        if (r) {
                            let o = null
                            for (let l = 0; l < s.transactions.length; l++) {
                                const c = s.transactions[l]
                                if (c.blockNumber == null) c.confirmations = 0
                                else if (c.confirmations == null) {
                                    o == null && (o = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval))
                                    let f = o - c.blockNumber + 1
                                    f <= 0 && (f = 1), (c.confirmations = f)
                                }
                            }
                            const a = this.formatter.blockWithTransactions(s)
                            return (a.transactions = a.transactions.map((l) => this._wrapTransaction(l))), a
                        }
                        return this.formatter.block(s)
                    }),
                { oncePoll: this }
            )
        })
    }
    getBlock(e) {
        return this._getBlock(e, !1)
    }
    getBlockWithTransactions(e) {
        return this._getBlock(e, !0)
    }
    getTransaction(e) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork(), (e = yield e)
            const r = { transactionHash: this.formatter.hash(e, !0) }
            return Ts(
                () =>
                    De(this, void 0, void 0, function* () {
                        const n = yield this.perform("getTransaction", r)
                        if (n == null) return this._emitted["t:" + e] == null ? null : void 0
                        const i = this.formatter.transactionResponse(n)
                        if (i.blockNumber == null) i.confirmations = 0
                        else if (i.confirmations == null) {
                            let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1
                            o <= 0 && (o = 1), (i.confirmations = o)
                        }
                        return this._wrapTransaction(i)
                    }),
                { oncePoll: this }
            )
        })
    }
    getTransactionReceipt(e) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork(), (e = yield e)
            const r = { transactionHash: this.formatter.hash(e, !0) }
            return Ts(
                () =>
                    De(this, void 0, void 0, function* () {
                        const n = yield this.perform("getTransactionReceipt", r)
                        if (n == null) return this._emitted["t:" + e] == null ? null : void 0
                        if (n.blockHash == null) return
                        const i = this.formatter.receipt(n)
                        if (i.blockNumber == null) i.confirmations = 0
                        else if (i.confirmations == null) {
                            let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1
                            o <= 0 && (o = 1), (i.confirmations = o)
                        }
                        return i
                    }),
                { oncePoll: this }
            )
        })
    }
    getLogs(e) {
        return De(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const r = yield Dt({ filter: this._getFilter(e) }),
                n = yield this.perform("getLogs", r)
            return (
                n.forEach((i) => {
                    i.removed == null && (i.removed = !1)
                }),
                _e.arrayOf(this.formatter.filterLog.bind(this.formatter))(n)
            )
        })
    }
    getEtherPrice() {
        return De(this, void 0, void 0, function* () {
            return yield this.getNetwork(), this.perform("getEtherPrice", {})
        })
    }
    _getBlockTag(e) {
        return De(this, void 0, void 0, function* () {
            if (((e = yield e), typeof e == "number" && e < 0)) {
                e % 1 && Qe.throwArgumentError("invalid BlockTag", "blockTag", e)
                let r = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)
                return (r += e), r < 0 && (r = 0), this.formatter.blockTag(r)
            }
            return this.formatter.blockTag(e)
        })
    }
    getResolver(e) {
        return De(this, void 0, void 0, function* () {
            try {
                const r = yield this._getResolver(e)
                return r == null ? null : new bd(this, r, e)
            } catch (r) {
                if (r.code === F.errors.CALL_EXCEPTION) return null
                throw r
            }
        })
    }
    _getResolver(e) {
        return De(this, void 0, void 0, function* () {
            const r = yield this.getNetwork()
            r.ensAddress || Qe.throwError("network does not support ENS", F.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: r.name })
            const n = { to: r.ensAddress, data: "0x0178b8bf" + Ya(e).substring(2) }
            try {
                return this.formatter.callAddress(yield this.call(n))
            } catch (i) {
                if (i.code === F.errors.CALL_EXCEPTION) return null
                throw i
            }
        })
    }
    resolveName(e) {
        return De(this, void 0, void 0, function* () {
            e = yield e
            try {
                return Promise.resolve(this.formatter.address(e))
            } catch (n) {
                if (Le(e)) throw n
            }
            typeof e != "string" && Qe.throwArgumentError("invalid ENS name", "name", e)
            const r = yield this.getResolver(e)
            return r ? yield r.getAddress() : null
        })
    }
    lookupAddress(e) {
        return De(this, void 0, void 0, function* () {
            ;(e = yield e), (e = this.formatter.address(e))
            const r = e.substring(2).toLowerCase() + ".addr.reverse",
                n = yield this._getResolver(r)
            if (!n) return null
            let i = le(yield this.call({ to: n, data: "0x691f3431" + Ya(r).substring(2) }))
            if (i.length < 32 || !ce.from(i.slice(0, 32)).eq(32) || ((i = i.slice(32)), i.length < 32)) return null
            const s = ce.from(i.slice(0, 32)).toNumber()
            if (((i = i.slice(32)), s > i.length)) return null
            const o = Xi(i.slice(0, s))
            return (yield this.resolveName(o)) != e ? null : o
        })
    }
    getAvatar(e) {
        return De(this, void 0, void 0, function* () {
            let r = null
            if (Le(e)) {
                const i = this.formatter.address(e),
                    s = i.substring(2).toLowerCase() + ".addr.reverse",
                    o = yield this._getResolver(s)
                if (!o) return null
                r = new bd(this, o, "_", i)
            } else if (((r = yield this.getResolver(e)), !r)) return null
            const n = yield r.getAvatar()
            return n == null ? null : n.url
        })
    }
    perform(e, r) {
        return Qe.throwError(e + " not implemented", F.errors.NOT_IMPLEMENTED, { operation: e })
    }
    _startEvent(e) {
        this.polling = this._events.filter((r) => r.pollable()).length > 0
    }
    _stopEvent(e) {
        this.polling = this._events.filter((r) => r.pollable()).length > 0
    }
    _addEventListener(e, r, n) {
        const i = new Z5(Ys(e), r, n)
        return this._events.push(i), this._startEvent(i), this
    }
    on(e, r) {
        return this._addEventListener(e, r, !1)
    }
    once(e, r) {
        return this._addEventListener(e, r, !0)
    }
    emit(e, ...r) {
        let n = !1,
            i = [],
            s = Ys(e)
        return (
            (this._events = this._events.filter((o) =>
                o.tag !== s
                    ? !0
                    : (setTimeout(() => {
                          o.listener.apply(this, r)
                      }, 0),
                      (n = !0),
                      o.once ? (i.push(o), !1) : !0)
            )),
            i.forEach((o) => {
                this._stopEvent(o)
            }),
            n
        )
    }
    listenerCount(e) {
        if (!e) return this._events.length
        let r = Ys(e)
        return this._events.filter((n) => n.tag === r).length
    }
    listeners(e) {
        if (e == null) return this._events.map((n) => n.listener)
        let r = Ys(e)
        return this._events.filter((n) => n.tag === r).map((n) => n.listener)
    }
    off(e, r) {
        if (r == null) return this.removeAllListeners(e)
        const n = []
        let i = !1,
            s = Ys(e)
        return (
            (this._events = this._events.filter((o) => (o.tag !== s || o.listener != r || i ? !0 : ((i = !0), n.push(o), !1)))),
            n.forEach((o) => {
                this._stopEvent(o)
            }),
            this
        )
    }
    removeAllListeners(e) {
        let r = []
        if (e == null) (r = this._events), (this._events = [])
        else {
            const n = Ys(e)
            this._events = this._events.filter((i) => (i.tag !== n ? !0 : (r.push(i), !1)))
        }
        return (
            r.forEach((n) => {
                this._stopEvent(n)
            }),
            this
        )
    }
}
var Wn =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const rr = new F(mr),
    r8 = ["call", "estimateGas"]
function Tx(t, e, r) {
    if (t === "call" && e.code === F.errors.SERVER_ERROR) {
        const s = e.error
        if (s && s.message.match("reverted") && Le(s.data)) return s.data
        rr.throwError("missing revert data in call exception", F.errors.CALL_EXCEPTION, { error: e, data: "0x" })
    }
    let n = e.message
    e.code === F.errors.SERVER_ERROR && e.error && typeof e.error.message == "string"
        ? (n = e.error.message)
        : typeof e.body == "string"
        ? (n = e.body)
        : typeof e.responseText == "string" && (n = e.responseText),
        (n = (n || "").toLowerCase())
    const i = r.transaction || r.signedTransaction
    throw (
        (n.match(/insufficient funds|base fee exceeds gas limit/) &&
            rr.throwError("insufficient funds for intrinsic transaction cost", F.errors.INSUFFICIENT_FUNDS, {
                error: e,
                method: t,
                transaction: i,
            }),
        n.match(/nonce too low/) &&
            rr.throwError("nonce has already been used", F.errors.NONCE_EXPIRED, { error: e, method: t, transaction: i }),
        n.match(/replacement transaction underpriced/) &&
            rr.throwError("replacement fee too low", F.errors.REPLACEMENT_UNDERPRICED, { error: e, method: t, transaction: i }),
        n.match(/only replay-protected/) &&
            rr.throwError("legacy pre-eip-155 transactions not supported", F.errors.UNSUPPORTED_OPERATION, {
                error: e,
                method: t,
                transaction: i,
            }),
        r8.indexOf(t) >= 0 &&
            n.match(/gas required exceeds allowance|always failing transaction|execution reverted/) &&
            rr.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", F.errors.UNPREDICTABLE_GAS_LIMIT, {
                error: e,
                method: t,
                transaction: i,
            }),
        e)
    )
}
function Qp(t) {
    return new Promise(function (e) {
        setTimeout(e, t)
    })
}
function n8(t) {
    if (t.error) {
        const e = new Error(t.error.message)
        throw ((e.code = t.error.code), (e.data = t.error.data), e)
    }
    return t.result
}
function oa(t) {
    return t && t.toLowerCase()
}
const xd = {}
class hl extends di {
    constructor(e, r, n) {
        rr.checkNew(new.target, hl)
        super()
        if (e !== xd) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner")
        X(this, "provider", r),
            n == null && (n = 0),
            typeof n == "string"
                ? (X(this, "_address", this.provider.formatter.address(n)), X(this, "_index", null))
                : typeof n == "number"
                ? (X(this, "_index", n), X(this, "_address", null))
                : rr.throwArgumentError("invalid address or index", "addressOrIndex", n)
    }
    connect(e) {
        return rr.throwError("cannot alter JSON-RPC Signer connection", F.errors.UNSUPPORTED_OPERATION, { operation: "connect" })
    }
    connectUnchecked() {
        return new i8(xd, this.provider, this._address || this._index)
    }
    getAddress() {
        return this._address
            ? Promise.resolve(this._address)
            : this.provider
                  .send("eth_accounts", [])
                  .then(
                      (e) => (
                          e.length <= this._index &&
                              rr.throwError("unknown account #" + this._index, F.errors.UNSUPPORTED_OPERATION, { operation: "getAddress" }),
                          this.provider.formatter.address(e[this._index])
                      )
                  )
    }
    sendUncheckedTransaction(e) {
        e = Pt(e)
        const r = this.getAddress().then((n) => (n && (n = n.toLowerCase()), n))
        if (e.gasLimit == null) {
            const n = Pt(e)
            ;(n.from = r), (e.gasLimit = this.provider.estimateGas(n))
        }
        return (
            e.to != null &&
                (e.to = Promise.resolve(e.to).then((n) =>
                    Wn(this, void 0, void 0, function* () {
                        if (n == null) return null
                        const i = yield this.provider.resolveName(n)
                        return i == null && rr.throwArgumentError("provided ENS name resolves to null", "tx.to", n), i
                    })
                )),
            Dt({ tx: Dt(e), sender: r }).then(({ tx: n, sender: i }) => {
                n.from != null ? n.from.toLowerCase() !== i && rr.throwArgumentError("from address mismatch", "transaction", e) : (n.from = i)
                const s = this.provider.constructor.hexlifyTransaction(n, { from: !0 })
                return this.provider.send("eth_sendTransaction", [s]).then(
                    (o) => o,
                    (o) => Tx("sendTransaction", o, s)
                )
            })
        )
    }
    signTransaction(e) {
        return rr.throwError("signing transactions is unsupported", F.errors.UNSUPPORTED_OPERATION, { operation: "signTransaction" })
    }
    sendTransaction(e) {
        return Wn(this, void 0, void 0, function* () {
            const r = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval),
                n = yield this.sendUncheckedTransaction(e)
            try {
                return yield Ts(
                    () =>
                        Wn(this, void 0, void 0, function* () {
                            const i = yield this.provider.getTransaction(n)
                            if (i !== null) return this.provider._wrapTransaction(i, n, r)
                        }),
                    { oncePoll: this.provider }
                )
            } catch (i) {
                throw ((i.transactionHash = n), i)
            }
        })
    }
    signMessage(e) {
        return Wn(this, void 0, void 0, function* () {
            const r = typeof e == "string" ? zt(e) : e,
                n = yield this.getAddress()
            return yield this.provider.send("personal_sign", [pe(r), n.toLowerCase()])
        })
    }
    _legacySignMessage(e) {
        return Wn(this, void 0, void 0, function* () {
            const r = typeof e == "string" ? zt(e) : e,
                n = yield this.getAddress()
            return yield this.provider.send("eth_sign", [n.toLowerCase(), pe(r)])
        })
    }
    _signTypedData(e, r, n) {
        return Wn(this, void 0, void 0, function* () {
            const i = yield tr.resolveNames(e, r, n, (o) => this.provider.resolveName(o)),
                s = yield this.getAddress()
            return yield this.provider.send("eth_signTypedData_v4", [s.toLowerCase(), JSON.stringify(tr.getPayload(i.domain, r, i.value))])
        })
    }
    unlock(e) {
        return Wn(this, void 0, void 0, function* () {
            const r = this.provider,
                n = yield this.getAddress()
            return r.send("personal_unlockAccount", [n.toLowerCase(), e, null])
        })
    }
}
class i8 extends hl {
    sendTransaction(e) {
        return this.sendUncheckedTransaction(e).then((r) => ({
            hash: r,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: (n) => this.provider.waitForTransaction(r, n),
        }))
    }
}
const s8 = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    value: !0,
    type: !0,
    accessList: !0,
    maxFeePerGas: !0,
    maxPriorityFeePerGas: !0,
}
class li extends of {
    constructor(e, r) {
        rr.checkNew(new.target, li)
        let n = r
        n == null &&
            (n = new Promise((i, s) => {
                setTimeout(() => {
                    this.detectNetwork().then(
                        (o) => {
                            i(o)
                        },
                        (o) => {
                            s(o)
                        }
                    )
                }, 0)
            }))
        super(n)
        e || (e = Yt(this.constructor, "defaultUrl")()),
            typeof e == "string" ? X(this, "connection", Object.freeze({ url: e })) : X(this, "connection", Object.freeze(Pt(e))),
            (this._nextId = 42)
    }
    get _cache() {
        return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache
    }
    static defaultUrl() {
        return "http://localhost:8545"
    }
    detectNetwork() {
        return (
            this._cache.detectNetwork ||
                ((this._cache.detectNetwork = this._uncachedDetectNetwork()),
                setTimeout(() => {
                    this._cache.detectNetwork = null
                }, 0)),
            this._cache.detectNetwork
        )
    }
    _uncachedDetectNetwork() {
        return Wn(this, void 0, void 0, function* () {
            yield Qp(0)
            let e = null
            try {
                e = yield this.send("eth_chainId", [])
            } catch {
                try {
                    e = yield this.send("net_version", [])
                } catch {}
            }
            if (e != null) {
                const r = Yt(this.constructor, "getNetwork")
                try {
                    return r(ce.from(e).toNumber())
                } catch (n) {
                    return rr.throwError("could not detect network", F.errors.NETWORK_ERROR, {
                        chainId: e,
                        event: "invalidNetwork",
                        serverError: n,
                    })
                }
            }
            return rr.throwError("could not detect network", F.errors.NETWORK_ERROR, { event: "noNetwork" })
        })
    }
    getSigner(e) {
        return new hl(xd, this, e)
    }
    getUncheckedSigner(e) {
        return this.getSigner(e).connectUnchecked()
    }
    listAccounts() {
        return this.send("eth_accounts", []).then((e) => e.map((r) => this.formatter.address(r)))
    }
    send(e, r) {
        const n = { method: e, params: r, id: this._nextId++, jsonrpc: "2.0" }
        this.emit("debug", { action: "request", request: pr(n), provider: this })
        const i = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0
        if (i && this._cache[e]) return this._cache[e]
        const s = dl(this.connection, JSON.stringify(n), n8).then(
            (o) => (this.emit("debug", { action: "response", request: n, response: o, provider: this }), o),
            (o) => {
                throw (this.emit("debug", { action: "response", error: o, request: n, provider: this }), o)
            }
        )
        return (
            i &&
                ((this._cache[e] = s),
                setTimeout(() => {
                    this._cache[e] = null
                }, 0)),
            s
        )
    }
    prepareRequest(e, r) {
        switch (e) {
            case "getBlockNumber":
                return ["eth_blockNumber", []]
            case "getGasPrice":
                return ["eth_gasPrice", []]
            case "getBalance":
                return ["eth_getBalance", [oa(r.address), r.blockTag]]
            case "getTransactionCount":
                return ["eth_getTransactionCount", [oa(r.address), r.blockTag]]
            case "getCode":
                return ["eth_getCode", [oa(r.address), r.blockTag]]
            case "getStorageAt":
                return ["eth_getStorageAt", [oa(r.address), r.position, r.blockTag]]
            case "sendTransaction":
                return ["eth_sendRawTransaction", [r.signedTransaction]]
            case "getBlock":
                return r.blockTag
                    ? ["eth_getBlockByNumber", [r.blockTag, !!r.includeTransactions]]
                    : r.blockHash
                    ? ["eth_getBlockByHash", [r.blockHash, !!r.includeTransactions]]
                    : null
            case "getTransaction":
                return ["eth_getTransactionByHash", [r.transactionHash]]
            case "getTransactionReceipt":
                return ["eth_getTransactionReceipt", [r.transactionHash]]
            case "call": {
                const n = Yt(this.constructor, "hexlifyTransaction")
                return ["eth_call", [n(r.transaction, { from: !0 }), r.blockTag]]
            }
            case "estimateGas": {
                const n = Yt(this.constructor, "hexlifyTransaction")
                return ["eth_estimateGas", [n(r.transaction, { from: !0 })]]
            }
            case "getLogs":
                return r.filter && r.filter.address != null && (r.filter.address = oa(r.filter.address)), ["eth_getLogs", [r.filter]]
        }
        return null
    }
    perform(e, r) {
        return Wn(this, void 0, void 0, function* () {
            if (e === "call" || e === "estimateGas") {
                const i = r.transaction
                if (i && i.type != null && ce.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
                    const s = yield this.getFeeData()
                    s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && ((r = Pt(r)), (r.transaction = Pt(i)), delete r.transaction.type)
                }
            }
            const n = this.prepareRequest(e, r)
            n == null && rr.throwError(e + " not implemented", F.errors.NOT_IMPLEMENTED, { operation: e })
            try {
                return yield this.send(n[0], n[1])
            } catch (i) {
                return Tx(e, i, r)
            }
        })
    }
    _startEvent(e) {
        e.tag === "pending" && this._startPending(), super._startEvent(e)
    }
    _startPending() {
        if (this._pendingFilter != null) return
        const e = this,
            r = this.send("eth_newPendingTransactionFilter", [])
        ;(this._pendingFilter = r),
            r
                .then(function (n) {
                    function i() {
                        e.send("eth_getFilterChanges", [n])
                            .then(function (s) {
                                if (e._pendingFilter != r) return null
                                let o = Promise.resolve()
                                return (
                                    s.forEach(function (a) {
                                        ;(e._emitted["t:" + a.toLowerCase()] = "pending"),
                                            (o = o.then(function () {
                                                return e.getTransaction(a).then(function (l) {
                                                    return e.emit("pending", l), null
                                                })
                                            }))
                                    }),
                                    o.then(function () {
                                        return Qp(1e3)
                                    })
                                )
                            })
                            .then(function () {
                                if (e._pendingFilter != r) {
                                    e.send("eth_uninstallFilter", [n])
                                    return
                                }
                                return (
                                    setTimeout(function () {
                                        i()
                                    }, 0),
                                    null
                                )
                            })
                            .catch((s) => {})
                    }
                    return i(), n
                })
                .catch((n) => {})
    }
    _stopEvent(e) {
        e.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(e)
    }
    static hexlifyTransaction(e, r) {
        const n = Pt(s8)
        if (r) for (const s in r) r[s] && (n[s] = !0)
        b0(e, n)
        const i = {}
        return (
            ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (s) {
                if (e[s] == null) return
                const o = al(e[s])
                s === "gasLimit" && (s = "gas"), (i[s] = o)
            }),
            ["from", "to", "data"].forEach(function (s) {
                e[s] != null && (i[s] = pe(e[s]))
            }),
            e.accessList && (i.accessList = Zi(e.accessList)),
            i
        )
    }
}
let $a = null
try {
    if ((($a = WebSocket), $a == null)) throw new Error("inject please")
} catch {
    const e = new F(mr)
    $a = function () {
        e.throwError("WebSockets not supported in this environment", F.errors.UNSUPPORTED_OPERATION, { operation: "new WebSocket()" })
    }
}
var gu =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const Rl = new F(mr)
let o8 = 1
class af extends li {
    constructor(e, r) {
        r === "any" &&
            Rl.throwError("WebSocketProvider does not support 'any' network yet", F.errors.UNSUPPORTED_OPERATION, { operation: "network:any" })
        super(e, r)
        ;(this._pollingInterval = -1),
            (this._wsReady = !1),
            X(this, "_websocket", new $a(this.connection.url)),
            X(this, "_requests", {}),
            X(this, "_subs", {}),
            X(this, "_subIds", {}),
            X(this, "_detectNetwork", super.detectNetwork()),
            (this._websocket.onopen = () => {
                ;(this._wsReady = !0),
                    Object.keys(this._requests).forEach((i) => {
                        this._websocket.send(this._requests[i].payload)
                    })
            }),
            (this._websocket.onmessage = (i) => {
                const s = i.data,
                    o = JSON.parse(s)
                if (o.id != null) {
                    const a = String(o.id),
                        l = this._requests[a]
                    if ((delete this._requests[a], o.result !== void 0))
                        l.callback(null, o.result),
                            this.emit("debug", { action: "response", request: JSON.parse(l.payload), response: o.result, provider: this })
                    else {
                        let c = null
                        o.error
                            ? ((c = new Error(o.error.message || "unknown error")), X(c, "code", o.error.code || null), X(c, "response", s))
                            : (c = new Error("unknown error")),
                            l.callback(c, void 0),
                            this.emit("debug", { action: "response", error: c, request: JSON.parse(l.payload), provider: this })
                    }
                } else if (o.method === "eth_subscription") {
                    const a = this._subs[o.params.subscription]
                    a && a.processFunc(o.params.result)
                } else console.warn("this should not happen")
            })
        const n = setInterval(() => {
            this.emit("poll")
        }, 1e3)
        n.unref && n.unref()
    }
    detectNetwork() {
        return this._detectNetwork
    }
    get pollingInterval() {
        return 0
    }
    resetEventsBlock(e) {
        Rl.throwError("cannot reset events block on WebSocketProvider", F.errors.UNSUPPORTED_OPERATION, { operation: "resetEventBlock" })
    }
    set pollingInterval(e) {
        Rl.throwError("cannot set polling interval on WebSocketProvider", F.errors.UNSUPPORTED_OPERATION, { operation: "setPollingInterval" })
    }
    poll() {
        return gu(this, void 0, void 0, function* () {
            return null
        })
    }
    set polling(e) {
        !e || Rl.throwError("cannot set polling on WebSocketProvider", F.errors.UNSUPPORTED_OPERATION, { operation: "setPolling" })
    }
    send(e, r) {
        const n = o8++
        return new Promise((i, s) => {
            function o(l, c) {
                return l ? s(l) : i(c)
            }
            const a = JSON.stringify({ method: e, params: r, id: n, jsonrpc: "2.0" })
            this.emit("debug", { action: "request", request: JSON.parse(a), provider: this }),
                (this._requests[String(n)] = { callback: o, payload: a }),
                this._wsReady && this._websocket.send(a)
        })
    }
    static defaultUrl() {
        return "ws://localhost:8546"
    }
    _subscribe(e, r, n) {
        return gu(this, void 0, void 0, function* () {
            let i = this._subIds[e]
            i == null && ((i = Promise.all(r).then((o) => this.send("eth_subscribe", o))), (this._subIds[e] = i))
            const s = yield i
            this._subs[s] = { tag: e, processFunc: n }
        })
    }
    _startEvent(e) {
        switch (e.type) {
            case "block":
                this._subscribe("block", ["newHeads"], (r) => {
                    const n = ce.from(r.number).toNumber()
                    ;(this._emitted.block = n), this.emit("block", n)
                })
                break
            case "pending":
                this._subscribe("pending", ["newPendingTransactions"], (r) => {
                    this.emit("pending", r)
                })
                break
            case "filter":
                this._subscribe(e.tag, ["logs", this._getFilter(e.filter)], (r) => {
                    r.removed == null && (r.removed = !1), this.emit(e.filter, this.formatter.filterLog(r))
                })
                break
            case "tx": {
                const r = (n) => {
                    const i = n.hash
                    this.getTransactionReceipt(i).then((s) => {
                        !s || this.emit(i, s)
                    })
                }
                r(e),
                    this._subscribe("tx", ["newHeads"], (n) => {
                        this._events.filter((i) => i.type === "tx").forEach(r)
                    })
                break
            }
            case "debug":
            case "poll":
            case "willPoll":
            case "didPoll":
            case "error":
                break
            default:
                console.log("unhandled:", e)
                break
        }
    }
    _stopEvent(e) {
        let r = e.tag
        if (e.type === "tx") {
            if (this._events.filter((i) => i.type === "tx").length) return
            r = "tx"
        } else if (this.listenerCount(e.event)) return
        const n = this._subIds[r]
        !n ||
            (delete this._subIds[r],
            n.then((i) => {
                !this._subs[i] || (delete this._subs[i], this.send("eth_unsubscribe", [i]))
            }))
    }
    destroy() {
        return gu(this, void 0, void 0, function* () {
            this._websocket.readyState === $a.CONNECTING &&
                (yield new Promise((e) => {
                    ;(this._websocket.onopen = function () {
                        e(!0)
                    }),
                        (this._websocket.onerror = function () {
                            e(!1)
                        })
                })),
                this._websocket.close(1e3)
        })
    }
}
var a8 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const ma = new F(mr)
class Cx extends li {
    detectNetwork() {
        const e = Object.create(null, { detectNetwork: { get: () => super.detectNetwork } })
        return a8(this, void 0, void 0, function* () {
            let r = this.network
            return (
                r == null &&
                    ((r = yield e.detectNetwork.call(this)),
                    r || ma.throwError("no network detected", F.errors.UNKNOWN_ERROR, {}),
                    this._network == null && (X(this, "_network", r), this.emit("network", r, null))),
                r
            )
        })
    }
}
class Qi extends Cx {
    constructor(e, r) {
        ma.checkAbstract(new.target, Qi), (e = Yt(new.target, "getNetwork")(e)), (r = Yt(new.target, "getApiKey")(r))
        const n = Yt(new.target, "getUrl")(e, r)
        super(n, e)
        typeof r == "string"
            ? X(this, "apiKey", r)
            : r != null &&
              Object.keys(r).forEach((i) => {
                  X(this, i, r[i])
              })
    }
    _startPending() {
        ma.warn("WARNING: API provider does not support pending filters")
    }
    isCommunityResource() {
        return !1
    }
    getSigner(e) {
        return ma.throwError("API provider does not support signing", F.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" })
    }
    listAccounts() {
        return Promise.resolve([])
    }
    static getApiKey(e) {
        return e
    }
    static getUrl(e, r) {
        return ma.throwError("not implemented; sub-classes must override getUrl", F.errors.NOT_IMPLEMENTED, { operation: "getUrl" })
    }
}
const eg = new F(mr),
    nc = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC"
class kx extends af {
    constructor(e, r) {
        const n = new V0(e, r),
            i = n.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.")
        super(i, n.network)
        X(this, "apiKey", n.apiKey)
    }
    isCommunityResource() {
        return this.apiKey === nc
    }
}
class V0 extends Qi {
    static getWebSocketProvider(e, r) {
        return new kx(e, r)
    }
    static getApiKey(e) {
        return e == null ? nc : (e && typeof e != "string" && eg.throwArgumentError("invalid apiKey", "apiKey", e), e)
    }
    static getUrl(e, r) {
        let n = null
        switch (e.name) {
            case "homestead":
                n = "eth-mainnet.alchemyapi.io/v2/"
                break
            case "ropsten":
                n = "eth-ropsten.alchemyapi.io/v2/"
                break
            case "rinkeby":
                n = "eth-rinkeby.alchemyapi.io/v2/"
                break
            case "goerli":
                n = "eth-goerli.alchemyapi.io/v2/"
                break
            case "kovan":
                n = "eth-kovan.alchemyapi.io/v2/"
                break
            case "matic":
                n = "polygon-mainnet.g.alchemy.com/v2/"
                break
            case "maticmum":
                n = "polygon-mumbai.g.alchemy.com/v2/"
                break
            case "arbitrum":
                n = "arb-mainnet.g.alchemy.com/v2/"
                break
            case "arbitrum-rinkeby":
                n = "arb-rinkeby.g.alchemy.com/v2/"
                break
            case "optimism":
                n = "opt-mainnet.g.alchemy.com/v2/"
                break
            case "optimism-kovan":
                n = "opt-kovan.g.alchemy.com/v2/"
                break
            default:
                eg.throwArgumentError("unsupported network", "network", arguments[0])
        }
        return { allowGzip: !0, url: "https://" + n + r, throttleCallback: (i, s) => (r === nc && sf(), Promise.resolve(!0)) }
    }
    isCommunityResource() {
        return this.apiKey === nc
    }
}
var l8 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const tg = new F(mr)
class Nx extends Qi {
    static getApiKey(e) {
        return e != null && tg.throwArgumentError("apiKey not supported for cloudflare", "apiKey", e), null
    }
    static getUrl(e, r) {
        let n = null
        switch (e.name) {
            case "homestead":
                n = "https://cloudflare-eth.com/"
                break
            default:
                tg.throwArgumentError("unsupported network", "network", arguments[0])
        }
        return n
    }
    perform(e, r) {
        const n = Object.create(null, { perform: { get: () => super.perform } })
        return l8(this, void 0, void 0, function* () {
            return e === "getBlockNumber" ? (yield n.perform.call(this, "getBlock", { blockTag: "latest" })).number : n.perform.call(this, e, r)
        })
    }
}
var Ll =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const Zn = new F(mr)
function rg(t) {
    const e = {}
    for (let r in t) {
        if (t[r] == null) continue
        let n = t[r]
        ;(r === "type" && n === 0) ||
            ({ type: !0, gasLimit: !0, gasPrice: !0, maxFeePerGs: !0, maxPriorityFeePerGas: !0, nonce: !0, value: !0 }[r]
                ? (n = al(pe(n)))
                : r === "accessList"
                ? (n =
                      "[" +
                      Zi(n)
                          .map((i) => `{address:"${i.address}",storageKeys:["${i.storageKeys.join('","')}"]}`)
                          .join(",") +
                      "]")
                : (n = pe(n)),
            (e[r] = n))
    }
    return e
}
function c8(t) {
    if (t.status == 0 && (t.message === "No records found" || t.message === "No transactions found")) return t.result
    if (t.status != 1 || t.message != "OK") {
        const e = new Error("invalid response")
        throw ((e.result = JSON.stringify(t)), (t.result || "").toLowerCase().indexOf("rate limit") >= 0 && (e.throttleRetry = !0), e)
    }
    return t.result
}
function ng(t) {
    if (t && t.status == 0 && t.message == "NOTOK" && (t.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        const e = new Error("throttled response")
        throw ((e.result = JSON.stringify(t)), (e.throttleRetry = !0), e)
    }
    if (t.jsonrpc != "2.0") {
        const e = new Error("invalid response")
        throw ((e.result = JSON.stringify(t)), e)
    }
    if (t.error) {
        const e = new Error(t.error.message || "unknown error")
        throw (t.error.code && (e.code = t.error.code), t.error.data && (e.data = t.error.data), e)
    }
    return t.result
}
function ig(t) {
    if (t === "pending") throw new Error("pending not supported")
    return t === "latest" ? t : parseInt(t.substring(2), 16)
}
const sg = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB"
function mu(t, e, r) {
    if (t === "call" && e.code === F.errors.SERVER_ERROR) {
        const i = e.error
        if (i && (i.message.match(/reverted/i) || i.message.match(/VM execution error/i))) {
            let s = i.data
            if ((s && (s = "0x" + s.replace(/^.*0x/i, "")), Le(s))) return s
            Zn.throwError("missing revert data in call exception", F.errors.CALL_EXCEPTION, { error: e, data: "0x" })
        }
    }
    let n = e.message
    throw (
        (e.code === F.errors.SERVER_ERROR &&
            (e.error && typeof e.error.message == "string"
                ? (n = e.error.message)
                : typeof e.body == "string"
                ? (n = e.body)
                : typeof e.responseText == "string" && (n = e.responseText)),
        (n = (n || "").toLowerCase()),
        n.match(/insufficient funds/) &&
            Zn.throwError("insufficient funds for intrinsic transaction cost", F.errors.INSUFFICIENT_FUNDS, {
                error: e,
                method: t,
                transaction: r,
            }),
        n.match(/same hash was already imported|transaction nonce is too low|nonce too low/) &&
            Zn.throwError("nonce has already been used", F.errors.NONCE_EXPIRED, { error: e, method: t, transaction: r }),
        n.match(/another transaction with same nonce/) &&
            Zn.throwError("replacement fee too low", F.errors.REPLACEMENT_UNDERPRICED, { error: e, method: t, transaction: r }),
        n.match(/execution failed due to an exception|execution reverted/) &&
            Zn.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", F.errors.UNPREDICTABLE_GAS_LIMIT, {
                error: e,
                method: t,
                transaction: r,
            }),
        e)
    )
}
class lf extends of {
    constructor(e, r) {
        Zn.checkNew(new.target, lf)
        super(e)
        X(this, "baseUrl", this.getBaseUrl()), X(this, "apiKey", r || sg)
    }
    getBaseUrl() {
        switch (this.network ? this.network.name : "invalid") {
            case "homestead":
                return "https://api.etherscan.io"
            case "ropsten":
                return "https://api-ropsten.etherscan.io"
            case "rinkeby":
                return "https://api-rinkeby.etherscan.io"
            case "kovan":
                return "https://api-kovan.etherscan.io"
            case "goerli":
                return "https://api-goerli.etherscan.io"
        }
        return Zn.throwArgumentError("unsupported network", "network", name)
    }
    getUrl(e, r) {
        const n = Object.keys(r).reduce((s, o) => {
                const a = r[o]
                return a != null && (s += `&${o}=${a}`), s
            }, ""),
            i = this.apiKey ? `&apikey=${this.apiKey}` : ""
        return `${this.baseUrl}/api?module=${e}${n}${i}`
    }
    getPostUrl() {
        return `${this.baseUrl}/api`
    }
    getPostData(e, r) {
        return (r.module = e), (r.apikey = this.apiKey), r
    }
    fetch(e, r, n) {
        return Ll(this, void 0, void 0, function* () {
            const i = n ? this.getPostUrl() : this.getUrl(e, r),
                s = n ? this.getPostData(e, r) : null,
                o = e === "proxy" ? ng : c8
            this.emit("debug", { action: "request", request: i, provider: this })
            const a = {
                url: i,
                throttleSlotInterval: 1e3,
                throttleCallback: (f, u) => (this.isCommunityResource() && sf(), Promise.resolve(!0)),
            }
            let l = null
            s &&
                ((a.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" }),
                (l = Object.keys(s)
                    .map((f) => `${f}=${s[f]}`)
                    .join("&")))
            const c = yield dl(a, l, o || ng)
            return this.emit("debug", { action: "response", request: i, response: pr(c), provider: this }), c
        })
    }
    detectNetwork() {
        return Ll(this, void 0, void 0, function* () {
            return this.network
        })
    }
    perform(e, r) {
        const n = Object.create(null, { perform: { get: () => super.perform } })
        return Ll(this, void 0, void 0, function* () {
            switch (e) {
                case "getBlockNumber":
                    return this.fetch("proxy", { action: "eth_blockNumber" })
                case "getGasPrice":
                    return this.fetch("proxy", { action: "eth_gasPrice" })
                case "getBalance":
                    return this.fetch("account", { action: "balance", address: r.address, tag: r.blockTag })
                case "getTransactionCount":
                    return this.fetch("proxy", { action: "eth_getTransactionCount", address: r.address, tag: r.blockTag })
                case "getCode":
                    return this.fetch("proxy", { action: "eth_getCode", address: r.address, tag: r.blockTag })
                case "getStorageAt":
                    return this.fetch("proxy", { action: "eth_getStorageAt", address: r.address, position: r.position, tag: r.blockTag })
                case "sendTransaction":
                    return this.fetch("proxy", { action: "eth_sendRawTransaction", hex: r.signedTransaction }, !0).catch((i) =>
                        mu("sendTransaction", i, r.signedTransaction)
                    )
                case "getBlock":
                    if (r.blockTag)
                        return this.fetch("proxy", {
                            action: "eth_getBlockByNumber",
                            tag: r.blockTag,
                            boolean: r.includeTransactions ? "true" : "false",
                        })
                    throw new Error("getBlock by blockHash not implemented")
                case "getTransaction":
                    return this.fetch("proxy", { action: "eth_getTransactionByHash", txhash: r.transactionHash })
                case "getTransactionReceipt":
                    return this.fetch("proxy", { action: "eth_getTransactionReceipt", txhash: r.transactionHash })
                case "call": {
                    if (r.blockTag !== "latest") throw new Error("EtherscanProvider does not support blockTag for call")
                    const i = rg(r.transaction)
                    ;(i.module = "proxy"), (i.action = "eth_call")
                    try {
                        return yield this.fetch("proxy", i, !0)
                    } catch (s) {
                        return mu("call", s, r.transaction)
                    }
                }
                case "estimateGas": {
                    const i = rg(r.transaction)
                    ;(i.module = "proxy"), (i.action = "eth_estimateGas")
                    try {
                        return yield this.fetch("proxy", i, !0)
                    } catch (s) {
                        return mu("estimateGas", s, r.transaction)
                    }
                }
                case "getLogs": {
                    const i = { action: "getLogs" }
                    if (
                        (r.filter.fromBlock && (i.fromBlock = ig(r.filter.fromBlock)),
                        r.filter.toBlock && (i.toBlock = ig(r.filter.toBlock)),
                        r.filter.address && (i.address = r.filter.address),
                        r.filter.topics &&
                            r.filter.topics.length > 0 &&
                            (r.filter.topics.length > 1 &&
                                Zn.throwError("unsupported topic count", F.errors.UNSUPPORTED_OPERATION, { topics: r.filter.topics }),
                            r.filter.topics.length === 1))
                    ) {
                        const a = r.filter.topics[0]
                        ;(typeof a != "string" || a.length !== 66) &&
                            Zn.throwError("unsupported topic format", F.errors.UNSUPPORTED_OPERATION, { topic0: a }),
                            (i.topic0 = a)
                    }
                    const s = yield this.fetch("logs", i)
                    let o = {}
                    for (let a = 0; a < s.length; a++) {
                        const l = s[a]
                        if (l.blockHash == null) {
                            if (o[l.blockNumber] == null) {
                                const c = yield this.getBlock(l.blockNumber)
                                c && (o[l.blockNumber] = c.hash)
                            }
                            l.blockHash = o[l.blockNumber]
                        }
                    }
                    return s
                }
                case "getEtherPrice":
                    return this.network.name !== "homestead" ? 0 : parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd)
            }
            return n.perform.call(this, e, r)
        })
    }
    getHistory(e, r, n) {
        return Ll(this, void 0, void 0, function* () {
            const i = {
                action: "txlist",
                address: yield this.resolveName(e),
                startblock: r == null ? 0 : r,
                endblock: n == null ? 99999999 : n,
                sort: "asc",
            }
            return (yield this.fetch("account", i)).map((o) => {
                ;["contractAddress", "to"].forEach(function (l) {
                    o[l] == "" && delete o[l]
                }),
                    o.creates == null && o.contractAddress != null && (o.creates = o.contractAddress)
                const a = this.formatter.transactionResponse(o)
                return o.timeStamp && (a.timestamp = parseInt(o.timeStamp)), a
            })
        })
    }
    isCommunityResource() {
        return this.apiKey === sg
    }
}
var Nc =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function a(f) {
                try {
                    c(n.next(f))
                } catch (u) {
                    o(u)
                }
            }
            function l(f) {
                try {
                    c(n.throw(f))
                } catch (u) {
                    o(u)
                }
            }
            function c(f) {
                f.done ? s(f.value) : i(f.value).then(a, l)
            }
            c((n = n.apply(t, e || [])).next())
        })
    }
const Pi = new F(mr)
function Dl() {
    return new Date().getTime()
}
function og(t) {
    let e = null
    for (let r = 0; r < t.length; r++) {
        const n = t[r]
        if (n == null) return null
        e
            ? (e.name === n.name &&
                  e.chainId === n.chainId &&
                  (e.ensAddress === n.ensAddress || (e.ensAddress == null && n.ensAddress == null))) ||
              Pi.throwArgumentError("provider mismatch", "networks", t)
            : (e = n)
    }
    return e
}
function ag(t, e) {
    t = t.slice().sort()
    const r = Math.floor(t.length / 2)
    if (t.length % 2) return t[r]
    const n = t[r - 1],
        i = t[r]
    return e != null && Math.abs(n - i) > e ? null : (n + i) / 2
}
function uo(t) {
    if (t === null) return "null"
    if (typeof t == "number" || typeof t == "boolean") return JSON.stringify(t)
    if (typeof t == "string") return t
    if (ce.isBigNumber(t)) return t.toString()
    if (Array.isArray(t)) return JSON.stringify(t.map((e) => uo(e)))
    if (typeof t == "object") {
        const e = Object.keys(t)
        return (
            e.sort(),
            "{" +
                e
                    .map((r) => {
                        let n = t[r]
                        return typeof n == "function" ? (n = "[function]") : (n = uo(n)), JSON.stringify(r) + ":" + n
                    })
                    .join(",") +
                "}"
        )
    }
    throw new Error("unknown value type: " + typeof t)
}
let f8 = 1
function lg(t) {
    let e = null,
        r = null,
        n = new Promise((o) => {
            ;(e = function () {
                r && (clearTimeout(r), (r = null)), o()
            }),
                (r = setTimeout(e, t))
        })
    const i = (o) => ((n = n.then(o)), n)
    function s() {
        return n
    }
    return { cancel: e, getPromise: s, wait: i }
}
const u8 = [
        F.errors.CALL_EXCEPTION,
        F.errors.INSUFFICIENT_FUNDS,
        F.errors.NONCE_EXPIRED,
        F.errors.REPLACEMENT_UNDERPRICED,
        F.errors.UNPREDICTABLE_GAS_LIMIT,
    ],
    d8 = ["address", "args", "errorArgs", "errorSignature", "method", "transaction"]
function Fl(t, e) {
    const r = { weight: t.weight }
    return (
        Object.defineProperty(r, "provider", { get: () => t.provider }),
        t.start && (r.start = t.start),
        e && (r.duration = e - t.start),
        t.done && (t.error ? (r.error = t.error) : (r.result = t.result || null)),
        r
    )
}
function h8(t, e) {
    return function (r) {
        const n = {}
        r.forEach((s) => {
            const o = t(s.result)
            n[o] || (n[o] = { count: 0, result: s.result }), n[o].count++
        })
        const i = Object.keys(n)
        for (let s = 0; s < i.length; s++) {
            const o = n[i[s]]
            if (o.count >= e) return o.result
        }
    }
}
function p8(t, e, r) {
    let n = uo
    switch (e) {
        case "getBlockNumber":
            return function (i) {
                const s = i.map((a) => a.result)
                let o = ag(
                    i.map((a) => a.result),
                    2
                )
                if (o != null)
                    return (
                        (o = Math.ceil(o)),
                        s.indexOf(o + 1) >= 0 && o++,
                        o >= t._highestBlockNumber && (t._highestBlockNumber = o),
                        t._highestBlockNumber
                    )
            }
        case "getGasPrice":
            return function (i) {
                const s = i.map((o) => o.result)
                return s.sort(), s[Math.floor(s.length / 2)]
            }
        case "getEtherPrice":
            return function (i) {
                return ag(i.map((s) => s.result))
            }
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorageAt":
        case "call":
        case "estimateGas":
        case "getLogs":
            break
        case "getTransaction":
        case "getTransactionReceipt":
            n = function (i) {
                return i == null ? null : ((i = Pt(i)), (i.confirmations = -1), uo(i))
            }
            break
        case "getBlock":
            r.includeTransactions
                ? (n = function (i) {
                      return i == null
                          ? null
                          : ((i = Pt(i)), (i.transactions = i.transactions.map((s) => ((s = Pt(s)), (s.confirmations = -1), s))), uo(i))
                  })
                : (n = function (i) {
                      return i == null ? null : uo(i)
                  })
            break
        default:
            throw new Error("unknown method: " + e)
    }
    return h8(n, t.quorum)
}
function aa(t, e) {
    return Nc(this, void 0, void 0, function* () {
        const r = t.provider
        return (r.blockNumber != null && r.blockNumber >= e) || e === -1
            ? r
            : Ts(
                  () =>
                      new Promise((n, i) => {
                          setTimeout(function () {
                              return r.blockNumber >= e ? n(r) : t.cancelled ? n(null) : n(void 0)
                          }, 0)
                      }),
                  { oncePoll: r }
              )
    })
}
function g8(t, e, r, n) {
    return Nc(this, void 0, void 0, function* () {
        let i = t.provider
        switch (r) {
            case "getBlockNumber":
            case "getGasPrice":
                return i[r]()
            case "getEtherPrice":
                if (i.getEtherPrice) return i.getEtherPrice()
                break
            case "getBalance":
            case "getTransactionCount":
            case "getCode":
                return n.blockTag && Le(n.blockTag) && (i = yield aa(t, e)), i[r](n.address, n.blockTag || "latest")
            case "getStorageAt":
                return n.blockTag && Le(n.blockTag) && (i = yield aa(t, e)), i.getStorageAt(n.address, n.position, n.blockTag || "latest")
            case "getBlock":
                return (
                    n.blockTag && Le(n.blockTag) && (i = yield aa(t, e)),
                    i[n.includeTransactions ? "getBlockWithTransactions" : "getBlock"](n.blockTag || n.blockHash)
                )
            case "call":
            case "estimateGas":
                return n.blockTag && Le(n.blockTag) && (i = yield aa(t, e)), i[r](n.transaction)
            case "getTransaction":
            case "getTransactionReceipt":
                return i[r](n.transactionHash)
            case "getLogs": {
                let s = n.filter
                return ((s.fromBlock && Le(s.fromBlock)) || (s.toBlock && Le(s.toBlock))) && (i = yield aa(t, e)), i.getLogs(s)
            }
        }
        return Pi.throwError("unknown method error", F.errors.UNKNOWN_ERROR, { method: r, params: n })
    })
}
class cf extends of {
    constructor(e, r) {
        Pi.checkNew(new.target, cf), e.length === 0 && Pi.throwArgumentError("missing providers", "providers", e)
        const n = e.map((o, a) => {
                if (qi.isProvider(o)) {
                    const f = md(o) ? 2e3 : 750
                    return Object.freeze({ provider: o, weight: 1, stallTimeout: f, priority: 1 })
                }
                const l = Pt(o)
                l.priority == null && (l.priority = 1),
                    l.stallTimeout == null && (l.stallTimeout = md(o) ? 2e3 : 750),
                    l.weight == null && (l.weight = 1)
                const c = l.weight
                return (
                    (c % 1 || c > 512 || c < 1) &&
                        Pi.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${a}].weight`, c),
                    Object.freeze(l)
                )
            }),
            i = n.reduce((o, a) => o + a.weight, 0)
        r == null ? (r = i / 2) : r > i && Pi.throwArgumentError("quorum will always fail; larger than total weight", "quorum", r)
        let s = og(n.map((o) => o.provider.network))
        s == null &&
            (s = new Promise((o, a) => {
                setTimeout(() => {
                    this.detectNetwork().then(o, a)
                }, 0)
            }))
        super(s)
        X(this, "providerConfigs", Object.freeze(n)), X(this, "quorum", r), (this._highestBlockNumber = -1)
    }
    detectNetwork() {
        return Nc(this, void 0, void 0, function* () {
            const e = yield Promise.all(this.providerConfigs.map((r) => r.provider.getNetwork()))
            return og(e)
        })
    }
    perform(e, r) {
        return Nc(this, void 0, void 0, function* () {
            if (e === "sendTransaction") {
                const l = yield Promise.all(
                    this.providerConfigs.map((c) =>
                        c.provider.sendTransaction(r.signedTransaction).then(
                            (f) => f.hash,
                            (f) => f
                        )
                    )
                )
                for (let c = 0; c < l.length; c++) {
                    const f = l[c]
                    if (typeof f == "string") return f
                }
                throw l[0]
            }
            this._highestBlockNumber === -1 && e !== "getBlockNumber" && (yield this.getBlockNumber())
            const n = p8(this, e, r),
                i = fx(this.providerConfigs.map(Pt))
            i.sort((l, c) => l.priority - c.priority)
            const s = this._highestBlockNumber
            let o = 0,
                a = !0
            for (;;) {
                const l = Dl()
                let c = i.filter((m) => m.runner && l - m.start < m.stallTimeout).reduce((m, y) => m + y.weight, 0)
                for (; c < this.quorum && o < i.length; ) {
                    const m = i[o++],
                        y = f8++
                    ;(m.start = Dl()),
                        (m.staller = lg(m.stallTimeout)),
                        m.staller.wait(() => {
                            m.staller = null
                        }),
                        (m.runner = g8(m, s, e, r).then(
                            (v) => {
                                ;(m.done = !0),
                                    (m.result = v),
                                    this.listenerCount("debug") &&
                                        this.emit("debug", {
                                            action: "request",
                                            rid: y,
                                            backend: Fl(m, Dl()),
                                            request: { method: e, params: pr(r) },
                                            provider: this,
                                        })
                            },
                            (v) => {
                                ;(m.done = !0),
                                    (m.error = v),
                                    this.listenerCount("debug") &&
                                        this.emit("debug", {
                                            action: "request",
                                            rid: y,
                                            backend: Fl(m, Dl()),
                                            request: { method: e, params: pr(r) },
                                            provider: this,
                                        })
                            }
                        )),
                        this.listenerCount("debug") &&
                            this.emit("debug", {
                                action: "request",
                                rid: y,
                                backend: Fl(m, null),
                                request: { method: e, params: pr(r) },
                                provider: this,
                            }),
                        (c += m.weight)
                }
                const f = []
                i.forEach((m) => {
                    m.done || !m.runner || (f.push(m.runner), m.staller && f.push(m.staller.getPromise()))
                }),
                    f.length && (yield Promise.race(f))
                const u = i.filter((m) => m.done && m.error == null)
                if (u.length >= this.quorum) {
                    const m = n(u)
                    if (m !== void 0)
                        return (
                            i.forEach((y) => {
                                y.staller && y.staller.cancel(), (y.cancelled = !0)
                            }),
                            m
                        )
                    a || (yield lg(100).getPromise()), (a = !1)
                }
                const p = i.reduce((m, y) => {
                    if (!y.done || y.error == null) return m
                    const v = y.error.code
                    return u8.indexOf(v) >= 0 && (m[v] || (m[v] = { error: y.error, weight: 0 }), (m[v].weight += y.weight)), m
                }, {})
                if (
                    (Object.keys(p).forEach((m) => {
                        const y = p[m]
                        if (y.weight < this.quorum) return
                        i.forEach((C) => {
                            C.staller && C.staller.cancel(), (C.cancelled = !0)
                        })
                        const v = y.error,
                            _ = {}
                        d8.forEach((C) => {
                            v[C] != null && (_[C] = v[C])
                        }),
                            Pi.throwError(v.reason || v.message, m, _)
                    }),
                    i.filter((m) => !m.done).length === 0)
                )
                    break
            }
            return (
                i.forEach((l) => {
                    l.staller && l.staller.cancel(), (l.cancelled = !0)
                }),
                Pi.throwError("failed to meet quorum", F.errors.SERVER_ERROR, {
                    method: e,
                    params: r,
                    results: i.map((l) => Fl(l)),
                    provider: this,
                })
            )
        })
    }
}
const Px = null,
    ic = new F(mr),
    ba = "84842078b09946638c03157f83405213"
class Ix extends af {
    constructor(e, r) {
        const n = new U0(e, r),
            i = n.connection
        i.password &&
            ic.throwError("INFURA WebSocket project secrets unsupported", F.errors.UNSUPPORTED_OPERATION, {
                operation: "InfuraProvider.getWebSocketProvider()",
            })
        const s = i.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/")
        super(s, e)
        X(this, "apiKey", n.projectId), X(this, "projectId", n.projectId), X(this, "projectSecret", n.projectSecret)
    }
    isCommunityResource() {
        return this.projectId === ba
    }
}
class U0 extends Qi {
    static getWebSocketProvider(e, r) {
        return new Ix(e, r)
    }
    static getApiKey(e) {
        const r = { apiKey: ba, projectId: ba, projectSecret: null }
        return (
            e == null ||
                (typeof e == "string"
                    ? (r.projectId = e)
                    : e.projectSecret != null
                    ? (ic.assertArgument(typeof e.projectId == "string", "projectSecret requires a projectId", "projectId", e.projectId),
                      ic.assertArgument(typeof e.projectSecret == "string", "invalid projectSecret", "projectSecret", "[REDACTED]"),
                      (r.projectId = e.projectId),
                      (r.projectSecret = e.projectSecret))
                    : e.projectId && (r.projectId = e.projectId),
                (r.apiKey = r.projectId)),
            r
        )
    }
    static getUrl(e, r) {
        let n = null
        switch (e ? e.name : "unknown") {
            case "homestead":
                n = "mainnet.infura.io"
                break
            case "ropsten":
                n = "ropsten.infura.io"
                break
            case "rinkeby":
                n = "rinkeby.infura.io"
                break
            case "kovan":
                n = "kovan.infura.io"
                break
            case "goerli":
                n = "goerli.infura.io"
                break
            case "matic":
                n = "polygon-mainnet.infura.io"
                break
            case "maticmum":
                n = "polygon-mumbai.infura.io"
                break
            case "optimism":
                n = "optimism-mainnet.infura.io"
                break
            case "optimism-kovan":
                n = "optimism-kovan.infura.io"
                break
            case "arbitrum":
                n = "arbitrum-mainnet.infura.io"
                break
            case "arbitrum-rinkeby":
                n = "arbitrum-rinkeby.infura.io"
                break
            default:
                ic.throwError("unsupported network", F.errors.INVALID_ARGUMENT, { argument: "network", value: e })
        }
        const i = {
            allowGzip: !0,
            url: "https://" + n + "/v3/" + r.projectId,
            throttleCallback: (s, o) => (r.projectId === ba && sf(), Promise.resolve(!0)),
        }
        return r.projectSecret != null && ((i.user = ""), (i.password = r.projectSecret)), i
    }
    isCommunityResource() {
        return this.projectId === ba
    }
}
class m8 extends li {
    send(e, r) {
        const n = { method: e, params: r, id: this._nextId++, jsonrpc: "2.0" }
        this._pendingBatch == null && (this._pendingBatch = [])
        const i = { request: n, resolve: null, reject: null },
            s = new Promise((o, a) => {
                ;(i.resolve = o), (i.reject = a)
            })
        return (
            this._pendingBatch.push(i),
            this._pendingBatchAggregator ||
                (this._pendingBatchAggregator = setTimeout(() => {
                    const o = this._pendingBatch
                    ;(this._pendingBatch = null), (this._pendingBatchAggregator = null)
                    const a = o.map((l) => l.request)
                    return (
                        this.emit("debug", { action: "requestBatch", request: pr(a), provider: this }),
                        dl(this.connection, JSON.stringify(a)).then(
                            (l) => {
                                this.emit("debug", { action: "response", request: a, response: l, provider: this }),
                                    o.forEach((c, f) => {
                                        const u = l[f]
                                        if (u.error) {
                                            const p = new Error(u.error.message)
                                            ;(p.code = u.error.code), (p.data = u.error.data), c.reject(p)
                                        } else c.resolve(u.result)
                                    })
                            },
                            (l) => {
                                this.emit("debug", { action: "response", error: l, request: a, provider: this }),
                                    o.forEach((c) => {
                                        c.reject(l)
                                    })
                            }
                        )
                    )
                }, 10)),
            s
        )
    }
}
const bu = new F(mr),
    b8 = "ETHERS_JS_SHARED"
class $x extends Qi {
    static getApiKey(e) {
        return e && typeof e != "string" && bu.throwArgumentError("invalid apiKey", "apiKey", e), e || b8
    }
    static getUrl(e, r) {
        bu.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.")
        let n = null
        switch (e.name) {
            case "homestead":
                n = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc"
                break
            case "ropsten":
                n = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc"
                break
            case "rinkeby":
                n = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc"
                break
            case "goerli":
                n = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc"
                break
            case "kovan":
                n = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc"
                break
            default:
                bu.throwArgumentError("unsupported network", "network", arguments[0])
        }
        return n + "?apiKey=" + r
    }
}
const gs = new F(mr),
    cg = {
        homestead: "6004bcd10040261633ade990",
        ropsten: "6004bd4d0040261633ade991",
        rinkeby: "6004bda20040261633ade994",
        goerli: "6004bd860040261633ade992",
    }
class Bx extends Qi {
    constructor(e, r) {
        if (r == null) {
            const n = Yt(new.target, "getNetwork")(e)
            if (n) {
                const i = cg[n.name]
                i && (r = { applicationId: i, loadBalancer: !0 })
            }
            r == null && gs.throwError("unsupported network", F.errors.INVALID_ARGUMENT, { argument: "network", value: e })
        }
        super(e, r)
    }
    static getApiKey(e) {
        e == null && gs.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", e)
        const r = { applicationId: null, loadBalancer: !1, applicationSecretKey: null }
        return (
            typeof e == "string"
                ? (r.applicationId = e)
                : e.applicationSecretKey != null
                ? (gs.assertArgument(
                      typeof e.applicationId == "string",
                      "applicationSecretKey requires an applicationId",
                      "applicationId",
                      e.applicationId
                  ),
                  gs.assertArgument(
                      typeof e.applicationSecretKey == "string",
                      "invalid applicationSecretKey",
                      "applicationSecretKey",
                      "[REDACTED]"
                  ),
                  (r.applicationId = e.applicationId),
                  (r.applicationSecretKey = e.applicationSecretKey),
                  (r.loadBalancer = !!e.loadBalancer))
                : e.applicationId
                ? (gs.assertArgument(
                      typeof e.applicationId == "string",
                      "apiKey.applicationId must be a string",
                      "apiKey.applicationId",
                      e.applicationId
                  ),
                  (r.applicationId = e.applicationId),
                  (r.loadBalancer = !!e.loadBalancer))
                : gs.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", e),
            r
        )
    }
    static getUrl(e, r) {
        let n = null
        switch (e ? e.name : "unknown") {
            case "homestead":
                n = "eth-mainnet.gateway.pokt.network"
                break
            case "ropsten":
                n = "eth-ropsten.gateway.pokt.network"
                break
            case "rinkeby":
                n = "eth-rinkeby.gateway.pokt.network"
                break
            case "goerli":
                n = "eth-goerli.gateway.pokt.network"
                break
            default:
                gs.throwError("unsupported network", F.errors.INVALID_ARGUMENT, { argument: "network", value: e })
        }
        let i = null
        r.loadBalancer ? (i = `https://${n}/v1/lb/${r.applicationId}`) : (i = `https://${n}/v1/${r.applicationId}`)
        const s = { url: i }
        return (s.headers = {}), r.applicationSecretKey != null && ((s.user = ""), (s.password = r.applicationSecretKey)), s
    }
    isCommunityResource() {
        return this.applicationId === cg[this.network.name]
    }
}
const xu = new F(mr)
let x8 = 1
function fg(t, e) {
    const r = "Web3LegacyFetcher"
    return function (n, i) {
        const s = { method: n, params: i, id: x8++, jsonrpc: "2.0" }
        return new Promise((o, a) => {
            this.emit("debug", { action: "request", fetcher: r, request: pr(s), provider: this }),
                e(s, (l, c) => {
                    if (l) return this.emit("debug", { action: "response", fetcher: r, error: l, request: s, provider: this }), a(l)
                    if ((this.emit("debug", { action: "response", fetcher: r, request: s, response: c, provider: this }), c.error)) {
                        const f = new Error(c.error.message)
                        return (f.code = c.error.code), (f.data = c.error.data), a(f)
                    }
                    o(c.result)
                })
        })
    }
}
function v8(t) {
    return function (e, r) {
        r == null && (r = [])
        const n = { method: e, params: r }
        return (
            this.emit("debug", { action: "request", fetcher: "Eip1193Fetcher", request: pr(n), provider: this }),
            t.request(n).then(
                (i) => (this.emit("debug", { action: "response", fetcher: "Eip1193Fetcher", request: n, response: i, provider: this }), i),
                (i) => {
                    throw (this.emit("debug", { action: "response", fetcher: "Eip1193Fetcher", request: n, error: i, provider: this }), i)
                }
            )
        )
    }
}
class ff extends li {
    constructor(e, r) {
        xu.checkNew(new.target, ff), e == null && xu.throwArgumentError("missing provider", "provider", e)
        let n = null,
            i = null,
            s = null
        typeof e == "function"
            ? ((n = "unknown:"), (i = e))
            : ((n = e.host || e.path || ""),
              !n && e.isMetaMask && (n = "metamask"),
              (s = e),
              e.request
                  ? (n === "" && (n = "eip-1193:"), (i = v8(e)))
                  : e.sendAsync
                  ? (i = fg(e, e.sendAsync.bind(e)))
                  : e.send
                  ? (i = fg(e, e.send.bind(e)))
                  : xu.throwArgumentError("unsupported provider", "provider", e),
              n || (n = "unknown:"))
        super(n, r)
        X(this, "jsonRpcFetchFunc", i), X(this, "provider", s)
    }
    send(e, r) {
        return this.jsonRpcFetchFunc(e, r)
    }
}
const ug = new F(mr)
function H0(t, e) {
    if ((t == null && (t = "homestead"), typeof t == "string")) {
        const n = t.match(/^(ws|http)s?:/i)
        if (n)
            switch (n[1]) {
                case "http":
                    return new li(t)
                case "ws":
                    return new af(t)
                default:
                    ug.throwArgumentError("unsupported URL scheme", "network", t)
            }
    }
    const r = F0(t)
    return (
        (!r || !r._defaultProvider) &&
            ug.throwError("unsupported getDefaultProvider network", F.errors.NETWORK_ERROR, { operation: "getDefaultProvider", network: t }),
        r._defaultProvider(
            {
                FallbackProvider: cf,
                AlchemyProvider: V0,
                CloudflareProvider: Nx,
                EtherscanProvider: lf,
                InfuraProvider: U0,
                JsonRpcProvider: li,
                NodesmithProvider: $x,
                PocketProvider: Bx,
                Web3Provider: ff,
                IpcProvider: Px,
            },
            e
        )
    )
}
var Ox = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    Provider: qi,
    BaseProvider: of,
    Resolver: bd,
    UrlJsonRpcProvider: Qi,
    FallbackProvider: cf,
    AlchemyProvider: V0,
    AlchemyWebSocketProvider: kx,
    CloudflareProvider: Nx,
    EtherscanProvider: lf,
    InfuraProvider: U0,
    InfuraWebSocketProvider: Ix,
    JsonRpcProvider: li,
    JsonRpcBatchProvider: m8,
    NodesmithProvider: $x,
    PocketProvider: Bx,
    StaticJsonRpcProvider: Cx,
    Web3Provider: ff,
    WebSocketProvider: af,
    IpcProvider: Px,
    JsonRpcSigner: hl,
    getDefaultProvider: H0,
    getNetwork: F0,
    isCommunityResource: md,
    isCommunityResourcable: Ex,
    showThrottleMessage: sf,
    Formatter: _e,
})
const y8 = "solidity/5.5.0",
    _8 = new RegExp("^bytes([0-9]+)$"),
    w8 = new RegExp("^(u?int)([0-9]*)$"),
    E8 = new RegExp("^(.*)\\[([0-9]*)\\]$"),
    S8 = "0000000000000000000000000000000000000000000000000000000000000000",
    oo = new F(y8)
function Mx(t, e, r) {
    switch (t) {
        case "address":
            return r ? Ca(e, 32) : le(e)
        case "string":
            return zt(e)
        case "bytes":
            return le(e)
        case "bool":
            return (e = e ? "0x01" : "0x00"), r ? Ca(e, 32) : le(e)
    }
    let n = t.match(w8)
    if (n) {
        let i = parseInt(n[2] || "256")
        return (
            ((n[2] && String(i) !== n[2]) || i % 8 !== 0 || i === 0 || i > 256) && oo.throwArgumentError("invalid number type", "type", t),
            r && (i = 256),
            (e = ce.from(e).toTwos(i)),
            Ca(e, i / 8)
        )
    }
    if (((n = t.match(_8)), n)) {
        const i = parseInt(n[1])
        return (
            (String(i) !== n[1] || i === 0 || i > 32) && oo.throwArgumentError("invalid bytes type", "type", t),
            le(e).byteLength !== i && oo.throwArgumentError(`invalid value for ${t}`, "value", e),
            r ? le((e + S8).substring(0, 66)) : e
        )
    }
    if (((n = t.match(E8)), n && Array.isArray(e))) {
        const i = n[1]
        parseInt(n[2] || String(e.length)) != e.length && oo.throwArgumentError(`invalid array length for ${t}`, "value", e)
        const o = []
        return (
            e.forEach(function (a) {
                o.push(Mx(i, a, !0))
            }),
            ft(o)
        )
    }
    return oo.throwArgumentError("invalid type", "type", t)
}
function q0(t, e) {
    t.length != e.length && oo.throwArgumentError("wrong number of values; expected ${ types.length }", "values", e)
    const r = []
    return (
        t.forEach(function (n, i) {
            r.push(Mx(n, e[i]))
        }),
        pe(ft(r))
    )
}
function A8(t, e) {
    return st(q0(t, e))
}
function T8(t, e) {
    return ai(q0(t, e))
}
const C8 = "units/5.5.0",
    Rx = new F(C8),
    Lx = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"]
function k8(t) {
    const e = String(t).split(".")
    ;(e.length > 2 || !e[0].match(/^-?[0-9]*$/) || (e[1] && !e[1].match(/^[0-9]*$/)) || t === "." || t === "-.") &&
        Rx.throwArgumentError("invalid value", "value", t)
    let r = e[0],
        n = ""
    for (r.substring(0, 1) === "-" && ((n = "-"), (r = r.substring(1))); r.substring(0, 1) === "0"; ) r = r.substring(1)
    r === "" && (r = "0")
    let i = ""
    for (e.length === 2 && (i = "." + (e[1] || "0")); i.length > 2 && i[i.length - 1] === "0"; ) i = i.substring(0, i.length - 1)
    const s = []
    for (; r.length; )
        if (r.length <= 3) {
            s.unshift(r)
            break
        } else {
            const o = r.length - 3
            s.unshift(r.substring(o)), (r = r.substring(0, o))
        }
    return n + s.join(",") + i
}
function Dx(t, e) {
    if (typeof e == "string") {
        const r = Lx.indexOf(e)
        r !== -1 && (e = 3 * r)
    }
    return Zl(t, e != null ? e : 18)
}
function Fx(t, e) {
    if ((typeof t != "string" && Rx.throwArgumentError("value must be a string", "value", t), typeof e == "string")) {
        const r = Lx.indexOf(e)
        r !== -1 && (e = 3 * r)
    }
    return mn(t, e != null ? e : 18)
}
function N8(t) {
    return Dx(t, 18)
}
function P8(t) {
    return Fx(t, 18)
}
var Vx = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    AbiCoder: Xc,
    defaultAbiCoder: v1,
    Fragment: En,
    ConstructorFragment: rn,
    ErrorFragment: Yn,
    EventFragment: _n,
    FunctionFragment: nn,
    ParamType: Wt,
    FormatTypes: Xe,
    checkResultErrors: r1,
    Logger: F,
    RLP: e6,
    _fetchData: yx,
    fetchJson: dl,
    poll: Ts,
    checkProperties: b0,
    deepCopy: pr,
    defineReadOnly: X,
    getStatic: Yt,
    resolveProperties: Dt,
    shallowCopy: Pt,
    arrayify: le,
    concat: ft,
    stripZeros: In,
    zeroPad: Ca,
    isBytes: Ji,
    isBytesLike: ol,
    defaultPath: Io,
    HDNode: yr,
    SigningKey: Ns,
    Interface: Za,
    LogDescription: A1,
    TransactionDescription: T1,
    base58: ul,
    base64: L5,
    hexlify: pe,
    isHexString: Le,
    hexConcat: qr,
    hexStripZeros: Gb,
    hexValue: al,
    hexZeroPad: ut,
    hexDataLength: Hi,
    hexDataSlice: Er,
    nameprep: A0,
    _toEscapedUtf8String: E6,
    toUtf8Bytes: zt,
    toUtf8CodePoints: od,
    toUtf8String: Xi,
    Utf8ErrorFuncs: b1,
    formatBytes32String: S6,
    parseBytes32String: A6,
    hashMessage: T0,
    namehash: Ya,
    isValidName: H6,
    id: Bi,
    _TypedDataEncoder: tr,
    getAddress: nt,
    getIcapAddress: s6,
    getContractAddress: Jc,
    getCreate2Address: o6,
    isAddress: i6,
    formatEther: N8,
    parseEther: P8,
    formatUnits: Dx,
    parseUnits: Fx,
    commify: k8,
    computeHmac: tl,
    keccak256: st,
    ripemd160: ox,
    sha256: ai,
    sha512: i5,
    randomBytes: fo,
    shuffled: fx,
    solidityPack: q0,
    solidityKeccak256: A8,
    soliditySha256: T8,
    splitSignature: Us,
    joinSignature: nd,
    accessListify: Zi,
    parseTransaction: ex,
    serializeTransaction: dd,
    get TransactionTypes() {
        return ud
    },
    getJsonWalletAddress: y5,
    computeAddress: Di,
    recoverAddress: fl,
    computePublicKey: P0,
    recoverPublicKey: J1,
    verifyMessage: B5,
    verifyTypedData: O5,
    getAccountPath: p5,
    mnemonicToEntropy: tf,
    entropyToMnemonic: rf,
    isValidMnemonic: h5,
    mnemonicToSeed: cx,
    get SupportedAlgorithm() {
        return Po
    },
    get UnicodeNormalizationForm() {
        return Dn
    },
    get Utf8ErrorReason() {
        return _r
    },
    Indexed: wc,
})
const j0 = "ethers/5.5.4",
    Ux = new F(j0)
var Hx = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: "Module",
    Signer: di,
    Wallet: Jn,
    VoidSigner: To,
    getDefaultProvider: H0,
    providers: Ox,
    BaseContract: $0,
    Contract: el,
    ContractFactory: ix,
    BigNumber: ce,
    FixedNumber: qt,
    constants: p1,
    get errors() {
        return za
    },
    logger: Ux,
    utils: Vx,
    wordlists: Tc,
    version: j0,
    Wordlist: js,
})
try {
    const t = window
    t._ethers == null && (t._ethers = Hx)
} catch {}
var I8 = Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: "Module",
        ethers: Hx,
        Signer: di,
        Wallet: Jn,
        VoidSigner: To,
        getDefaultProvider: H0,
        providers: Ox,
        BaseContract: $0,
        Contract: el,
        ContractFactory: ix,
        BigNumber: ce,
        FixedNumber: qt,
        constants: p1,
        get errors() {
            return za
        },
        logger: Ux,
        utils: Vx,
        wordlists: Tc,
        version: j0,
        Wordlist: js,
    }),
    Sr = "top",
    Rr = "bottom",
    Lr = "right",
    Ar = "left",
    uf = "auto",
    Go = [Sr, Rr, Lr, Ar],
    Ls = "start",
    $o = "end",
    qx = "clippingParents",
    z0 = "viewport",
    ao = "popper",
    jx = "reference",
    vd = Go.reduce(function (t, e) {
        return t.concat([e + "-" + Ls, e + "-" + $o])
    }, []),
    K0 = [].concat(Go, [uf]).reduce(function (t, e) {
        return t.concat([e, e + "-" + Ls, e + "-" + $o])
    }, []),
    zx = "beforeRead",
    Kx = "read",
    Gx = "afterRead",
    Wx = "beforeMain",
    Jx = "main",
    Xx = "afterMain",
    Yx = "beforeWrite",
    Zx = "write",
    Qx = "afterWrite",
    ev = [zx, Kx, Gx, Wx, Jx, Xx, Yx, Zx, Qx]
function Hn(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}
function ln(t) {
    if (t == null) return window
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument
        return (e && e.defaultView) || window
    }
    return t
}
function rl(t) {
    var e = ln(t).Element
    return t instanceof e || t instanceof Element
}
function zr(t) {
    var e = ln(t).HTMLElement
    return t instanceof e || t instanceof HTMLElement
}
function tv(t) {
    if (typeof ShadowRoot == "undefined") return !1
    var e = ln(t).ShadowRoot
    return t instanceof e || t instanceof ShadowRoot
}
function $8(t) {
    var e = t.state
    Object.keys(e.elements).forEach(function (r) {
        var n = e.styles[r] || {},
            i = e.attributes[r] || {},
            s = e.elements[r]
        !zr(s) ||
            !Hn(s) ||
            (Object.assign(s.style, n),
            Object.keys(i).forEach(function (o) {
                var a = i[o]
                a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a)
            }))
    })
}
function B8(t) {
    var e = t.state,
        r = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }
    return (
        Object.assign(e.elements.popper.style, r.popper),
        (e.styles = r),
        e.elements.arrow && Object.assign(e.elements.arrow.style, r.arrow),
        function () {
            Object.keys(e.elements).forEach(function (n) {
                var i = e.elements[n],
                    s = e.attributes[n] || {},
                    o = Object.keys(e.styles.hasOwnProperty(n) ? e.styles[n] : r[n]),
                    a = o.reduce(function (l, c) {
                        return (l[c] = ""), l
                    }, {})
                !zr(i) ||
                    !Hn(i) ||
                    (Object.assign(i.style, a),
                    Object.keys(s).forEach(function (l) {
                        i.removeAttribute(l)
                    }))
            })
        }
    )
}
var G0 = { name: "applyStyles", enabled: !0, phase: "write", fn: $8, effect: B8, requires: ["computeStyles"] }
function Mn(t) {
    return t.split("-")[0]
}
function Bo(t, e) {
    var r = t.getBoundingClientRect(),
        n = 1,
        i = 1
    return {
        width: r.width / n,
        height: r.height / i,
        top: r.top / i,
        right: r.right / n,
        bottom: r.bottom / i,
        left: r.left / n,
        x: r.left / n,
        y: r.top / i,
    }
}
function W0(t) {
    var e = Bo(t),
        r = t.offsetWidth,
        n = t.offsetHeight
    return (
        Math.abs(e.width - r) <= 1 && (r = e.width),
        Math.abs(e.height - n) <= 1 && (n = e.height),
        { x: t.offsetLeft, y: t.offsetTop, width: r, height: n }
    )
}
function rv(t, e) {
    var r = e.getRootNode && e.getRootNode()
    if (t.contains(e)) return !0
    if (r && tv(r)) {
        var n = e
        do {
            if (n && t.isSameNode(n)) return !0
            n = n.parentNode || n.host
        } while (n)
    }
    return !1
}
function ci(t) {
    return ln(t).getComputedStyle(t)
}
function O8(t) {
    return ["table", "td", "th"].indexOf(Hn(t)) >= 0
}
function es(t) {
    return ((rl(t) ? t.ownerDocument : t.document) || window.document).documentElement
}
function df(t) {
    return Hn(t) === "html" ? t : t.assignedSlot || t.parentNode || (tv(t) ? t.host : null) || es(t)
}
function dg(t) {
    return !zr(t) || ci(t).position === "fixed" ? null : t.offsetParent
}
function M8(t) {
    var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1,
        r = navigator.userAgent.indexOf("Trident") !== -1
    if (r && zr(t)) {
        var n = ci(t)
        if (n.position === "fixed") return null
    }
    for (var i = df(t); zr(i) && ["html", "body"].indexOf(Hn(i)) < 0; ) {
        var s = ci(i)
        if (
            s.transform !== "none" ||
            s.perspective !== "none" ||
            s.contain === "paint" ||
            ["transform", "perspective"].indexOf(s.willChange) !== -1 ||
            (e && s.willChange === "filter") ||
            (e && s.filter && s.filter !== "none")
        )
            return i
        i = i.parentNode
    }
    return null
}
function pl(t) {
    for (var e = ln(t), r = dg(t); r && O8(r) && ci(r).position === "static"; ) r = dg(r)
    return r && (Hn(r) === "html" || (Hn(r) === "body" && ci(r).position === "static")) ? e : r || M8(t) || e
}
function J0(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}
var Fi = Math.max,
    nl = Math.min,
    Vl = Math.round
function sc(t, e, r) {
    return Fi(t, nl(e, r))
}
function nv() {
    return { top: 0, right: 0, bottom: 0, left: 0 }
}
function iv(t) {
    return Object.assign({}, nv(), t)
}
function sv(t, e) {
    return e.reduce(function (r, n) {
        return (r[n] = t), r
    }, {})
}
var R8 = function (e, r) {
    return (e = typeof e == "function" ? e(Object.assign({}, r.rects, { placement: r.placement })) : e), iv(typeof e != "number" ? e : sv(e, Go))
}
function L8(t) {
    var e,
        r = t.state,
        n = t.name,
        i = t.options,
        s = r.elements.arrow,
        o = r.modifiersData.popperOffsets,
        a = Mn(r.placement),
        l = J0(a),
        c = [Ar, Lr].indexOf(a) >= 0,
        f = c ? "height" : "width"
    if (!(!s || !o)) {
        var u = R8(i.padding, r),
            p = W0(s),
            m = l === "y" ? Sr : Ar,
            y = l === "y" ? Rr : Lr,
            v = r.rects.reference[f] + r.rects.reference[l] - o[l] - r.rects.popper[f],
            _ = o[l] - r.rects.reference[l],
            C = pl(s),
            B = C ? (l === "y" ? C.clientHeight || 0 : C.clientWidth || 0) : 0,
            R = v / 2 - _ / 2,
            U = u[m],
            D = B - p[f] - u[y],
            Y = B / 2 - p[f] / 2 + R,
            J = sc(U, Y, D),
            te = l
        r.modifiersData[n] = ((e = {}), (e[te] = J), (e.centerOffset = J - Y), e)
    }
}
function D8(t) {
    var e = t.state,
        r = t.options,
        n = r.element,
        i = n === void 0 ? "[data-popper-arrow]" : n
    i != null &&
        ((typeof i == "string" && ((i = e.elements.popper.querySelector(i)), !i)) || !rv(e.elements.popper, i) || (e.elements.arrow = i))
}
var ov = { name: "arrow", enabled: !0, phase: "main", fn: L8, effect: D8, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }
function Oo(t) {
    return t.split("-")[1]
}
var F8 = { top: "auto", right: "auto", bottom: "auto", left: "auto" }
function V8(t) {
    var e = t.x,
        r = t.y,
        n = window,
        i = n.devicePixelRatio || 1
    return { x: Vl(Vl(e * i) / i) || 0, y: Vl(Vl(r * i) / i) || 0 }
}
function hg(t) {
    var e,
        r = t.popper,
        n = t.popperRect,
        i = t.placement,
        s = t.variation,
        o = t.offsets,
        a = t.position,
        l = t.gpuAcceleration,
        c = t.adaptive,
        f = t.roundOffsets,
        u = f === !0 ? V8(o) : typeof f == "function" ? f(o) : o,
        p = u.x,
        m = p === void 0 ? 0 : p,
        y = u.y,
        v = y === void 0 ? 0 : y,
        _ = o.hasOwnProperty("x"),
        C = o.hasOwnProperty("y"),
        B = Ar,
        R = Sr,
        U = window
    if (c) {
        var D = pl(r),
            Y = "clientHeight",
            J = "clientWidth"
        D === ln(r) && ((D = es(r)), ci(D).position !== "static" && a === "absolute" && ((Y = "scrollHeight"), (J = "scrollWidth"))),
            (D = D),
            (i === Sr || ((i === Ar || i === Lr) && s === $o)) && ((R = Rr), (v -= D[Y] - n.height), (v *= l ? 1 : -1)),
            (i === Ar || ((i === Sr || i === Rr) && s === $o)) && ((B = Lr), (m -= D[J] - n.width), (m *= l ? 1 : -1))
    }
    var te = Object.assign({ position: a }, c && F8)
    if (l) {
        var G
        return Object.assign(
            {},
            te,
            ((G = {}),
            (G[R] = C ? "0" : ""),
            (G[B] = _ ? "0" : ""),
            (G.transform = (U.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + v + "px)" : "translate3d(" + m + "px, " + v + "px, 0)"),
            G)
        )
    }
    return Object.assign({}, te, ((e = {}), (e[R] = C ? v + "px" : ""), (e[B] = _ ? m + "px" : ""), (e.transform = ""), e))
}
function U8(t) {
    var e = t.state,
        r = t.options,
        n = r.gpuAcceleration,
        i = n === void 0 ? !0 : n,
        s = r.adaptive,
        o = s === void 0 ? !0 : s,
        a = r.roundOffsets,
        l = a === void 0 ? !0 : a,
        c = { placement: Mn(e.placement), variation: Oo(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i }
    e.modifiersData.popperOffsets != null &&
        (e.styles.popper = Object.assign(
            {},
            e.styles.popper,
            hg(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: o, roundOffsets: l }))
        )),
        e.modifiersData.arrow != null &&
            (e.styles.arrow = Object.assign(
                {},
                e.styles.arrow,
                hg(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l }))
            )),
        (e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }))
}
var X0 = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: U8, data: {} },
    Ul = { passive: !0 }
function H8(t) {
    var e = t.state,
        r = t.instance,
        n = t.options,
        i = n.scroll,
        s = i === void 0 ? !0 : i,
        o = n.resize,
        a = o === void 0 ? !0 : o,
        l = ln(e.elements.popper),
        c = [].concat(e.scrollParents.reference, e.scrollParents.popper)
    return (
        s &&
            c.forEach(function (f) {
                f.addEventListener("scroll", r.update, Ul)
            }),
        a && l.addEventListener("resize", r.update, Ul),
        function () {
            s &&
                c.forEach(function (f) {
                    f.removeEventListener("scroll", r.update, Ul)
                }),
                a && l.removeEventListener("resize", r.update, Ul)
        }
    )
}
var Y0 = { name: "eventListeners", enabled: !0, phase: "write", fn: function () {}, effect: H8, data: {} },
    q8 = { left: "right", right: "left", bottom: "top", top: "bottom" }
function oc(t) {
    return t.replace(/left|right|bottom|top/g, function (e) {
        return q8[e]
    })
}
var j8 = { start: "end", end: "start" }
function pg(t) {
    return t.replace(/start|end/g, function (e) {
        return j8[e]
    })
}
function Z0(t) {
    var e = ln(t),
        r = e.pageXOffset,
        n = e.pageYOffset
    return { scrollLeft: r, scrollTop: n }
}
function Q0(t) {
    return Bo(es(t)).left + Z0(t).scrollLeft
}
function z8(t) {
    var e = ln(t),
        r = es(t),
        n = e.visualViewport,
        i = r.clientWidth,
        s = r.clientHeight,
        o = 0,
        a = 0
    return (
        n &&
            ((i = n.width),
            (s = n.height),
            /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || ((o = n.offsetLeft), (a = n.offsetTop))),
        { width: i, height: s, x: o + Q0(t), y: a }
    )
}
function K8(t) {
    var e,
        r = es(t),
        n = Z0(t),
        i = (e = t.ownerDocument) == null ? void 0 : e.body,
        s = Fi(r.scrollWidth, r.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
        o = Fi(r.scrollHeight, r.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
        a = -n.scrollLeft + Q0(t),
        l = -n.scrollTop
    return ci(i || r).direction === "rtl" && (a += Fi(r.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: o, x: a, y: l }
}
function eh(t) {
    var e = ci(t),
        r = e.overflow,
        n = e.overflowX,
        i = e.overflowY
    return /auto|scroll|overlay|hidden/.test(r + i + n)
}
function av(t) {
    return ["html", "body", "#document"].indexOf(Hn(t)) >= 0 ? t.ownerDocument.body : zr(t) && eh(t) ? t : av(df(t))
}
function Ba(t, e) {
    var r
    e === void 0 && (e = [])
    var n = av(t),
        i = n === ((r = t.ownerDocument) == null ? void 0 : r.body),
        s = ln(n),
        o = i ? [s].concat(s.visualViewport || [], eh(n) ? n : []) : n,
        a = e.concat(o)
    return i ? a : a.concat(Ba(df(o)))
}
function yd(t) {
    return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height })
}
function G8(t) {
    var e = Bo(t)
    return (
        (e.top = e.top + t.clientTop),
        (e.left = e.left + t.clientLeft),
        (e.bottom = e.top + t.clientHeight),
        (e.right = e.left + t.clientWidth),
        (e.width = t.clientWidth),
        (e.height = t.clientHeight),
        (e.x = e.left),
        (e.y = e.top),
        e
    )
}
function gg(t, e) {
    return e === z0 ? yd(z8(t)) : zr(e) ? G8(e) : yd(K8(es(t)))
}
function W8(t) {
    var e = Ba(df(t)),
        r = ["absolute", "fixed"].indexOf(ci(t).position) >= 0,
        n = r && zr(t) ? pl(t) : t
    return rl(n)
        ? e.filter(function (i) {
              return rl(i) && rv(i, n) && Hn(i) !== "body"
          })
        : []
}
function J8(t, e, r) {
    var n = e === "clippingParents" ? W8(t) : [].concat(e),
        i = [].concat(n, [r]),
        s = i[0],
        o = i.reduce(function (a, l) {
            var c = gg(t, l)
            return (
                (a.top = Fi(c.top, a.top)),
                (a.right = nl(c.right, a.right)),
                (a.bottom = nl(c.bottom, a.bottom)),
                (a.left = Fi(c.left, a.left)),
                a
            )
        }, gg(t, s))
    return (o.width = o.right - o.left), (o.height = o.bottom - o.top), (o.x = o.left), (o.y = o.top), o
}
function lv(t) {
    var e = t.reference,
        r = t.element,
        n = t.placement,
        i = n ? Mn(n) : null,
        s = n ? Oo(n) : null,
        o = e.x + e.width / 2 - r.width / 2,
        a = e.y + e.height / 2 - r.height / 2,
        l
    switch (i) {
        case Sr:
            l = { x: o, y: e.y - r.height }
            break
        case Rr:
            l = { x: o, y: e.y + e.height }
            break
        case Lr:
            l = { x: e.x + e.width, y: a }
            break
        case Ar:
            l = { x: e.x - r.width, y: a }
            break
        default:
            l = { x: e.x, y: e.y }
    }
    var c = i ? J0(i) : null
    if (c != null) {
        var f = c === "y" ? "height" : "width"
        switch (s) {
            case Ls:
                l[c] = l[c] - (e[f] / 2 - r[f] / 2)
                break
            case $o:
                l[c] = l[c] + (e[f] / 2 - r[f] / 2)
                break
        }
    }
    return l
}
function Mo(t, e) {
    e === void 0 && (e = {})
    var r = e,
        n = r.placement,
        i = n === void 0 ? t.placement : n,
        s = r.boundary,
        o = s === void 0 ? qx : s,
        a = r.rootBoundary,
        l = a === void 0 ? z0 : a,
        c = r.elementContext,
        f = c === void 0 ? ao : c,
        u = r.altBoundary,
        p = u === void 0 ? !1 : u,
        m = r.padding,
        y = m === void 0 ? 0 : m,
        v = iv(typeof y != "number" ? y : sv(y, Go)),
        _ = f === ao ? jx : ao,
        C = t.rects.popper,
        B = t.elements[p ? _ : f],
        R = J8(rl(B) ? B : B.contextElement || es(t.elements.popper), o, l),
        U = Bo(t.elements.reference),
        D = lv({ reference: U, element: C, strategy: "absolute", placement: i }),
        Y = yd(Object.assign({}, C, D)),
        J = f === ao ? Y : U,
        te = {
            top: R.top - J.top + v.top,
            bottom: J.bottom - R.bottom + v.bottom,
            left: R.left - J.left + v.left,
            right: J.right - R.right + v.right,
        },
        G = t.modifiersData.offset
    if (f === ao && G) {
        var de = G[i]
        Object.keys(te).forEach(function (k) {
            var d = [Lr, Rr].indexOf(k) >= 0 ? 1 : -1,
                b = [Sr, Rr].indexOf(k) >= 0 ? "y" : "x"
            te[k] += de[b] * d
        })
    }
    return te
}
function X8(t, e) {
    e === void 0 && (e = {})
    var r = e,
        n = r.placement,
        i = r.boundary,
        s = r.rootBoundary,
        o = r.padding,
        a = r.flipVariations,
        l = r.allowedAutoPlacements,
        c = l === void 0 ? K0 : l,
        f = Oo(n),
        u = f
            ? a
                ? vd
                : vd.filter(function (y) {
                      return Oo(y) === f
                  })
            : Go,
        p = u.filter(function (y) {
            return c.indexOf(y) >= 0
        })
    p.length === 0 && (p = u)
    var m = p.reduce(function (y, v) {
        return (y[v] = Mo(t, { placement: v, boundary: i, rootBoundary: s, padding: o })[Mn(v)]), y
    }, {})
    return Object.keys(m).sort(function (y, v) {
        return m[y] - m[v]
    })
}
function Y8(t) {
    if (Mn(t) === uf) return []
    var e = oc(t)
    return [pg(t), e, pg(e)]
}
function Z8(t) {
    var e = t.state,
        r = t.options,
        n = t.name
    if (!e.modifiersData[n]._skip) {
        for (
            var i = r.mainAxis,
                s = i === void 0 ? !0 : i,
                o = r.altAxis,
                a = o === void 0 ? !0 : o,
                l = r.fallbackPlacements,
                c = r.padding,
                f = r.boundary,
                u = r.rootBoundary,
                p = r.altBoundary,
                m = r.flipVariations,
                y = m === void 0 ? !0 : m,
                v = r.allowedAutoPlacements,
                _ = e.options.placement,
                C = Mn(_),
                B = C === _,
                R = l || (B || !y ? [oc(_)] : Y8(_)),
                U = [_].concat(R).reduce(function (L, h) {
                    return L.concat(
                        Mn(h) === uf
                            ? X8(e, { placement: h, boundary: f, rootBoundary: u, padding: c, flipVariations: y, allowedAutoPlacements: v })
                            : h
                    )
                }, []),
                D = e.rects.reference,
                Y = e.rects.popper,
                J = new Map(),
                te = !0,
                G = U[0],
                de = 0;
            de < U.length;
            de++
        ) {
            var k = U[de],
                d = Mn(k),
                b = Oo(k) === Ls,
                w = [Sr, Rr].indexOf(d) >= 0,
                E = w ? "width" : "height",
                T = Mo(e, { placement: k, boundary: f, rootBoundary: u, altBoundary: p, padding: c }),
                A = w ? (b ? Lr : Ar) : b ? Rr : Sr
            D[E] > Y[E] && (A = oc(A))
            var $ = oc(A),
                S = []
            if (
                (s && S.push(T[d] <= 0),
                a && S.push(T[A] <= 0, T[$] <= 0),
                S.every(function (L) {
                    return L
                }))
            ) {
                ;(G = k), (te = !1)
                break
            }
            J.set(k, S)
        }
        if (te)
            for (
                var g = y ? 3 : 1,
                    x = function (h) {
                        var P = U.find(function (M) {
                            var V = J.get(M)
                            if (V)
                                return V.slice(0, h).every(function (z) {
                                    return z
                                })
                        })
                        if (P) return (G = P), "break"
                    },
                    O = g;
                O > 0;
                O--
            ) {
                var j = x(O)
                if (j === "break") break
            }
        e.placement !== G && ((e.modifiersData[n]._skip = !0), (e.placement = G), (e.reset = !0))
    }
}
var cv = { name: "flip", enabled: !0, phase: "main", fn: Z8, requiresIfExists: ["offset"], data: { _skip: !1 } }
function mg(t, e, r) {
    return (
        r === void 0 && (r = { x: 0, y: 0 }),
        { top: t.top - e.height - r.y, right: t.right - e.width + r.x, bottom: t.bottom - e.height + r.y, left: t.left - e.width - r.x }
    )
}
function bg(t) {
    return [Sr, Lr, Rr, Ar].some(function (e) {
        return t[e] >= 0
    })
}
function Q8(t) {
    var e = t.state,
        r = t.name,
        n = e.rects.reference,
        i = e.rects.popper,
        s = e.modifiersData.preventOverflow,
        o = Mo(e, { elementContext: "reference" }),
        a = Mo(e, { altBoundary: !0 }),
        l = mg(o, n),
        c = mg(a, i, s),
        f = bg(l),
        u = bg(c)
    ;(e.modifiersData[r] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: f, hasPopperEscaped: u }),
        (e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": f, "data-popper-escaped": u }))
}
var fv = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: Q8 }
function e7(t, e, r) {
    var n = Mn(t),
        i = [Ar, Sr].indexOf(n) >= 0 ? -1 : 1,
        s = typeof r == "function" ? r(Object.assign({}, e, { placement: t })) : r,
        o = s[0],
        a = s[1]
    return (o = o || 0), (a = (a || 0) * i), [Ar, Lr].indexOf(n) >= 0 ? { x: a, y: o } : { x: o, y: a }
}
function t7(t) {
    var e = t.state,
        r = t.options,
        n = t.name,
        i = r.offset,
        s = i === void 0 ? [0, 0] : i,
        o = K0.reduce(function (f, u) {
            return (f[u] = e7(u, e.rects, s)), f
        }, {}),
        a = o[e.placement],
        l = a.x,
        c = a.y
    e.modifiersData.popperOffsets != null && ((e.modifiersData.popperOffsets.x += l), (e.modifiersData.popperOffsets.y += c)),
        (e.modifiersData[n] = o)
}
var uv = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: t7 }
function r7(t) {
    var e = t.state,
        r = t.name
    e.modifiersData[r] = lv({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement })
}
var th = { name: "popperOffsets", enabled: !0, phase: "read", fn: r7, data: {} }
function n7(t) {
    return t === "x" ? "y" : "x"
}
function i7(t) {
    var e = t.state,
        r = t.options,
        n = t.name,
        i = r.mainAxis,
        s = i === void 0 ? !0 : i,
        o = r.altAxis,
        a = o === void 0 ? !1 : o,
        l = r.boundary,
        c = r.rootBoundary,
        f = r.altBoundary,
        u = r.padding,
        p = r.tether,
        m = p === void 0 ? !0 : p,
        y = r.tetherOffset,
        v = y === void 0 ? 0 : y,
        _ = Mo(e, { boundary: l, rootBoundary: c, padding: u, altBoundary: f }),
        C = Mn(e.placement),
        B = Oo(e.placement),
        R = !B,
        U = J0(C),
        D = n7(U),
        Y = e.modifiersData.popperOffsets,
        J = e.rects.reference,
        te = e.rects.popper,
        G = typeof v == "function" ? v(Object.assign({}, e.rects, { placement: e.placement })) : v,
        de = { x: 0, y: 0 }
    if (!!Y) {
        if (s || a) {
            var k = U === "y" ? Sr : Ar,
                d = U === "y" ? Rr : Lr,
                b = U === "y" ? "height" : "width",
                w = Y[U],
                E = Y[U] + _[k],
                T = Y[U] - _[d],
                A = m ? -te[b] / 2 : 0,
                $ = B === Ls ? J[b] : te[b],
                S = B === Ls ? -te[b] : -J[b],
                g = e.elements.arrow,
                x = m && g ? W0(g) : { width: 0, height: 0 },
                O = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : nv(),
                j = O[k],
                L = O[d],
                h = sc(0, J[b], x[b]),
                P = R ? J[b] / 2 - A - h - j - G : $ - h - j - G,
                M = R ? -J[b] / 2 + A + h + L + G : S + h + L + G,
                V = e.elements.arrow && pl(e.elements.arrow),
                z = V ? (U === "y" ? V.clientTop || 0 : V.clientLeft || 0) : 0,
                ee = e.modifiersData.offset ? e.modifiersData.offset[e.placement][U] : 0,
                ne = Y[U] + P - ee - z,
                W = Y[U] + M - ee
            if (s) {
                var N = sc(m ? nl(E, ne) : E, w, m ? Fi(T, W) : T)
                ;(Y[U] = N), (de[U] = N - w)
            }
            if (a) {
                var I = U === "x" ? Sr : Ar,
                    q = U === "x" ? Rr : Lr,
                    Q = Y[D],
                    ie = Q + _[I],
                    Z = Q - _[q],
                    oe = sc(m ? nl(ie, ne) : ie, Q, m ? Fi(Z, W) : Z)
                ;(Y[D] = oe), (de[D] = oe - Q)
            }
        }
        e.modifiersData[n] = de
    }
}
var dv = { name: "preventOverflow", enabled: !0, phase: "main", fn: i7, requiresIfExists: ["offset"] }
function s7(t) {
    return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
}
function o7(t) {
    return t === ln(t) || !zr(t) ? Z0(t) : s7(t)
}
function a7(t) {
    var e = t.getBoundingClientRect(),
        r = e.width / t.offsetWidth || 1,
        n = e.height / t.offsetHeight || 1
    return r !== 1 || n !== 1
}
function l7(t, e, r) {
    r === void 0 && (r = !1)
    var n = zr(e)
    zr(e) && a7(e)
    var i = es(e),
        s = Bo(t),
        o = { scrollLeft: 0, scrollTop: 0 },
        a = { x: 0, y: 0 }
    return (
        (n || (!n && !r)) &&
            ((Hn(e) !== "body" || eh(i)) && (o = o7(e)),
            zr(e) ? ((a = Bo(e)), (a.x += e.clientLeft), (a.y += e.clientTop)) : i && (a.x = Q0(i))),
        { x: s.left + o.scrollLeft - a.x, y: s.top + o.scrollTop - a.y, width: s.width, height: s.height }
    )
}
function c7(t) {
    var e = new Map(),
        r = new Set(),
        n = []
    t.forEach(function (s) {
        e.set(s.name, s)
    })
    function i(s) {
        r.add(s.name)
        var o = [].concat(s.requires || [], s.requiresIfExists || [])
        o.forEach(function (a) {
            if (!r.has(a)) {
                var l = e.get(a)
                l && i(l)
            }
        }),
            n.push(s)
    }
    return (
        t.forEach(function (s) {
            r.has(s.name) || i(s)
        }),
        n
    )
}
function f7(t) {
    var e = c7(t)
    return ev.reduce(function (r, n) {
        return r.concat(
            e.filter(function (i) {
                return i.phase === n
            })
        )
    }, [])
}
function u7(t) {
    var e
    return function () {
        return (
            e ||
                (e = new Promise(function (r) {
                    Promise.resolve().then(function () {
                        ;(e = void 0), r(t())
                    })
                })),
            e
        )
    }
}
function d7(t) {
    var e = t.reduce(function (r, n) {
        var i = r[n.name]
        return (
            (r[n.name] = i
                ? Object.assign({}, i, n, { options: Object.assign({}, i.options, n.options), data: Object.assign({}, i.data, n.data) })
                : n),
            r
        )
    }, {})
    return Object.keys(e).map(function (r) {
        return e[r]
    })
}
var xg = { placement: "bottom", modifiers: [], strategy: "absolute" }
function vg() {
    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r]
    return !e.some(function (n) {
        return !(n && typeof n.getBoundingClientRect == "function")
    })
}
function hf(t) {
    t === void 0 && (t = {})
    var e = t,
        r = e.defaultModifiers,
        n = r === void 0 ? [] : r,
        i = e.defaultOptions,
        s = i === void 0 ? xg : i
    return function (a, l, c) {
        c === void 0 && (c = s)
        var f = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, xg, s),
                modifiersData: {},
                elements: { reference: a, popper: l },
                attributes: {},
                styles: {},
            },
            u = [],
            p = !1,
            m = {
                state: f,
                setOptions: function (C) {
                    var B = typeof C == "function" ? C(f.options) : C
                    v(),
                        (f.options = Object.assign({}, s, f.options, B)),
                        (f.scrollParents = { reference: rl(a) ? Ba(a) : a.contextElement ? Ba(a.contextElement) : [], popper: Ba(l) })
                    var R = f7(d7([].concat(n, f.options.modifiers)))
                    return (
                        (f.orderedModifiers = R.filter(function (U) {
                            return U.enabled
                        })),
                        y(),
                        m.update()
                    )
                },
                forceUpdate: function () {
                    if (!p) {
                        var C = f.elements,
                            B = C.reference,
                            R = C.popper
                        if (!!vg(B, R)) {
                            ;(f.rects = { reference: l7(B, pl(R), f.options.strategy === "fixed"), popper: W0(R) }),
                                (f.reset = !1),
                                (f.placement = f.options.placement),
                                f.orderedModifiers.forEach(function (de) {
                                    return (f.modifiersData[de.name] = Object.assign({}, de.data))
                                })
                            for (var U = 0; U < f.orderedModifiers.length; U++) {
                                if (f.reset === !0) {
                                    ;(f.reset = !1), (U = -1)
                                    continue
                                }
                                var D = f.orderedModifiers[U],
                                    Y = D.fn,
                                    J = D.options,
                                    te = J === void 0 ? {} : J,
                                    G = D.name
                                typeof Y == "function" && (f = Y({ state: f, options: te, name: G, instance: m }) || f)
                            }
                        }
                    }
                },
                update: u7(function () {
                    return new Promise(function (_) {
                        m.forceUpdate(), _(f)
                    })
                }),
                destroy: function () {
                    v(), (p = !0)
                },
            }
        if (!vg(a, l)) return m
        m.setOptions(c).then(function (_) {
            !p && c.onFirstUpdate && c.onFirstUpdate(_)
        })
        function y() {
            f.orderedModifiers.forEach(function (_) {
                var C = _.name,
                    B = _.options,
                    R = B === void 0 ? {} : B,
                    U = _.effect
                if (typeof U == "function") {
                    var D = U({ state: f, name: C, instance: m, options: R }),
                        Y = function () {}
                    u.push(D || Y)
                }
            })
        }
        function v() {
            u.forEach(function (_) {
                return _()
            }),
                (u = [])
        }
        return m
    }
}
var h7 = hf(),
    p7 = [Y0, th, X0, G0],
    g7 = hf({ defaultModifiers: p7 }),
    m7 = [Y0, th, X0, G0, uv, cv, dv, ov, fv],
    rh = hf({ defaultModifiers: m7 }),
    hv = Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: "Module",
        popperGenerator: hf,
        detectOverflow: Mo,
        createPopperBase: h7,
        createPopper: rh,
        createPopperLite: g7,
        top: Sr,
        bottom: Rr,
        right: Lr,
        left: Ar,
        auto: uf,
        basePlacements: Go,
        start: Ls,
        end: $o,
        clippingParents: qx,
        viewport: z0,
        popper: ao,
        reference: jx,
        variationPlacements: vd,
        placements: K0,
        beforeRead: zx,
        read: Kx,
        afterRead: Gx,
        beforeMain: Wx,
        main: Jx,
        afterMain: Xx,
        beforeWrite: Yx,
        write: Zx,
        afterWrite: Qx,
        modifierPhases: ev,
        applyStyles: G0,
        arrow: ov,
        computeStyles: X0,
        eventListeners: Y0,
        flip: cv,
        hide: fv,
        offset: uv,
        popperOffsets: th,
        preventOverflow: dv,
    })
/*!
 * Bootstrap v5.1.3 (https://getbootstrap.com/)
 * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */ const b7 = 1e6,
    x7 = 1e3,
    _d = "transitionend",
    v7 = (t) =>
        t == null
            ? `${t}`
            : {}.toString
                  .call(t)
                  .match(/\s([a-z]+)/i)[1]
                  .toLowerCase(),
    y7 = (t) => {
        do t += Math.floor(Math.random() * b7)
        while (document.getElementById(t))
        return t
    },
    pv = (t) => {
        let e = t.getAttribute("data-bs-target")
        if (!e || e === "#") {
            let r = t.getAttribute("href")
            if (!r || (!r.includes("#") && !r.startsWith("."))) return null
            r.includes("#") && !r.startsWith("#") && (r = `#${r.split("#")[1]}`), (e = r && r !== "#" ? r.trim() : null)
        }
        return e
    },
    nh = (t) => {
        const e = pv(t)
        return e && document.querySelector(e) ? e : null
    },
    Ki = (t) => {
        const e = pv(t)
        return e ? document.querySelector(e) : null
    },
    _7 = (t) => {
        if (!t) return 0
        let { transitionDuration: e, transitionDelay: r } = window.getComputedStyle(t)
        const n = Number.parseFloat(e),
            i = Number.parseFloat(r)
        return !n && !i ? 0 : ((e = e.split(",")[0]), (r = r.split(",")[0]), (Number.parseFloat(e) + Number.parseFloat(r)) * x7)
    },
    gv = (t) => {
        t.dispatchEvent(new Event(_d))
    },
    Ds = (t) => (!t || typeof t != "object" ? !1 : (typeof t.jquery != "undefined" && (t = t[0]), typeof t.nodeType != "undefined")),
    Gi = (t) => (Ds(t) ? (t.jquery ? t[0] : t) : typeof t == "string" && t.length > 0 ? document.querySelector(t) : null),
    zn = (t, e, r) => {
        Object.keys(r).forEach((n) => {
            const i = r[n],
                s = e[n],
                o = s && Ds(s) ? "element" : v7(s)
            if (!new RegExp(i).test(o)) throw new TypeError(`${t.toUpperCase()}: Option "${n}" provided type "${o}" but expected type "${i}".`)
        })
    },
    gl = (t) => (!Ds(t) || t.getClientRects().length === 0 ? !1 : getComputedStyle(t).getPropertyValue("visibility") === "visible"),
    Is = (t) =>
        !t || t.nodeType !== Node.ELEMENT_NODE || t.classList.contains("disabled")
            ? !0
            : typeof t.disabled != "undefined"
            ? t.disabled
            : t.hasAttribute("disabled") && t.getAttribute("disabled") !== "false",
    mv = (t) => {
        if (!document.documentElement.attachShadow) return null
        if (typeof t.getRootNode == "function") {
            const e = t.getRootNode()
            return e instanceof ShadowRoot ? e : null
        }
        return t instanceof ShadowRoot ? t : t.parentNode ? mv(t.parentNode) : null
    },
    Pc = () => {},
    Wo = (t) => {
        t.offsetHeight
    },
    bv = () => {
        const { jQuery: t } = window
        return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null
    },
    vu = [],
    w7 = (t) => {
        document.readyState === "loading"
            ? (vu.length ||
                  document.addEventListener("DOMContentLoaded", () => {
                      vu.forEach((e) => e())
                  }),
              vu.push(t))
            : t()
    },
    wr = () => document.documentElement.dir === "rtl",
    Xr = (t) => {
        w7(() => {
            const e = bv()
            if (e) {
                const r = t.NAME,
                    n = e.fn[r]
                ;(e.fn[r] = t.jQueryInterface), (e.fn[r].Constructor = t), (e.fn[r].noConflict = () => ((e.fn[r] = n), t.jQueryInterface))
            }
        })
    },
    Ss = (t) => {
        typeof t == "function" && t()
    },
    xv = (t, e, r = !0) => {
        if (!r) {
            Ss(t)
            return
        }
        const n = 5,
            i = _7(e) + n
        let s = !1
        const o = ({ target: a }) => {
            a === e && ((s = !0), e.removeEventListener(_d, o), Ss(t))
        }
        e.addEventListener(_d, o),
            setTimeout(() => {
                s || gv(e)
            }, i)
    },
    vv = (t, e, r, n) => {
        let i = t.indexOf(e)
        if (i === -1) return t[!r && n ? t.length - 1 : 0]
        const s = t.length
        return (i += r ? 1 : -1), n && (i = (i + s) % s), t[Math.max(0, Math.min(i, s - 1))]
    },
    E7 = /[^.]*(?=\..*)\.|.*/,
    S7 = /\..*/,
    A7 = /::\d+$/,
    yu = {}
let yg = 1
const T7 = { mouseenter: "mouseover", mouseleave: "mouseout" },
    C7 = /^(mouseenter|mouseleave)/i,
    yv = new Set([
        "click",
        "dblclick",
        "mouseup",
        "mousedown",
        "contextmenu",
        "mousewheel",
        "DOMMouseScroll",
        "mouseover",
        "mouseout",
        "mousemove",
        "selectstart",
        "selectend",
        "keydown",
        "keypress",
        "keyup",
        "orientationchange",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "pointerdown",
        "pointermove",
        "pointerup",
        "pointerleave",
        "pointercancel",
        "gesturestart",
        "gesturechange",
        "gestureend",
        "focus",
        "blur",
        "change",
        "reset",
        "select",
        "submit",
        "focusin",
        "focusout",
        "load",
        "unload",
        "beforeunload",
        "resize",
        "move",
        "DOMContentLoaded",
        "readystatechange",
        "error",
        "abort",
        "scroll",
    ])
function _v(t, e) {
    return (e && `${e}::${yg++}`) || t.uidEvent || yg++
}
function wv(t) {
    const e = _v(t)
    return (t.uidEvent = e), (yu[e] = yu[e] || {}), yu[e]
}
function k7(t, e) {
    return function r(n) {
        return (n.delegateTarget = t), r.oneOff && ae.off(t, n.type, e), e.apply(t, [n])
    }
}
function N7(t, e, r) {
    return function n(i) {
        const s = t.querySelectorAll(e)
        for (let { target: o } = i; o && o !== this; o = o.parentNode)
            for (let a = s.length; a--; ) if (s[a] === o) return (i.delegateTarget = o), n.oneOff && ae.off(t, i.type, e, r), r.apply(o, [i])
        return null
    }
}
function Ev(t, e, r = null) {
    const n = Object.keys(t)
    for (let i = 0, s = n.length; i < s; i++) {
        const o = t[n[i]]
        if (o.originalHandler === e && o.delegationSelector === r) return o
    }
    return null
}
function Sv(t, e, r) {
    const n = typeof e == "string",
        i = n ? r : e
    let s = Av(t)
    return yv.has(s) || (s = t), [n, i, s]
}
function _g(t, e, r, n, i) {
    if (typeof e != "string" || !t) return
    if ((r || ((r = n), (n = null)), C7.test(e))) {
        const m = (y) =>
            function (v) {
                if (!v.relatedTarget || (v.relatedTarget !== v.delegateTarget && !v.delegateTarget.contains(v.relatedTarget)))
                    return y.call(this, v)
            }
        n ? (n = m(n)) : (r = m(r))
    }
    const [s, o, a] = Sv(e, r, n),
        l = wv(t),
        c = l[a] || (l[a] = {}),
        f = Ev(c, o, s ? r : null)
    if (f) {
        f.oneOff = f.oneOff && i
        return
    }
    const u = _v(o, e.replace(E7, "")),
        p = s ? N7(t, r, n) : k7(t, r)
    ;(p.delegationSelector = s ? r : null), (p.originalHandler = o), (p.oneOff = i), (p.uidEvent = u), (c[u] = p), t.addEventListener(a, p, s)
}
function wd(t, e, r, n, i) {
    const s = Ev(e[r], n, i)
    !s || (t.removeEventListener(r, s, Boolean(i)), delete e[r][s.uidEvent])
}
function P7(t, e, r, n) {
    const i = e[r] || {}
    Object.keys(i).forEach((s) => {
        if (s.includes(n)) {
            const o = i[s]
            wd(t, e, r, o.originalHandler, o.delegationSelector)
        }
    })
}
function Av(t) {
    return (t = t.replace(S7, "")), T7[t] || t
}
const ae = {
        on(t, e, r, n) {
            _g(t, e, r, n, !1)
        },
        one(t, e, r, n) {
            _g(t, e, r, n, !0)
        },
        off(t, e, r, n) {
            if (typeof e != "string" || !t) return
            const [i, s, o] = Sv(e, r, n),
                a = o !== e,
                l = wv(t),
                c = e.startsWith(".")
            if (typeof s != "undefined") {
                if (!l || !l[o]) return
                wd(t, l, o, s, i ? r : null)
                return
            }
            c &&
                Object.keys(l).forEach((u) => {
                    P7(t, l, u, e.slice(1))
                })
            const f = l[o] || {}
            Object.keys(f).forEach((u) => {
                const p = u.replace(A7, "")
                if (!a || e.includes(p)) {
                    const m = f[u]
                    wd(t, l, o, m.originalHandler, m.delegationSelector)
                }
            })
        },
        trigger(t, e, r) {
            if (typeof e != "string" || !t) return null
            const n = bv(),
                i = Av(e),
                s = e !== i,
                o = yv.has(i)
            let a,
                l = !0,
                c = !0,
                f = !1,
                u = null
            return (
                s &&
                    n &&
                    ((a = n.Event(e, r)),
                    n(t).trigger(a),
                    (l = !a.isPropagationStopped()),
                    (c = !a.isImmediatePropagationStopped()),
                    (f = a.isDefaultPrevented())),
                o ? ((u = document.createEvent("HTMLEvents")), u.initEvent(i, l, !0)) : (u = new CustomEvent(e, { bubbles: l, cancelable: !0 })),
                typeof r != "undefined" &&
                    Object.keys(r).forEach((p) => {
                        Object.defineProperty(u, p, {
                            get() {
                                return r[p]
                            },
                        })
                    }),
                f && u.preventDefault(),
                c && t.dispatchEvent(u),
                u.defaultPrevented && typeof a != "undefined" && a.preventDefault(),
                u
            )
        },
    },
    Ti = new Map(),
    Oa = {
        set(t, e, r) {
            Ti.has(t) || Ti.set(t, new Map())
            const n = Ti.get(t)
            if (!n.has(e) && n.size !== 0) {
                console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`)
                return
            }
            n.set(e, r)
        },
        get(t, e) {
            return (Ti.has(t) && Ti.get(t).get(e)) || null
        },
        remove(t, e) {
            if (!Ti.has(t)) return
            const r = Ti.get(t)
            r.delete(e), r.size === 0 && Ti.delete(t)
        },
    },
    I7 = "5.1.3"
class cn {
    constructor(e) {
        ;(e = Gi(e)), !!e && ((this._element = e), Oa.set(this._element, this.constructor.DATA_KEY, this))
    }
    dispose() {
        Oa.remove(this._element, this.constructor.DATA_KEY),
            ae.off(this._element, this.constructor.EVENT_KEY),
            Object.getOwnPropertyNames(this).forEach((e) => {
                this[e] = null
            })
    }
    _queueCallback(e, r, n = !0) {
        xv(e, r, n)
    }
    static getInstance(e) {
        return Oa.get(Gi(e), this.DATA_KEY)
    }
    static getOrCreateInstance(e, r = {}) {
        return this.getInstance(e) || new this(e, typeof r == "object" ? r : null)
    }
    static get VERSION() {
        return I7
    }
    static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!')
    }
    static get DATA_KEY() {
        return `bs.${this.NAME}`
    }
    static get EVENT_KEY() {
        return `.${this.DATA_KEY}`
    }
}
const pf = (t, e = "hide") => {
        const r = `click.dismiss${t.EVENT_KEY}`,
            n = t.NAME
        ae.on(document, r, `[data-bs-dismiss="${n}"]`, function (i) {
            if ((["A", "AREA"].includes(this.tagName) && i.preventDefault(), Is(this))) return
            const s = Ki(this) || this.closest(`.${n}`)
            t.getOrCreateInstance(s)[e]()
        })
    },
    $7 = "alert",
    B7 = "bs.alert",
    Tv = `.${B7}`,
    O7 = `close${Tv}`,
    M7 = `closed${Tv}`,
    R7 = "fade",
    L7 = "show"
class ml extends cn {
    static get NAME() {
        return $7
    }
    close() {
        if (ae.trigger(this._element, O7).defaultPrevented) return
        this._element.classList.remove(L7)
        const r = this._element.classList.contains(R7)
        this._queueCallback(() => this._destroyElement(), this._element, r)
    }
    _destroyElement() {
        this._element.remove(), ae.trigger(this._element, M7), this.dispose()
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = ml.getOrCreateInstance(this)
            if (typeof e == "string") {
                if (r[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`)
                r[e](this)
            }
        })
    }
}
pf(ml, "close")
Xr(ml)
const D7 = "button",
    F7 = "bs.button",
    V7 = `.${F7}`,
    U7 = ".data-api",
    H7 = "active",
    wg = '[data-bs-toggle="button"]',
    q7 = `click${V7}${U7}`
class gf extends cn {
    static get NAME() {
        return D7
    }
    toggle() {
        this._element.setAttribute("aria-pressed", this._element.classList.toggle(H7))
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = gf.getOrCreateInstance(this)
            e === "toggle" && r[e]()
        })
    }
}
ae.on(document, q7, wg, (t) => {
    t.preventDefault()
    const e = t.target.closest(wg)
    gf.getOrCreateInstance(e).toggle()
})
Xr(gf)
function Eg(t) {
    return t === "true" ? !0 : t === "false" ? !1 : t === Number(t).toString() ? Number(t) : t === "" || t === "null" ? null : t
}
function _u(t) {
    return t.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`)
}
const ir = {
        setDataAttribute(t, e, r) {
            t.setAttribute(`data-bs-${_u(e)}`, r)
        },
        removeDataAttribute(t, e) {
            t.removeAttribute(`data-bs-${_u(e)}`)
        },
        getDataAttributes(t) {
            if (!t) return {}
            const e = {}
            return (
                Object.keys(t.dataset)
                    .filter((r) => r.startsWith("bs"))
                    .forEach((r) => {
                        let n = r.replace(/^bs/, "")
                        ;(n = n.charAt(0).toLowerCase() + n.slice(1, n.length)), (e[n] = Eg(t.dataset[r]))
                    }),
                e
            )
        },
        getDataAttribute(t, e) {
            return Eg(t.getAttribute(`data-bs-${_u(e)}`))
        },
        offset(t) {
            const e = t.getBoundingClientRect()
            return { top: e.top + window.pageYOffset, left: e.left + window.pageXOffset }
        },
        position(t) {
            return { top: t.offsetTop, left: t.offsetLeft }
        },
    },
    j7 = 3,
    Pe = {
        find(t, e = document.documentElement) {
            return [].concat(...Element.prototype.querySelectorAll.call(e, t))
        },
        findOne(t, e = document.documentElement) {
            return Element.prototype.querySelector.call(e, t)
        },
        children(t, e) {
            return [].concat(...t.children).filter((r) => r.matches(e))
        },
        parents(t, e) {
            const r = []
            let n = t.parentNode
            for (; n && n.nodeType === Node.ELEMENT_NODE && n.nodeType !== j7; ) n.matches(e) && r.push(n), (n = n.parentNode)
            return r
        },
        prev(t, e) {
            let r = t.previousElementSibling
            for (; r; ) {
                if (r.matches(e)) return [r]
                r = r.previousElementSibling
            }
            return []
        },
        next(t, e) {
            let r = t.nextElementSibling
            for (; r; ) {
                if (r.matches(e)) return [r]
                r = r.nextElementSibling
            }
            return []
        },
        focusableChildren(t) {
            const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]']
                .map((r) => `${r}:not([tabindex^="-"])`)
                .join(", ")
            return this.find(e, t).filter((r) => !Is(r) && gl(r))
        },
    },
    Sg = "carousel",
    z7 = "bs.carousel",
    Fr = `.${z7}`,
    Cv = ".data-api",
    K7 = "ArrowLeft",
    G7 = "ArrowRight",
    W7 = 500,
    J7 = 40,
    Ag = { interval: 5e3, keyboard: !0, slide: !1, pause: "hover", wrap: !0, touch: !0 },
    X7 = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        slide: "(boolean|string)",
        pause: "(string|boolean)",
        wrap: "boolean",
        touch: "boolean",
    },
    ms = "next",
    bs = "prev",
    _s = "left",
    xa = "right",
    Y7 = { [K7]: xa, [G7]: _s },
    Z7 = `slide${Fr}`,
    Tg = `slid${Fr}`,
    Q7 = `keydown${Fr}`,
    eS = `mouseenter${Fr}`,
    tS = `mouseleave${Fr}`,
    rS = `touchstart${Fr}`,
    nS = `touchmove${Fr}`,
    iS = `touchend${Fr}`,
    sS = `pointerdown${Fr}`,
    oS = `pointerup${Fr}`,
    aS = `dragstart${Fr}`,
    lS = `load${Fr}${Cv}`,
    cS = `click${Fr}${Cv}`,
    fS = "carousel",
    xs = "active",
    uS = "slide",
    dS = "carousel-item-end",
    hS = "carousel-item-start",
    pS = "carousel-item-next",
    gS = "carousel-item-prev",
    mS = "pointer-event",
    bS = ".active",
    Hl = ".active.carousel-item",
    xS = ".carousel-item",
    vS = ".carousel-item img",
    yS = ".carousel-item-next, .carousel-item-prev",
    _S = ".carousel-indicators",
    wS = "[data-bs-target]",
    ES = "[data-bs-slide], [data-bs-slide-to]",
    SS = '[data-bs-ride="carousel"]',
    AS = "touch",
    TS = "pen"
class An extends cn {
    constructor(e, r) {
        super(e)
        ;(this._items = null),
            (this._interval = null),
            (this._activeElement = null),
            (this._isPaused = !1),
            (this._isSliding = !1),
            (this.touchTimeout = null),
            (this.touchStartX = 0),
            (this.touchDeltaX = 0),
            (this._config = this._getConfig(r)),
            (this._indicatorsElement = Pe.findOne(_S, this._element)),
            (this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0),
            (this._pointerEvent = Boolean(window.PointerEvent)),
            this._addEventListeners()
    }
    static get Default() {
        return Ag
    }
    static get NAME() {
        return Sg
    }
    next() {
        this._slide(ms)
    }
    nextWhenVisible() {
        !document.hidden && gl(this._element) && this.next()
    }
    prev() {
        this._slide(bs)
    }
    pause(e) {
        e || (this._isPaused = !0),
            Pe.findOne(yS, this._element) && (gv(this._element), this.cycle(!0)),
            clearInterval(this._interval),
            (this._interval = null)
    }
    cycle(e) {
        e || (this._isPaused = !1),
            this._interval && (clearInterval(this._interval), (this._interval = null)),
            this._config &&
                this._config.interval &&
                !this._isPaused &&
                (this._updateInterval(),
                (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)))
    }
    to(e) {
        this._activeElement = Pe.findOne(Hl, this._element)
        const r = this._getItemIndex(this._activeElement)
        if (e > this._items.length - 1 || e < 0) return
        if (this._isSliding) {
            ae.one(this._element, Tg, () => this.to(e))
            return
        }
        if (r === e) {
            this.pause(), this.cycle()
            return
        }
        const n = e > r ? ms : bs
        this._slide(n, this._items[e])
    }
    _getConfig(e) {
        return (e = Fe(Fe(Fe({}, Ag), ir.getDataAttributes(this._element)), typeof e == "object" ? e : {})), zn(Sg, e, X7), e
    }
    _handleSwipe() {
        const e = Math.abs(this.touchDeltaX)
        if (e <= J7) return
        const r = e / this.touchDeltaX
        ;(this.touchDeltaX = 0), !!r && this._slide(r > 0 ? xa : _s)
    }
    _addEventListeners() {
        this._config.keyboard && ae.on(this._element, Q7, (e) => this._keydown(e)),
            this._config.pause === "hover" && (ae.on(this._element, eS, (e) => this.pause(e)), ae.on(this._element, tS, (e) => this.cycle(e))),
            this._config.touch && this._touchSupported && this._addTouchEventListeners()
    }
    _addTouchEventListeners() {
        const e = (s) => this._pointerEvent && (s.pointerType === TS || s.pointerType === AS),
            r = (s) => {
                e(s) ? (this.touchStartX = s.clientX) : this._pointerEvent || (this.touchStartX = s.touches[0].clientX)
            },
            n = (s) => {
                this.touchDeltaX = s.touches && s.touches.length > 1 ? 0 : s.touches[0].clientX - this.touchStartX
            },
            i = (s) => {
                e(s) && (this.touchDeltaX = s.clientX - this.touchStartX),
                    this._handleSwipe(),
                    this._config.pause === "hover" &&
                        (this.pause(),
                        this.touchTimeout && clearTimeout(this.touchTimeout),
                        (this.touchTimeout = setTimeout((o) => this.cycle(o), W7 + this._config.interval)))
            }
        Pe.find(vS, this._element).forEach((s) => {
            ae.on(s, aS, (o) => o.preventDefault())
        }),
            this._pointerEvent
                ? (ae.on(this._element, sS, (s) => r(s)), ae.on(this._element, oS, (s) => i(s)), this._element.classList.add(mS))
                : (ae.on(this._element, rS, (s) => r(s)), ae.on(this._element, nS, (s) => n(s)), ae.on(this._element, iS, (s) => i(s)))
    }
    _keydown(e) {
        if (/input|textarea/i.test(e.target.tagName)) return
        const r = Y7[e.key]
        r && (e.preventDefault(), this._slide(r))
    }
    _getItemIndex(e) {
        return (this._items = e && e.parentNode ? Pe.find(xS, e.parentNode) : []), this._items.indexOf(e)
    }
    _getItemByOrder(e, r) {
        const n = e === ms
        return vv(this._items, r, n, this._config.wrap)
    }
    _triggerSlideEvent(e, r) {
        const n = this._getItemIndex(e),
            i = this._getItemIndex(Pe.findOne(Hl, this._element))
        return ae.trigger(this._element, Z7, { relatedTarget: e, direction: r, from: i, to: n })
    }
    _setActiveIndicatorElement(e) {
        if (this._indicatorsElement) {
            const r = Pe.findOne(bS, this._indicatorsElement)
            r.classList.remove(xs), r.removeAttribute("aria-current")
            const n = Pe.find(wS, this._indicatorsElement)
            for (let i = 0; i < n.length; i++)
                if (Number.parseInt(n[i].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(e)) {
                    n[i].classList.add(xs), n[i].setAttribute("aria-current", "true")
                    break
                }
        }
    }
    _updateInterval() {
        const e = this._activeElement || Pe.findOne(Hl, this._element)
        if (!e) return
        const r = Number.parseInt(e.getAttribute("data-bs-interval"), 10)
        r
            ? ((this._config.defaultInterval = this._config.defaultInterval || this._config.interval), (this._config.interval = r))
            : (this._config.interval = this._config.defaultInterval || this._config.interval)
    }
    _slide(e, r) {
        const n = this._directionToOrder(e),
            i = Pe.findOne(Hl, this._element),
            s = this._getItemIndex(i),
            o = r || this._getItemByOrder(n, i),
            a = this._getItemIndex(o),
            l = Boolean(this._interval),
            c = n === ms,
            f = c ? hS : dS,
            u = c ? pS : gS,
            p = this._orderToDirection(n)
        if (o && o.classList.contains(xs)) {
            this._isSliding = !1
            return
        }
        if (this._isSliding || this._triggerSlideEvent(o, p).defaultPrevented || !i || !o) return
        ;(this._isSliding = !0), l && this.pause(), this._setActiveIndicatorElement(o), (this._activeElement = o)
        const y = () => {
            ae.trigger(this._element, Tg, { relatedTarget: o, direction: p, from: s, to: a })
        }
        if (this._element.classList.contains(uS)) {
            o.classList.add(u), Wo(o), i.classList.add(f), o.classList.add(f)
            const v = () => {
                o.classList.remove(f, u), o.classList.add(xs), i.classList.remove(xs, u, f), (this._isSliding = !1), setTimeout(y, 0)
            }
            this._queueCallback(v, i, !0)
        } else i.classList.remove(xs), o.classList.add(xs), (this._isSliding = !1), y()
        l && this.cycle()
    }
    _directionToOrder(e) {
        return [xa, _s].includes(e) ? (wr() ? (e === _s ? bs : ms) : e === _s ? ms : bs) : e
    }
    _orderToDirection(e) {
        return [ms, bs].includes(e) ? (wr() ? (e === bs ? _s : xa) : e === bs ? xa : _s) : e
    }
    static carouselInterface(e, r) {
        const n = An.getOrCreateInstance(e, r)
        let { _config: i } = n
        typeof r == "object" && (i = Fe(Fe({}, i), r))
        const s = typeof r == "string" ? r : i.slide
        if (typeof r == "number") n.to(r)
        else if (typeof s == "string") {
            if (typeof n[s] == "undefined") throw new TypeError(`No method named "${s}"`)
            n[s]()
        } else i.interval && i.ride && (n.pause(), n.cycle())
    }
    static jQueryInterface(e) {
        return this.each(function () {
            An.carouselInterface(this, e)
        })
    }
    static dataApiClickHandler(e) {
        const r = Ki(this)
        if (!r || !r.classList.contains(fS)) return
        const n = Fe(Fe({}, ir.getDataAttributes(r)), ir.getDataAttributes(this)),
            i = this.getAttribute("data-bs-slide-to")
        i && (n.interval = !1), An.carouselInterface(r, n), i && An.getInstance(r).to(i), e.preventDefault()
    }
}
ae.on(document, cS, ES, An.dataApiClickHandler)
ae.on(window, lS, () => {
    const t = Pe.find(SS)
    for (let e = 0, r = t.length; e < r; e++) An.carouselInterface(t[e], An.getInstance(t[e]))
})
Xr(An)
const Cg = "collapse",
    kv = "bs.collapse",
    bl = `.${kv}`,
    CS = ".data-api",
    kg = { toggle: !0, parent: null },
    kS = { toggle: "boolean", parent: "(null|element)" },
    NS = `show${bl}`,
    PS = `shown${bl}`,
    IS = `hide${bl}`,
    $S = `hidden${bl}`,
    BS = `click${bl}${CS}`,
    wu = "show",
    ho = "collapse",
    ql = "collapsing",
    Ng = "collapsed",
    Pg = `:scope .${ho} .${ho}`,
    OS = "collapse-horizontal",
    MS = "width",
    RS = "height",
    LS = ".collapse.show, .collapse.collapsing",
    Ed = '[data-bs-toggle="collapse"]'
class $s extends cn {
    constructor(e, r) {
        super(e)
        ;(this._isTransitioning = !1), (this._config = this._getConfig(r)), (this._triggerArray = [])
        const n = Pe.find(Ed)
        for (let i = 0, s = n.length; i < s; i++) {
            const o = n[i],
                a = nh(o),
                l = Pe.find(a).filter((c) => c === this._element)
            a !== null && l.length && ((this._selector = a), this._triggerArray.push(o))
        }
        this._initializeChildren(),
            this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
            this._config.toggle && this.toggle()
    }
    static get Default() {
        return kg
    }
    static get NAME() {
        return Cg
    }
    toggle() {
        this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (this._isTransitioning || this._isShown()) return
        let e = [],
            r
        if (this._config.parent) {
            const c = Pe.find(Pg, this._config.parent)
            e = Pe.find(LS, this._config.parent).filter((f) => !c.includes(f))
        }
        const n = Pe.findOne(this._selector)
        if (e.length) {
            const c = e.find((f) => n !== f)
            if (((r = c ? $s.getInstance(c) : null), r && r._isTransitioning)) return
        }
        if (ae.trigger(this._element, NS).defaultPrevented) return
        e.forEach((c) => {
            n !== c && $s.getOrCreateInstance(c, { toggle: !1 }).hide(), r || Oa.set(c, kv, null)
        })
        const s = this._getDimension()
        this._element.classList.remove(ho),
            this._element.classList.add(ql),
            (this._element.style[s] = 0),
            this._addAriaAndCollapsedClass(this._triggerArray, !0),
            (this._isTransitioning = !0)
        const o = () => {
                ;(this._isTransitioning = !1),
                    this._element.classList.remove(ql),
                    this._element.classList.add(ho, wu),
                    (this._element.style[s] = ""),
                    ae.trigger(this._element, PS)
            },
            l = `scroll${s[0].toUpperCase() + s.slice(1)}`
        this._queueCallback(o, this._element, !0), (this._element.style[s] = `${this._element[l]}px`)
    }
    hide() {
        if (this._isTransitioning || !this._isShown() || ae.trigger(this._element, IS).defaultPrevented) return
        const r = this._getDimension()
        ;(this._element.style[r] = `${this._element.getBoundingClientRect()[r]}px`),
            Wo(this._element),
            this._element.classList.add(ql),
            this._element.classList.remove(ho, wu)
        const n = this._triggerArray.length
        for (let s = 0; s < n; s++) {
            const o = this._triggerArray[s],
                a = Ki(o)
            a && !this._isShown(a) && this._addAriaAndCollapsedClass([o], !1)
        }
        this._isTransitioning = !0
        const i = () => {
            ;(this._isTransitioning = !1), this._element.classList.remove(ql), this._element.classList.add(ho), ae.trigger(this._element, $S)
        }
        ;(this._element.style[r] = ""), this._queueCallback(i, this._element, !0)
    }
    _isShown(e = this._element) {
        return e.classList.contains(wu)
    }
    _getConfig(e) {
        return (
            (e = Fe(Fe(Fe({}, kg), ir.getDataAttributes(this._element)), e)),
            (e.toggle = Boolean(e.toggle)),
            (e.parent = Gi(e.parent)),
            zn(Cg, e, kS),
            e
        )
    }
    _getDimension() {
        return this._element.classList.contains(OS) ? MS : RS
    }
    _initializeChildren() {
        if (!this._config.parent) return
        const e = Pe.find(Pg, this._config.parent)
        Pe.find(Ed, this._config.parent)
            .filter((r) => !e.includes(r))
            .forEach((r) => {
                const n = Ki(r)
                n && this._addAriaAndCollapsedClass([r], this._isShown(n))
            })
    }
    _addAriaAndCollapsedClass(e, r) {
        !e.length ||
            e.forEach((n) => {
                r ? n.classList.remove(Ng) : n.classList.add(Ng), n.setAttribute("aria-expanded", r)
            })
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = {}
            typeof e == "string" && /show|hide/.test(e) && (r.toggle = !1)
            const n = $s.getOrCreateInstance(this, r)
            if (typeof e == "string") {
                if (typeof n[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                n[e]()
            }
        })
    }
}
ae.on(document, BS, Ed, function (t) {
    ;(t.target.tagName === "A" || (t.delegateTarget && t.delegateTarget.tagName === "A")) && t.preventDefault()
    const e = nh(this)
    Pe.find(e).forEach((n) => {
        $s.getOrCreateInstance(n, { toggle: !1 }).toggle()
    })
})
Xr($s)
const Eu = "dropdown",
    DS = "bs.dropdown",
    zs = `.${DS}`,
    ih = ".data-api",
    ac = "Escape",
    Ig = "Space",
    $g = "Tab",
    Sd = "ArrowUp",
    lc = "ArrowDown",
    FS = 2,
    VS = new RegExp(`${Sd}|${lc}|${ac}`),
    US = `hide${zs}`,
    HS = `hidden${zs}`,
    qS = `show${zs}`,
    jS = `shown${zs}`,
    Nv = `click${zs}${ih}`,
    Pv = `keydown${zs}${ih}`,
    zS = `keyup${zs}${ih}`,
    Zs = "show",
    KS = "dropup",
    GS = "dropend",
    WS = "dropstart",
    JS = "navbar",
    Ma = '[data-bs-toggle="dropdown"]',
    Ad = ".dropdown-menu",
    XS = ".navbar-nav",
    YS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
    ZS = wr() ? "top-end" : "top-start",
    QS = wr() ? "top-start" : "top-end",
    e9 = wr() ? "bottom-end" : "bottom-start",
    t9 = wr() ? "bottom-start" : "bottom-end",
    r9 = wr() ? "left-start" : "right-start",
    n9 = wr() ? "right-start" : "left-start",
    i9 = { offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, autoClose: !0 },
    s9 = {
        offset: "(array|string|function)",
        boundary: "(string|element)",
        reference: "(string|element|object)",
        display: "string",
        popperConfig: "(null|object|function)",
        autoClose: "(boolean|string)",
    }
class Ir extends cn {
    constructor(e, r) {
        super(e)
        ;(this._popper = null),
            (this._config = this._getConfig(r)),
            (this._menu = this._getMenuElement()),
            (this._inNavbar = this._detectNavbar())
    }
    static get Default() {
        return i9
    }
    static get DefaultType() {
        return s9
    }
    static get NAME() {
        return Eu
    }
    toggle() {
        return this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (Is(this._element) || this._isShown(this._menu)) return
        const e = { relatedTarget: this._element }
        if (ae.trigger(this._element, qS, e).defaultPrevented) return
        const n = Ir.getParentFromElement(this._element)
        this._inNavbar ? ir.setDataAttribute(this._menu, "popper", "none") : this._createPopper(n),
            "ontouchstart" in document.documentElement &&
                !n.closest(XS) &&
                [].concat(...document.body.children).forEach((i) => ae.on(i, "mouseover", Pc)),
            this._element.focus(),
            this._element.setAttribute("aria-expanded", !0),
            this._menu.classList.add(Zs),
            this._element.classList.add(Zs),
            ae.trigger(this._element, jS, e)
    }
    hide() {
        if (Is(this._element) || !this._isShown(this._menu)) return
        const e = { relatedTarget: this._element }
        this._completeHide(e)
    }
    dispose() {
        this._popper && this._popper.destroy(), super.dispose()
    }
    update() {
        ;(this._inNavbar = this._detectNavbar()), this._popper && this._popper.update()
    }
    _completeHide(e) {
        ae.trigger(this._element, US, e).defaultPrevented ||
            ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((n) => ae.off(n, "mouseover", Pc)),
            this._popper && this._popper.destroy(),
            this._menu.classList.remove(Zs),
            this._element.classList.remove(Zs),
            this._element.setAttribute("aria-expanded", "false"),
            ir.removeDataAttribute(this._menu, "popper"),
            ae.trigger(this._element, HS, e))
    }
    _getConfig(e) {
        if (
            ((e = Fe(Fe(Fe({}, this.constructor.Default), ir.getDataAttributes(this._element)), e)),
            zn(Eu, e, this.constructor.DefaultType),
            typeof e.reference == "object" && !Ds(e.reference) && typeof e.reference.getBoundingClientRect != "function")
        )
            throw new TypeError(
                `${Eu.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
            )
        return e
    }
    _createPopper(e) {
        if (typeof hv == "undefined") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)")
        let r = this._element
        this._config.reference === "parent"
            ? (r = e)
            : Ds(this._config.reference)
            ? (r = Gi(this._config.reference))
            : typeof this._config.reference == "object" && (r = this._config.reference)
        const n = this._getPopperConfig(),
            i = n.modifiers.find((s) => s.name === "applyStyles" && s.enabled === !1)
        ;(this._popper = rh(r, this._menu, n)), i && ir.setDataAttribute(this._menu, "popper", "static")
    }
    _isShown(e = this._element) {
        return e.classList.contains(Zs)
    }
    _getMenuElement() {
        return Pe.next(this._element, Ad)[0]
    }
    _getPlacement() {
        const e = this._element.parentNode
        if (e.classList.contains(GS)) return r9
        if (e.classList.contains(WS)) return n9
        const r = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end"
        return e.classList.contains(KS) ? (r ? QS : ZS) : r ? t9 : e9
    }
    _detectNavbar() {
        return this._element.closest(`.${JS}`) !== null
    }
    _getOffset() {
        const { offset: e } = this._config
        return typeof e == "string" ? e.split(",").map((r) => Number.parseInt(r, 10)) : typeof e == "function" ? (r) => e(r, this._element) : e
    }
    _getPopperConfig() {
        const e = {
            placement: this._getPlacement(),
            modifiers: [
                { name: "preventOverflow", options: { boundary: this._config.boundary } },
                { name: "offset", options: { offset: this._getOffset() } },
            ],
        }
        return (
            this._config.display === "static" && (e.modifiers = [{ name: "applyStyles", enabled: !1 }]),
            Fe(Fe({}, e), typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig)
        )
    }
    _selectMenuItem({ key: e, target: r }) {
        const n = Pe.find(YS, this._menu).filter(gl)
        !n.length || vv(n, r, e === lc, !n.includes(r)).focus()
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = Ir.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof r[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                r[e]()
            }
        })
    }
    static clearMenus(e) {
        if (e && (e.button === FS || (e.type === "keyup" && e.key !== $g))) return
        const r = Pe.find(Ma)
        for (let n = 0, i = r.length; n < i; n++) {
            const s = Ir.getInstance(r[n])
            if (!s || s._config.autoClose === !1 || !s._isShown()) continue
            const o = { relatedTarget: s._element }
            if (e) {
                const a = e.composedPath(),
                    l = a.includes(s._menu)
                if (
                    a.includes(s._element) ||
                    (s._config.autoClose === "inside" && !l) ||
                    (s._config.autoClose === "outside" && l) ||
                    (s._menu.contains(e.target) &&
                        ((e.type === "keyup" && e.key === $g) || /input|select|option|textarea|form/i.test(e.target.tagName)))
                )
                    continue
                e.type === "click" && (o.clickEvent = e)
            }
            s._completeHide(o)
        }
    }
    static getParentFromElement(e) {
        return Ki(e) || e.parentNode
    }
    static dataApiKeydownHandler(e) {
        if (
            /input|textarea/i.test(e.target.tagName)
                ? e.key === Ig || (e.key !== ac && ((e.key !== lc && e.key !== Sd) || e.target.closest(Ad)))
                : !VS.test(e.key)
        )
            return
        const r = this.classList.contains(Zs)
        if ((!r && e.key === ac) || (e.preventDefault(), e.stopPropagation(), Is(this))) return
        const n = this.matches(Ma) ? this : Pe.prev(this, Ma)[0],
            i = Ir.getOrCreateInstance(n)
        if (e.key === ac) {
            i.hide()
            return
        }
        if (e.key === Sd || e.key === lc) {
            r || i.show(), i._selectMenuItem(e)
            return
        }
        ;(!r || e.key === Ig) && Ir.clearMenus()
    }
}
ae.on(document, Pv, Ma, Ir.dataApiKeydownHandler)
ae.on(document, Pv, Ad, Ir.dataApiKeydownHandler)
ae.on(document, Nv, Ir.clearMenus)
ae.on(document, zS, Ir.clearMenus)
ae.on(document, Nv, Ma, function (t) {
    t.preventDefault(), Ir.getOrCreateInstance(this).toggle()
})
Xr(Ir)
const Bg = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    Og = ".sticky-top"
class Td {
    constructor() {
        this._element = document.body
    }
    getWidth() {
        const e = document.documentElement.clientWidth
        return Math.abs(window.innerWidth - e)
    }
    hide() {
        const e = this.getWidth()
        this._disableOverFlow(),
            this._setElementAttributes(this._element, "paddingRight", (r) => r + e),
            this._setElementAttributes(Bg, "paddingRight", (r) => r + e),
            this._setElementAttributes(Og, "marginRight", (r) => r - e)
    }
    _disableOverFlow() {
        this._saveInitialAttribute(this._element, "overflow"), (this._element.style.overflow = "hidden")
    }
    _setElementAttributes(e, r, n) {
        const i = this.getWidth(),
            s = (o) => {
                if (o !== this._element && window.innerWidth > o.clientWidth + i) return
                this._saveInitialAttribute(o, r)
                const a = window.getComputedStyle(o)[r]
                o.style[r] = `${n(Number.parseFloat(a))}px`
            }
        this._applyManipulationCallback(e, s)
    }
    reset() {
        this._resetElementAttributes(this._element, "overflow"),
            this._resetElementAttributes(this._element, "paddingRight"),
            this._resetElementAttributes(Bg, "paddingRight"),
            this._resetElementAttributes(Og, "marginRight")
    }
    _saveInitialAttribute(e, r) {
        const n = e.style[r]
        n && ir.setDataAttribute(e, r, n)
    }
    _resetElementAttributes(e, r) {
        const n = (i) => {
            const s = ir.getDataAttribute(i, r)
            typeof s == "undefined" ? i.style.removeProperty(r) : (ir.removeDataAttribute(i, r), (i.style[r] = s))
        }
        this._applyManipulationCallback(e, n)
    }
    _applyManipulationCallback(e, r) {
        Ds(e) ? r(e) : Pe.find(e, this._element).forEach(r)
    }
    isOverflowing() {
        return this.getWidth() > 0
    }
}
const o9 = { className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null },
    a9 = { className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" },
    Iv = "backdrop",
    l9 = "fade",
    Mg = "show",
    Rg = `mousedown.bs.${Iv}`
class $v {
    constructor(e) {
        ;(this._config = this._getConfig(e)), (this._isAppended = !1), (this._element = null)
    }
    show(e) {
        if (!this._config.isVisible) {
            Ss(e)
            return
        }
        this._append(),
            this._config.isAnimated && Wo(this._getElement()),
            this._getElement().classList.add(Mg),
            this._emulateAnimation(() => {
                Ss(e)
            })
    }
    hide(e) {
        if (!this._config.isVisible) {
            Ss(e)
            return
        }
        this._getElement().classList.remove(Mg),
            this._emulateAnimation(() => {
                this.dispose(), Ss(e)
            })
    }
    _getElement() {
        if (!this._element) {
            const e = document.createElement("div")
            ;(e.className = this._config.className), this._config.isAnimated && e.classList.add(l9), (this._element = e)
        }
        return this._element
    }
    _getConfig(e) {
        return (e = Fe(Fe({}, o9), typeof e == "object" ? e : {})), (e.rootElement = Gi(e.rootElement)), zn(Iv, e, a9), e
    }
    _append() {
        this._isAppended ||
            (this._config.rootElement.append(this._getElement()),
            ae.on(this._getElement(), Rg, () => {
                Ss(this._config.clickCallback)
            }),
            (this._isAppended = !0))
    }
    dispose() {
        !this._isAppended || (ae.off(this._element, Rg), this._element.remove(), (this._isAppended = !1))
    }
    _emulateAnimation(e) {
        xv(e, this._getElement(), this._config.isAnimated)
    }
}
const c9 = { trapElement: null, autofocus: !0 },
    f9 = { trapElement: "element", autofocus: "boolean" },
    u9 = "focustrap",
    d9 = "bs.focustrap",
    Ic = `.${d9}`,
    h9 = `focusin${Ic}`,
    p9 = `keydown.tab${Ic}`,
    g9 = "Tab",
    m9 = "forward",
    Lg = "backward"
class Bv {
    constructor(e) {
        ;(this._config = this._getConfig(e)), (this._isActive = !1), (this._lastTabNavDirection = null)
    }
    activate() {
        const { trapElement: e, autofocus: r } = this._config
        this._isActive ||
            (r && e.focus(),
            ae.off(document, Ic),
            ae.on(document, h9, (n) => this._handleFocusin(n)),
            ae.on(document, p9, (n) => this._handleKeydown(n)),
            (this._isActive = !0))
    }
    deactivate() {
        !this._isActive || ((this._isActive = !1), ae.off(document, Ic))
    }
    _handleFocusin(e) {
        const { target: r } = e,
            { trapElement: n } = this._config
        if (r === document || r === n || n.contains(r)) return
        const i = Pe.focusableChildren(n)
        i.length === 0 ? n.focus() : this._lastTabNavDirection === Lg ? i[i.length - 1].focus() : i[0].focus()
    }
    _handleKeydown(e) {
        e.key === g9 && (this._lastTabNavDirection = e.shiftKey ? Lg : m9)
    }
    _getConfig(e) {
        return (e = Fe(Fe({}, c9), typeof e == "object" ? e : {})), zn(u9, e, f9), e
    }
}
const Dg = "modal",
    b9 = "bs.modal",
    Yr = `.${b9}`,
    x9 = ".data-api",
    Fg = "Escape",
    Vg = { backdrop: !0, keyboard: !0, focus: !0 },
    v9 = { backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean" },
    y9 = `hide${Yr}`,
    _9 = `hidePrevented${Yr}`,
    Ov = `hidden${Yr}`,
    Mv = `show${Yr}`,
    w9 = `shown${Yr}`,
    Ug = `resize${Yr}`,
    Hg = `click.dismiss${Yr}`,
    qg = `keydown.dismiss${Yr}`,
    E9 = `mouseup.dismiss${Yr}`,
    jg = `mousedown.dismiss${Yr}`,
    S9 = `click${Yr}${x9}`,
    zg = "modal-open",
    A9 = "fade",
    Kg = "show",
    Su = "modal-static",
    T9 = ".modal.show",
    C9 = ".modal-dialog",
    k9 = ".modal-body",
    N9 = '[data-bs-toggle="modal"]'
class Fs extends cn {
    constructor(e, r) {
        super(e)
        ;(this._config = this._getConfig(r)),
            (this._dialog = Pe.findOne(C9, this._element)),
            (this._backdrop = this._initializeBackDrop()),
            (this._focustrap = this._initializeFocusTrap()),
            (this._isShown = !1),
            (this._ignoreBackdropClick = !1),
            (this._isTransitioning = !1),
            (this._scrollBar = new Td())
    }
    static get Default() {
        return Vg
    }
    static get NAME() {
        return Dg
    }
    toggle(e) {
        return this._isShown ? this.hide() : this.show(e)
    }
    show(e) {
        this._isShown ||
            this._isTransitioning ||
            ae.trigger(this._element, Mv, { relatedTarget: e }).defaultPrevented ||
            ((this._isShown = !0),
            this._isAnimated() && (this._isTransitioning = !0),
            this._scrollBar.hide(),
            document.body.classList.add(zg),
            this._adjustDialog(),
            this._setEscapeEvent(),
            this._setResizeEvent(),
            ae.on(this._dialog, jg, () => {
                ae.one(this._element, E9, (n) => {
                    n.target === this._element && (this._ignoreBackdropClick = !0)
                })
            }),
            this._showBackdrop(() => this._showElement(e)))
    }
    hide() {
        if (!this._isShown || this._isTransitioning || ae.trigger(this._element, y9).defaultPrevented) return
        this._isShown = !1
        const r = this._isAnimated()
        r && (this._isTransitioning = !0),
            this._setEscapeEvent(),
            this._setResizeEvent(),
            this._focustrap.deactivate(),
            this._element.classList.remove(Kg),
            ae.off(this._element, Hg),
            ae.off(this._dialog, jg),
            this._queueCallback(() => this._hideModal(), this._element, r)
    }
    dispose() {
        ;[window, this._dialog].forEach((e) => ae.off(e, Yr)), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    handleUpdate() {
        this._adjustDialog()
    }
    _initializeBackDrop() {
        return new $v({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() })
    }
    _initializeFocusTrap() {
        return new Bv({ trapElement: this._element })
    }
    _getConfig(e) {
        return (e = Fe(Fe(Fe({}, Vg), ir.getDataAttributes(this._element)), typeof e == "object" ? e : {})), zn(Dg, e, v9), e
    }
    _showElement(e) {
        const r = this._isAnimated(),
            n = Pe.findOne(k9, this._dialog)
        ;(!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element),
            (this._element.style.display = "block"),
            this._element.removeAttribute("aria-hidden"),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            (this._element.scrollTop = 0),
            n && (n.scrollTop = 0),
            r && Wo(this._element),
            this._element.classList.add(Kg)
        const i = () => {
            this._config.focus && this._focustrap.activate(), (this._isTransitioning = !1), ae.trigger(this._element, w9, { relatedTarget: e })
        }
        this._queueCallback(i, this._dialog, r)
    }
    _setEscapeEvent() {
        this._isShown
            ? ae.on(this._element, qg, (e) => {
                  this._config.keyboard && e.key === Fg
                      ? (e.preventDefault(), this.hide())
                      : !this._config.keyboard && e.key === Fg && this._triggerBackdropTransition()
              })
            : ae.off(this._element, qg)
    }
    _setResizeEvent() {
        this._isShown ? ae.on(window, Ug, () => this._adjustDialog()) : ae.off(window, Ug)
    }
    _hideModal() {
        ;(this._element.style.display = "none"),
            this._element.setAttribute("aria-hidden", !0),
            this._element.removeAttribute("aria-modal"),
            this._element.removeAttribute("role"),
            (this._isTransitioning = !1),
            this._backdrop.hide(() => {
                document.body.classList.remove(zg), this._resetAdjustments(), this._scrollBar.reset(), ae.trigger(this._element, Ov)
            })
    }
    _showBackdrop(e) {
        ae.on(this._element, Hg, (r) => {
            if (this._ignoreBackdropClick) {
                this._ignoreBackdropClick = !1
                return
            }
            r.target === r.currentTarget &&
                (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition())
        }),
            this._backdrop.show(e)
    }
    _isAnimated() {
        return this._element.classList.contains(A9)
    }
    _triggerBackdropTransition() {
        if (ae.trigger(this._element, _9).defaultPrevented) return
        const { classList: r, scrollHeight: n, style: i } = this._element,
            s = n > document.documentElement.clientHeight
        ;(!s && i.overflowY === "hidden") ||
            r.contains(Su) ||
            (s || (i.overflowY = "hidden"),
            r.add(Su),
            this._queueCallback(() => {
                r.remove(Su),
                    s ||
                        this._queueCallback(() => {
                            i.overflowY = ""
                        }, this._dialog)
            }, this._dialog),
            this._element.focus())
    }
    _adjustDialog() {
        const e = this._element.scrollHeight > document.documentElement.clientHeight,
            r = this._scrollBar.getWidth(),
            n = r > 0
        ;((!n && e && !wr()) || (n && !e && wr())) && (this._element.style.paddingLeft = `${r}px`),
            ((n && !e && !wr()) || (!n && e && wr())) && (this._element.style.paddingRight = `${r}px`)
    }
    _resetAdjustments() {
        ;(this._element.style.paddingLeft = ""), (this._element.style.paddingRight = "")
    }
    static jQueryInterface(e, r) {
        return this.each(function () {
            const n = Fs.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof n[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                n[e](r)
            }
        })
    }
}
ae.on(document, S9, N9, function (t) {
    const e = Ki(this)
    ;["A", "AREA"].includes(this.tagName) && t.preventDefault(),
        ae.one(e, Mv, (i) => {
            i.defaultPrevented ||
                ae.one(e, Ov, () => {
                    gl(this) && this.focus()
                })
        })
    const r = Pe.findOne(T9)
    r && Fs.getInstance(r).hide(), Fs.getOrCreateInstance(e).toggle(this)
})
pf(Fs)
Xr(Fs)
const Gg = "offcanvas",
    P9 = "bs.offcanvas",
    Ks = `.${P9}`,
    Rv = ".data-api",
    I9 = `load${Ks}${Rv}`,
    $9 = "Escape",
    Wg = { backdrop: !0, keyboard: !0, scroll: !1 },
    B9 = { backdrop: "boolean", keyboard: "boolean", scroll: "boolean" },
    Jg = "show",
    O9 = "offcanvas-backdrop",
    Lv = ".offcanvas.show",
    M9 = `show${Ks}`,
    R9 = `shown${Ks}`,
    L9 = `hide${Ks}`,
    Dv = `hidden${Ks}`,
    D9 = `click${Ks}${Rv}`,
    F9 = `keydown.dismiss${Ks}`,
    V9 = '[data-bs-toggle="offcanvas"]'
class Wi extends cn {
    constructor(e, r) {
        super(e)
        ;(this._config = this._getConfig(r)),
            (this._isShown = !1),
            (this._backdrop = this._initializeBackDrop()),
            (this._focustrap = this._initializeFocusTrap()),
            this._addEventListeners()
    }
    static get NAME() {
        return Gg
    }
    static get Default() {
        return Wg
    }
    toggle(e) {
        return this._isShown ? this.hide() : this.show(e)
    }
    show(e) {
        if (this._isShown || ae.trigger(this._element, M9, { relatedTarget: e }).defaultPrevented) return
        ;(this._isShown = !0),
            (this._element.style.visibility = "visible"),
            this._backdrop.show(),
            this._config.scroll || new Td().hide(),
            this._element.removeAttribute("aria-hidden"),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            this._element.classList.add(Jg)
        const n = () => {
            this._config.scroll || this._focustrap.activate(), ae.trigger(this._element, R9, { relatedTarget: e })
        }
        this._queueCallback(n, this._element, !0)
    }
    hide() {
        if (!this._isShown || ae.trigger(this._element, L9).defaultPrevented) return
        this._focustrap.deactivate(), this._element.blur(), (this._isShown = !1), this._element.classList.remove(Jg), this._backdrop.hide()
        const r = () => {
            this._element.setAttribute("aria-hidden", !0),
                this._element.removeAttribute("aria-modal"),
                this._element.removeAttribute("role"),
                (this._element.style.visibility = "hidden"),
                this._config.scroll || new Td().reset(),
                ae.trigger(this._element, Dv)
        }
        this._queueCallback(r, this._element, !0)
    }
    dispose() {
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    _getConfig(e) {
        return (e = Fe(Fe(Fe({}, Wg), ir.getDataAttributes(this._element)), typeof e == "object" ? e : {})), zn(Gg, e, B9), e
    }
    _initializeBackDrop() {
        return new $v({
            className: O9,
            isVisible: this._config.backdrop,
            isAnimated: !0,
            rootElement: this._element.parentNode,
            clickCallback: () => this.hide(),
        })
    }
    _initializeFocusTrap() {
        return new Bv({ trapElement: this._element })
    }
    _addEventListeners() {
        ae.on(this._element, F9, (e) => {
            this._config.keyboard && e.key === $9 && this.hide()
        })
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = Wi.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (r[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`)
                r[e](this)
            }
        })
    }
}
ae.on(document, D9, V9, function (t) {
    const e = Ki(this)
    if ((["A", "AREA"].includes(this.tagName) && t.preventDefault(), Is(this))) return
    ae.one(e, Dv, () => {
        gl(this) && this.focus()
    })
    const r = Pe.findOne(Lv)
    r && r !== e && Wi.getInstance(r).hide(), Wi.getOrCreateInstance(e).toggle(this)
})
ae.on(window, I9, () => Pe.find(Lv).forEach((t) => Wi.getOrCreateInstance(t).show()))
pf(Wi)
Xr(Wi)
const U9 = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
    H9 = /^aria-[\w-]*$/i,
    q9 = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
    j9 = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
    z9 = (t, e) => {
        const r = t.nodeName.toLowerCase()
        if (e.includes(r)) return U9.has(r) ? Boolean(q9.test(t.nodeValue) || j9.test(t.nodeValue)) : !0
        const n = e.filter((i) => i instanceof RegExp)
        for (let i = 0, s = n.length; i < s; i++) if (n[i].test(r)) return !0
        return !1
    },
    K9 = {
        "*": ["class", "dir", "id", "lang", "role", H9],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: [],
    }
function Xg(t, e, r) {
    if (!t.length) return t
    if (r && typeof r == "function") return r(t)
    const i = new window.DOMParser().parseFromString(t, "text/html"),
        s = [].concat(...i.body.querySelectorAll("*"))
    for (let o = 0, a = s.length; o < a; o++) {
        const l = s[o],
            c = l.nodeName.toLowerCase()
        if (!Object.keys(e).includes(c)) {
            l.remove()
            continue
        }
        const f = [].concat(...l.attributes),
            u = [].concat(e["*"] || [], e[c] || [])
        f.forEach((p) => {
            z9(p, u) || l.removeAttribute(p.nodeName)
        })
    }
    return i.body.innerHTML
}
const Yg = "tooltip",
    G9 = "bs.tooltip",
    hn = `.${G9}`,
    W9 = "bs-tooltip",
    J9 = new Set(["sanitize", "allowList", "sanitizeFn"]),
    X9 = {
        animation: "boolean",
        template: "string",
        title: "(string|element|function)",
        trigger: "string",
        delay: "(number|object)",
        html: "boolean",
        selector: "(string|boolean)",
        placement: "(string|function)",
        offset: "(array|string|function)",
        container: "(string|element|boolean)",
        fallbackPlacements: "array",
        boundary: "(string|element)",
        customClass: "(string|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        allowList: "object",
        popperConfig: "(null|object|function)",
    },
    Y9 = { AUTO: "auto", TOP: "top", RIGHT: wr() ? "left" : "right", BOTTOM: "bottom", LEFT: wr() ? "right" : "left" },
    Z9 = {
        animation: !0,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        selector: !1,
        placement: "top",
        offset: [0, 0],
        container: !1,
        fallbackPlacements: ["top", "right", "bottom", "left"],
        boundary: "clippingParents",
        customClass: "",
        sanitize: !0,
        sanitizeFn: null,
        allowList: K9,
        popperConfig: null,
    },
    Q9 = {
        HIDE: `hide${hn}`,
        HIDDEN: `hidden${hn}`,
        SHOW: `show${hn}`,
        SHOWN: `shown${hn}`,
        INSERTED: `inserted${hn}`,
        CLICK: `click${hn}`,
        FOCUSIN: `focusin${hn}`,
        FOCUSOUT: `focusout${hn}`,
        MOUSEENTER: `mouseenter${hn}`,
        MOUSELEAVE: `mouseleave${hn}`,
    },
    jl = "fade",
    eA = "modal",
    la = "show",
    ca = "show",
    Au = "out",
    Zg = ".tooltip-inner",
    Qg = `.${eA}`,
    em = "hide.bs.modal",
    fa = "hover",
    Tu = "focus",
    tA = "click",
    rA = "manual"
class ti extends cn {
    constructor(e, r) {
        if (typeof hv == "undefined") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)")
        super(e)
        ;(this._isEnabled = !0),
            (this._timeout = 0),
            (this._hoverState = ""),
            (this._activeTrigger = {}),
            (this._popper = null),
            (this._config = this._getConfig(r)),
            (this.tip = null),
            this._setListeners()
    }
    static get Default() {
        return Z9
    }
    static get NAME() {
        return Yg
    }
    static get Event() {
        return Q9
    }
    static get DefaultType() {
        return X9
    }
    enable() {
        this._isEnabled = !0
    }
    disable() {
        this._isEnabled = !1
    }
    toggleEnabled() {
        this._isEnabled = !this._isEnabled
    }
    toggle(e) {
        if (!!this._isEnabled)
            if (e) {
                const r = this._initializeOnDelegatedTarget(e)
                ;(r._activeTrigger.click = !r._activeTrigger.click), r._isWithActiveTrigger() ? r._enter(null, r) : r._leave(null, r)
            } else {
                if (this.getTipElement().classList.contains(la)) {
                    this._leave(null, this)
                    return
                }
                this._enter(null, this)
            }
    }
    dispose() {
        clearTimeout(this._timeout),
            ae.off(this._element.closest(Qg), em, this._hideModalHandler),
            this.tip && this.tip.remove(),
            this._disposePopper(),
            super.dispose()
    }
    show() {
        if (this._element.style.display === "none") throw new Error("Please use show on visible elements")
        if (!(this.isWithContent() && this._isEnabled)) return
        const e = ae.trigger(this._element, this.constructor.Event.SHOW),
            r = mv(this._element),
            n = r === null ? this._element.ownerDocument.documentElement.contains(this._element) : r.contains(this._element)
        if (e.defaultPrevented || !n) return
        this.constructor.NAME === "tooltip" &&
            this.tip &&
            this.getTitle() !== this.tip.querySelector(Zg).innerHTML &&
            (this._disposePopper(), this.tip.remove(), (this.tip = null))
        const i = this.getTipElement(),
            s = y7(this.constructor.NAME)
        i.setAttribute("id", s), this._element.setAttribute("aria-describedby", s), this._config.animation && i.classList.add(jl)
        const o = typeof this._config.placement == "function" ? this._config.placement.call(this, i, this._element) : this._config.placement,
            a = this._getAttachment(o)
        this._addAttachmentClass(a)
        const { container: l } = this._config
        Oa.set(i, this.constructor.DATA_KEY, this),
            this._element.ownerDocument.documentElement.contains(this.tip) ||
                (l.append(i), ae.trigger(this._element, this.constructor.Event.INSERTED)),
            this._popper ? this._popper.update() : (this._popper = rh(this._element, i, this._getPopperConfig(a))),
            i.classList.add(la)
        const c = this._resolvePossibleFunction(this._config.customClass)
        c && i.classList.add(...c.split(" ")),
            "ontouchstart" in document.documentElement &&
                [].concat(...document.body.children).forEach((p) => {
                    ae.on(p, "mouseover", Pc)
                })
        const f = () => {
                const p = this._hoverState
                ;(this._hoverState = null), ae.trigger(this._element, this.constructor.Event.SHOWN), p === Au && this._leave(null, this)
            },
            u = this.tip.classList.contains(jl)
        this._queueCallback(f, this.tip, u)
    }
    hide() {
        if (!this._popper) return
        const e = this.getTipElement(),
            r = () => {
                this._isWithActiveTrigger() ||
                    (this._hoverState !== ca && e.remove(),
                    this._cleanTipClass(),
                    this._element.removeAttribute("aria-describedby"),
                    ae.trigger(this._element, this.constructor.Event.HIDDEN),
                    this._disposePopper())
            }
        if (ae.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return
        e.classList.remove(la),
            "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((s) => ae.off(s, "mouseover", Pc)),
            (this._activeTrigger[tA] = !1),
            (this._activeTrigger[Tu] = !1),
            (this._activeTrigger[fa] = !1)
        const i = this.tip.classList.contains(jl)
        this._queueCallback(r, this.tip, i), (this._hoverState = "")
    }
    update() {
        this._popper !== null && this._popper.update()
    }
    isWithContent() {
        return Boolean(this.getTitle())
    }
    getTipElement() {
        if (this.tip) return this.tip
        const e = document.createElement("div")
        e.innerHTML = this._config.template
        const r = e.children[0]
        return this.setContent(r), r.classList.remove(jl, la), (this.tip = r), this.tip
    }
    setContent(e) {
        this._sanitizeAndSetContent(e, this.getTitle(), Zg)
    }
    _sanitizeAndSetContent(e, r, n) {
        const i = Pe.findOne(n, e)
        if (!r && i) {
            i.remove()
            return
        }
        this.setElementContent(i, r)
    }
    setElementContent(e, r) {
        if (e !== null) {
            if (Ds(r)) {
                ;(r = Gi(r)), this._config.html ? r.parentNode !== e && ((e.innerHTML = ""), e.append(r)) : (e.textContent = r.textContent)
                return
            }
            this._config.html
                ? (this._config.sanitize && (r = Xg(r, this._config.allowList, this._config.sanitizeFn)), (e.innerHTML = r))
                : (e.textContent = r)
        }
    }
    getTitle() {
        const e = this._element.getAttribute("data-bs-original-title") || this._config.title
        return this._resolvePossibleFunction(e)
    }
    updateAttachment(e) {
        return e === "right" ? "end" : e === "left" ? "start" : e
    }
    _initializeOnDelegatedTarget(e, r) {
        return r || this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig())
    }
    _getOffset() {
        const { offset: e } = this._config
        return typeof e == "string" ? e.split(",").map((r) => Number.parseInt(r, 10)) : typeof e == "function" ? (r) => e(r, this._element) : e
    }
    _resolvePossibleFunction(e) {
        return typeof e == "function" ? e.call(this._element) : e
    }
    _getPopperConfig(e) {
        const r = {
            placement: e,
            modifiers: [
                { name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } },
                { name: "offset", options: { offset: this._getOffset() } },
                { name: "preventOverflow", options: { boundary: this._config.boundary } },
                { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } },
                { name: "onChange", enabled: !0, phase: "afterWrite", fn: (n) => this._handlePopperPlacementChange(n) },
            ],
            onFirstUpdate: (n) => {
                n.options.placement !== n.placement && this._handlePopperPlacementChange(n)
            },
        }
        return Fe(Fe({}, r), typeof this._config.popperConfig == "function" ? this._config.popperConfig(r) : this._config.popperConfig)
    }
    _addAttachmentClass(e) {
        this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(e)}`)
    }
    _getAttachment(e) {
        return Y9[e.toUpperCase()]
    }
    _setListeners() {
        this._config.trigger.split(" ").forEach((r) => {
            if (r === "click") ae.on(this._element, this.constructor.Event.CLICK, this._config.selector, (n) => this.toggle(n))
            else if (r !== rA) {
                const n = r === fa ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN,
                    i = r === fa ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT
                ae.on(this._element, n, this._config.selector, (s) => this._enter(s)),
                    ae.on(this._element, i, this._config.selector, (s) => this._leave(s))
            }
        }),
            (this._hideModalHandler = () => {
                this._element && this.hide()
            }),
            ae.on(this._element.closest(Qg), em, this._hideModalHandler),
            this._config.selector ? (this._config = El(Fe({}, this._config), { trigger: "manual", selector: "" })) : this._fixTitle()
    }
    _fixTitle() {
        const e = this._element.getAttribute("title"),
            r = typeof this._element.getAttribute("data-bs-original-title")
        ;(e || r !== "string") &&
            (this._element.setAttribute("data-bs-original-title", e || ""),
            e && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", e),
            this._element.setAttribute("title", ""))
    }
    _enter(e, r) {
        if (
            ((r = this._initializeOnDelegatedTarget(e, r)),
            e && (r._activeTrigger[e.type === "focusin" ? Tu : fa] = !0),
            r.getTipElement().classList.contains(la) || r._hoverState === ca)
        ) {
            r._hoverState = ca
            return
        }
        if ((clearTimeout(r._timeout), (r._hoverState = ca), !r._config.delay || !r._config.delay.show)) {
            r.show()
            return
        }
        r._timeout = setTimeout(() => {
            r._hoverState === ca && r.show()
        }, r._config.delay.show)
    }
    _leave(e, r) {
        if (
            ((r = this._initializeOnDelegatedTarget(e, r)),
            e && (r._activeTrigger[e.type === "focusout" ? Tu : fa] = r._element.contains(e.relatedTarget)),
            !r._isWithActiveTrigger())
        ) {
            if ((clearTimeout(r._timeout), (r._hoverState = Au), !r._config.delay || !r._config.delay.hide)) {
                r.hide()
                return
            }
            r._timeout = setTimeout(() => {
                r._hoverState === Au && r.hide()
            }, r._config.delay.hide)
        }
    }
    _isWithActiveTrigger() {
        for (const e in this._activeTrigger) if (this._activeTrigger[e]) return !0
        return !1
    }
    _getConfig(e) {
        const r = ir.getDataAttributes(this._element)
        return (
            Object.keys(r).forEach((n) => {
                J9.has(n) && delete r[n]
            }),
            (e = Fe(Fe(Fe({}, this.constructor.Default), r), typeof e == "object" && e ? e : {})),
            (e.container = e.container === !1 ? document.body : Gi(e.container)),
            typeof e.delay == "number" && (e.delay = { show: e.delay, hide: e.delay }),
            typeof e.title == "number" && (e.title = e.title.toString()),
            typeof e.content == "number" && (e.content = e.content.toString()),
            zn(Yg, e, this.constructor.DefaultType),
            e.sanitize && (e.template = Xg(e.template, e.allowList, e.sanitizeFn)),
            e
        )
    }
    _getDelegateConfig() {
        const e = {}
        for (const r in this._config) this.constructor.Default[r] !== this._config[r] && (e[r] = this._config[r])
        return e
    }
    _cleanTipClass() {
        const e = this.getTipElement(),
            r = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"),
            n = e.getAttribute("class").match(r)
        n !== null && n.length > 0 && n.map((i) => i.trim()).forEach((i) => e.classList.remove(i))
    }
    _getBasicClassPrefix() {
        return W9
    }
    _handlePopperPlacementChange(e) {
        const { state: r } = e
        !r || ((this.tip = r.elements.popper), this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(r.placement)))
    }
    _disposePopper() {
        this._popper && (this._popper.destroy(), (this._popper = null))
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = ti.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof r[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                r[e]()
            }
        })
    }
}
Xr(ti)
const nA = "popover",
    iA = "bs.popover",
    pn = `.${iA}`,
    sA = "bs-popover",
    oA = El(Fe({}, ti.Default), {
        placement: "right",
        offset: [0, 8],
        trigger: "click",
        content: "",
        template:
            '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    }),
    aA = El(Fe({}, ti.DefaultType), { content: "(string|element|function)" }),
    lA = {
        HIDE: `hide${pn}`,
        HIDDEN: `hidden${pn}`,
        SHOW: `show${pn}`,
        SHOWN: `shown${pn}`,
        INSERTED: `inserted${pn}`,
        CLICK: `click${pn}`,
        FOCUSIN: `focusin${pn}`,
        FOCUSOUT: `focusout${pn}`,
        MOUSEENTER: `mouseenter${pn}`,
        MOUSELEAVE: `mouseleave${pn}`,
    },
    cA = ".popover-header",
    fA = ".popover-body"
class Ro extends ti {
    static get Default() {
        return oA
    }
    static get NAME() {
        return nA
    }
    static get Event() {
        return lA
    }
    static get DefaultType() {
        return aA
    }
    isWithContent() {
        return this.getTitle() || this._getContent()
    }
    setContent(e) {
        this._sanitizeAndSetContent(e, this.getTitle(), cA), this._sanitizeAndSetContent(e, this._getContent(), fA)
    }
    _getContent() {
        return this._resolvePossibleFunction(this._config.content)
    }
    _getBasicClassPrefix() {
        return sA
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = Ro.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof r[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                r[e]()
            }
        })
    }
}
Xr(Ro)
const tm = "scrollspy",
    uA = "bs.scrollspy",
    mf = `.${uA}`,
    dA = ".data-api",
    rm = { offset: 10, method: "auto", target: "" },
    hA = { offset: "number", method: "string", target: "(string|element)" },
    pA = `activate${mf}`,
    gA = `scroll${mf}`,
    mA = `load${mf}${dA}`,
    Fv = "dropdown-item",
    Qs = "active",
    bA = '[data-bs-spy="scroll"]',
    xA = ".nav, .list-group",
    Cd = ".nav-link",
    vA = ".nav-item",
    Vv = ".list-group-item",
    Cu = `${Cd}, ${Vv}, .${Fv}`,
    yA = ".dropdown",
    _A = ".dropdown-toggle",
    wA = "offset",
    nm = "position"
class bf extends cn {
    constructor(e, r) {
        super(e)
        ;(this._scrollElement = this._element.tagName === "BODY" ? window : this._element),
            (this._config = this._getConfig(r)),
            (this._offsets = []),
            (this._targets = []),
            (this._activeTarget = null),
            (this._scrollHeight = 0),
            ae.on(this._scrollElement, gA, () => this._process()),
            this.refresh(),
            this._process()
    }
    static get Default() {
        return rm
    }
    static get NAME() {
        return tm
    }
    refresh() {
        const e = this._scrollElement === this._scrollElement.window ? wA : nm,
            r = this._config.method === "auto" ? e : this._config.method,
            n = r === nm ? this._getScrollTop() : 0
        ;(this._offsets = []),
            (this._targets = []),
            (this._scrollHeight = this._getScrollHeight()),
            Pe.find(Cu, this._config.target)
                .map((s) => {
                    const o = nh(s),
                        a = o ? Pe.findOne(o) : null
                    if (a) {
                        const l = a.getBoundingClientRect()
                        if (l.width || l.height) return [ir[r](a).top + n, o]
                    }
                    return null
                })
                .filter((s) => s)
                .sort((s, o) => s[0] - o[0])
                .forEach((s) => {
                    this._offsets.push(s[0]), this._targets.push(s[1])
                })
    }
    dispose() {
        ae.off(this._scrollElement, mf), super.dispose()
    }
    _getConfig(e) {
        return (
            (e = Fe(Fe(Fe({}, rm), ir.getDataAttributes(this._element)), typeof e == "object" && e ? e : {})),
            (e.target = Gi(e.target) || document.documentElement),
            zn(tm, e, hA),
            e
        )
    }
    _getScrollTop() {
        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
    }
    _getScrollHeight() {
        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
    }
    _getOffsetHeight() {
        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
    }
    _process() {
        const e = this._getScrollTop() + this._config.offset,
            r = this._getScrollHeight(),
            n = this._config.offset + r - this._getOffsetHeight()
        if ((this._scrollHeight !== r && this.refresh(), e >= n)) {
            const i = this._targets[this._targets.length - 1]
            this._activeTarget !== i && this._activate(i)
            return
        }
        if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) {
            ;(this._activeTarget = null), this._clear()
            return
        }
        for (let i = this._offsets.length; i--; )
            this._activeTarget !== this._targets[i] &&
                e >= this._offsets[i] &&
                (typeof this._offsets[i + 1] == "undefined" || e < this._offsets[i + 1]) &&
                this._activate(this._targets[i])
    }
    _activate(e) {
        ;(this._activeTarget = e), this._clear()
        const r = Cu.split(",").map((i) => `${i}[data-bs-target="${e}"],${i}[href="${e}"]`),
            n = Pe.findOne(r.join(","), this._config.target)
        n.classList.add(Qs),
            n.classList.contains(Fv)
                ? Pe.findOne(_A, n.closest(yA)).classList.add(Qs)
                : Pe.parents(n, xA).forEach((i) => {
                      Pe.prev(i, `${Cd}, ${Vv}`).forEach((s) => s.classList.add(Qs)),
                          Pe.prev(i, vA).forEach((s) => {
                              Pe.children(s, Cd).forEach((o) => o.classList.add(Qs))
                          })
                  }),
            ae.trigger(this._scrollElement, pA, { relatedTarget: e })
    }
    _clear() {
        Pe.find(Cu, this._config.target)
            .filter((e) => e.classList.contains(Qs))
            .forEach((e) => e.classList.remove(Qs))
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = bf.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof r[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                r[e]()
            }
        })
    }
}
ae.on(window, mA, () => {
    Pe.find(bA).forEach((t) => new bf(t))
})
Xr(bf)
const EA = "tab",
    SA = "bs.tab",
    xl = `.${SA}`,
    AA = ".data-api",
    TA = `hide${xl}`,
    CA = `hidden${xl}`,
    kA = `show${xl}`,
    NA = `shown${xl}`,
    PA = `click${xl}${AA}`,
    IA = "dropdown-menu",
    ua = "active",
    im = "fade",
    sm = "show",
    $A = ".dropdown",
    BA = ".nav, .list-group",
    om = ".active",
    am = ":scope > li > .active",
    OA = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    MA = ".dropdown-toggle",
    RA = ":scope > .dropdown-menu .active"
class xf extends cn {
    static get NAME() {
        return EA
    }
    show() {
        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(ua)) return
        let e
        const r = Ki(this._element),
            n = this._element.closest(BA)
        if (n) {
            const a = n.nodeName === "UL" || n.nodeName === "OL" ? am : om
            ;(e = Pe.find(a, n)), (e = e[e.length - 1])
        }
        const i = e ? ae.trigger(e, TA, { relatedTarget: this._element }) : null
        if (ae.trigger(this._element, kA, { relatedTarget: e }).defaultPrevented || (i !== null && i.defaultPrevented)) return
        this._activate(this._element, n)
        const o = () => {
            ae.trigger(e, CA, { relatedTarget: this._element }), ae.trigger(this._element, NA, { relatedTarget: e })
        }
        r ? this._activate(r, r.parentNode, o) : o()
    }
    _activate(e, r, n) {
        const s = (r && (r.nodeName === "UL" || r.nodeName === "OL") ? Pe.find(am, r) : Pe.children(r, om))[0],
            o = n && s && s.classList.contains(im),
            a = () => this._transitionComplete(e, s, n)
        s && o ? (s.classList.remove(sm), this._queueCallback(a, e, !0)) : a()
    }
    _transitionComplete(e, r, n) {
        if (r) {
            r.classList.remove(ua)
            const s = Pe.findOne(RA, r.parentNode)
            s && s.classList.remove(ua), r.getAttribute("role") === "tab" && r.setAttribute("aria-selected", !1)
        }
        e.classList.add(ua),
            e.getAttribute("role") === "tab" && e.setAttribute("aria-selected", !0),
            Wo(e),
            e.classList.contains(im) && e.classList.add(sm)
        let i = e.parentNode
        if ((i && i.nodeName === "LI" && (i = i.parentNode), i && i.classList.contains(IA))) {
            const s = e.closest($A)
            s && Pe.find(MA, s).forEach((o) => o.classList.add(ua)), e.setAttribute("aria-expanded", !0)
        }
        n && n()
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = xf.getOrCreateInstance(this)
            if (typeof e == "string") {
                if (typeof r[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                r[e]()
            }
        })
    }
}
ae.on(document, PA, OA, function (t) {
    if ((["A", "AREA"].includes(this.tagName) && t.preventDefault(), Is(this))) return
    xf.getOrCreateInstance(this).show()
})
Xr(xf)
const lm = "toast",
    LA = "bs.toast",
    ts = `.${LA}`,
    DA = `mouseover${ts}`,
    FA = `mouseout${ts}`,
    VA = `focusin${ts}`,
    UA = `focusout${ts}`,
    HA = `hide${ts}`,
    qA = `hidden${ts}`,
    jA = `show${ts}`,
    zA = `shown${ts}`,
    KA = "fade",
    cm = "hide",
    da = "show",
    zl = "showing",
    GA = { animation: "boolean", autohide: "boolean", delay: "number" },
    fm = { animation: !0, autohide: !0, delay: 5e3 }
class vf extends cn {
    constructor(e, r) {
        super(e)
        ;(this._config = this._getConfig(r)),
            (this._timeout = null),
            (this._hasMouseInteraction = !1),
            (this._hasKeyboardInteraction = !1),
            this._setListeners()
    }
    static get DefaultType() {
        return GA
    }
    static get Default() {
        return fm
    }
    static get NAME() {
        return lm
    }
    show() {
        if (ae.trigger(this._element, jA).defaultPrevented) return
        this._clearTimeout(), this._config.animation && this._element.classList.add(KA)
        const r = () => {
            this._element.classList.remove(zl), ae.trigger(this._element, zA), this._maybeScheduleHide()
        }
        this._element.classList.remove(cm),
            Wo(this._element),
            this._element.classList.add(da),
            this._element.classList.add(zl),
            this._queueCallback(r, this._element, this._config.animation)
    }
    hide() {
        if (!this._element.classList.contains(da) || ae.trigger(this._element, HA).defaultPrevented) return
        const r = () => {
            this._element.classList.add(cm),
                this._element.classList.remove(zl),
                this._element.classList.remove(da),
                ae.trigger(this._element, qA)
        }
        this._element.classList.add(zl), this._queueCallback(r, this._element, this._config.animation)
    }
    dispose() {
        this._clearTimeout(), this._element.classList.contains(da) && this._element.classList.remove(da), super.dispose()
    }
    _getConfig(e) {
        return (
            (e = Fe(Fe(Fe({}, fm), ir.getDataAttributes(this._element)), typeof e == "object" && e ? e : {})),
            zn(lm, e, this.constructor.DefaultType),
            e
        )
    }
    _maybeScheduleHide() {
        !this._config.autohide ||
            this._hasMouseInteraction ||
            this._hasKeyboardInteraction ||
            (this._timeout = setTimeout(() => {
                this.hide()
            }, this._config.delay))
    }
    _onInteraction(e, r) {
        switch (e.type) {
            case "mouseover":
            case "mouseout":
                this._hasMouseInteraction = r
                break
            case "focusin":
            case "focusout":
                this._hasKeyboardInteraction = r
                break
        }
        if (r) {
            this._clearTimeout()
            return
        }
        const n = e.relatedTarget
        this._element === n || this._element.contains(n) || this._maybeScheduleHide()
    }
    _setListeners() {
        ae.on(this._element, DA, (e) => this._onInteraction(e, !0)),
            ae.on(this._element, FA, (e) => this._onInteraction(e, !1)),
            ae.on(this._element, VA, (e) => this._onInteraction(e, !0)),
            ae.on(this._element, UA, (e) => this._onInteraction(e, !1))
    }
    _clearTimeout() {
        clearTimeout(this._timeout), (this._timeout = null)
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const r = vf.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof r[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                r[e](this)
            }
        })
    }
}
pf(vf)
Xr(vf)
var WA = Object.defineProperty,
    JA = Object.defineProperties,
    XA = Object.getOwnPropertyDescriptors,
    um = Object.getOwnPropertySymbols,
    YA = Object.prototype.hasOwnProperty,
    ZA = Object.prototype.propertyIsEnumerable,
    dm = (t, e, r) => (e in t ? WA(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (t[e] = r)),
    Me = (t, e) => {
        for (var r in e || (e = {})) YA.call(e, r) && dm(t, r, e[r])
        if (um) for (var r of um(e)) ZA.call(e, r) && dm(t, r, e[r])
        return t
    },
    Rt = (t, e) => JA(t, XA(e))
function ei(t = "") {
    return `__BVID__${Math.random().toString().substr(2, 6)}___BV_${t}__`
}
function gr(t, e) {
    return H(() => t || ei(e))
}
var xe = (t, e) => {
    const r = t.__vccOpts || t
    for (const [n, i] of e) r[n] = i
    return r
}
const Uv = Symbol(),
    QA = be({
        name: "BAccordion",
        props: { flush: { type: Boolean, default: !1 }, free: { type: Boolean, default: !1 }, id: { type: String, default: void 0 } },
        setup(t) {
            const e = gr(t.id, "accordion"),
                r = H(() => ({ "accordion-flush": t.flush }))
            return t.free || Nn(Uv, `${e.value}`), { computedId: e, classes: r }
        },
    }),
    eT = ["id"]
function tT(t, e, r, n, i, s) {
    return K(), ue("div", { id: t.computedId, class: ye(["accordion", t.classes]) }, [ge(t.$slots, "default")], 10, eT)
}
var rT = xe(QA, [["render", tT]])
function Bt(t, e, r) {
    Zt(() => {
        var n
        ;(n = t == null ? void 0 : t.value) == null || n.addEventListener(e, r)
    }),
        qc(() => {
            var n
            ;(n = t == null ? void 0 : t.value) == null || n.removeEventListener(e, r)
        })
}
const nT = be({
    name: "BCollapse",
    props: {
        accordion: { type: String, required: !1 },
        id: { type: String, default: ei() },
        modelValue: { type: Boolean, default: !1 },
        tag: { type: String, default: "div" },
        toggle: { type: Boolean, default: !1 },
        visible: { type: Boolean, default: !1 },
    },
    emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
    setup(t, { emit: e }) {
        const r = Ue(),
            n = Ue(),
            i = H(() => ({ show: t.modelValue })),
            s = () => e("update:modelValue", !1)
        return (
            Bt(r, "show.bs.collapse", () => {
                e("show"), e("update:modelValue", !0)
            }),
            Bt(r, "hide.bs.collapse", () => {
                e("hide"), e("update:modelValue", !1)
            }),
            Bt(r, "shown.bs.collapse", () => e("shown")),
            Bt(r, "hidden.bs.collapse", () => e("hidden")),
            Zt(() => {
                var o
                ;(n.value = new $s(r.value, { parent: t.accordion ? `#${t.accordion}` : void 0, toggle: t.toggle })),
                    (t.visible || t.modelValue) && (e("update:modelValue", !0), (o = n.value) == null || o.show())
            }),
            It(
                () => t.modelValue,
                (o) => {
                    var a, l
                    o ? (a = n.value) == null || a.show() : (l = n.value) == null || l.hide()
                }
            ),
            It(
                () => t.visible,
                (o) => {
                    var a, l
                    o
                        ? (e("update:modelValue", !!o), (a = n.value) == null || a.show())
                        : (e("update:modelValue", !!o), (l = n.value) == null || l.hide())
                }
            ),
            { element: r, classes: i, close: s }
        )
    },
})
function iT(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tag),
            { id: t.id, ref: "element", class: ye(["collapse", t.classes]), "data-bs-parent": t.accordion || null },
            { default: Te(() => [ge(t.$slots, "default", { visible: t.modelValue, close: t.close })]), _: 3 },
            8,
            ["id", "class", "data-bs-parent"]
        )
    )
}
var Hv = xe(nT, [["render", iT]])
const sT = /_/g,
    oT = /([a-z])([A-Z])/g,
    aT = /(\s|^)(\w)/,
    cc = /\s+/,
    lT = /^#/,
    cT = /^#[A-Za-z]+[\w\-:.]*$/,
    fT = (t, e) => t.indexOf(e) !== -1,
    uT = (...t) => Array.from(...t),
    dT = (...t) => Array.prototype.concat.apply([], t),
    Jo = typeof window != "undefined",
    qv = typeof document != "undefined",
    hT = typeof navigator != "undefined",
    pT = Jo && qv && hT,
    Qn = Jo ? window : {},
    jv = qv ? document : {},
    zv = Jo ? Qn.Element : class extends Object {},
    gT = Jo ? Qn.HTMLElement : class extends zv {}
Jo ? Qn.SVGElement : class extends zv {}
Jo ? Qn.File : class extends Object {}
const mT = /^[0-9]*\.?[0-9]+$/,
    ku = (t) => Wv(t) === "boolean",
    bT = (t) => t !== null && typeof t == "object",
    Lo = (t) => typeof t == "string",
    xT = (t) => t === void 0,
    vT = (t) => t === null,
    Kv = (t) => xT(t) || vT(t),
    Gv = (t) => mT.test(String(t)),
    yT = (t) => typeof t == "number",
    Wv = (t) => typeof t,
    Jv = (t) => Wv(t) === "function",
    Xv = (t) => Object.prototype.toString.call(t) === "[object Object]",
    Yv = (t) => Array.isArray(t),
    kd = (t, e = 2) => (Kv(t) ? "" : Yv(t) || (Xv(t) && t.toString === Object.prototype.toString) ? JSON.stringify(t, null, e) : String(t)),
    hm = (t) =>
        t
            .replace(sT, " ")
            .replace(oT, (e, r, n) => `${r} ${n}`)
            .replace(aT, (e, r, n) => r + n.toUpperCase()),
    _T = (t) => ((t = Lo(t) ? t.trim() : String(t)), t.charAt(0).toUpperCase() + t.slice(1)),
    rs = (t) => !!(t && t.nodeType === Node.ELEMENT_NODE),
    wT = (t) => (rs(t) ? t.getBoundingClientRect() : null),
    ET = (t = []) => {
        const { activeElement: e } = document
        return e && !t.some((r) => r === e) ? e : null
    },
    ST = (t) => rs(t) && t === ET(),
    AT = (t, e = {}) => {
        try {
            t.focus(e)
        } catch (r) {
            console.error(r)
        }
        return ST(t)
    },
    TT = (t, e) => (e && rs(t) && t.getAttribute(e)) || null,
    CT = (t) => {
        if (TT(t, "display") === "none") return !1
        const e = wT(t)
        return !!(e && e.height > 0 && e.width > 0)
    },
    pm = (t, e) => !t || t(e).filter((r) => r.type !== Tr).length < 1,
    kT = (t, e) => (rs(e) ? e : jv).querySelector(t) || null,
    NT = (t, e) => uT((rs(e) ? e : jv).querySelectorAll(t)),
    Zv = (t, e) => (e && rs(t) ? t.getAttribute(e) : null),
    PT = (t, e, r) => {
        e && rs(t) && t.setAttribute(e, r)
    },
    IT = (t, e) => {
        e && rs(t) && t.removeAttribute(e)
    },
    $T = (t, e) => kd(t).toLowerCase() === kd(e).toLowerCase(),
    Kl =
        Qn.requestAnimationFrame ||
        Qn.webkitRequestAnimationFrame ||
        Qn.mozRequestAnimationFrame ||
        Qn.msRequestAnimationFrame ||
        Qn.oRequestAnimationFrame ||
        ((t) => setTimeout(t, 16))
function BT(t) {
    if (t.classList.contains("offcanvas")) return "offcanvas"
    if (t.classList.contains("collapse")) return "collapse"
    throw Error("Couldn't resolve toggle type")
}
const OT = (t, e) => {
        const { modifiers: r, arg: n, value: i } = t,
            s = Object.keys(r || {}),
            o = Lo(i) ? i.split(cc) : i
        if ($T(e.tagName, "a")) {
            const a = Zv(e, "href") || ""
            cT.test(a) && s.push(a.replace(lT, ""))
        }
        return dT(n, o).forEach((a) => Lo(a) && s.push(a)), s.filter((a, l, c) => a && c.indexOf(a) === l)
    },
    Qv = {
        mounted(t, e) {
            const r = OT(e, t),
                n = []
            let i = "data-bs-target"
            t.tagName === "a" && (i = "href")
            for (let s = 0; s < r.length; s++) {
                const o = r[s],
                    a = document.getElementById(o)
                a && (t.setAttribute("data-bs-toggle", BT(a)), n.push(`#${o}`))
            }
            n.length > 0 && t.setAttribute(i, n.join(","))
        },
    },
    MT = be({
        name: "BAccordionItem",
        components: { BCollapse: Hv },
        directives: { BToggle: Qv },
        props: { title: { type: String }, id: { type: String }, visible: { type: Boolean, default: !1 } },
        setup(t) {
            const e = gr(t.id, "accordion_item")
            return { parent: sr(Uv, ""), computedId: e }
        },
    }),
    RT = { class: "accordion-item" },
    LT = ["id"],
    DT = ["aria-expanded", "aria-controls"],
    FT = { class: "accordion-body" }
function VT(t, e, r, n, i, s) {
    const o = Qt("b-collapse"),
        a = j_("b-toggle")
    return (
        K(),
        ue("div", RT, [
            He(
                "h2",
                { id: `${t.computedId}heading`, class: "accordion-header" },
                [
                    B_(
                        (K(),
                        ue(
                            "button",
                            {
                                class: ye(["accordion-button", { collapsed: !t.visible }]),
                                type: "button",
                                "aria-expanded": t.visible ? "true" : "false",
                                "aria-controls": t.computedId,
                            },
                            [ge(t.$slots, "title", {}, () => [Ut(tt(t.title), 1)])],
                            10,
                            DT
                        )),
                        [[a, void 0, t.computedId]]
                    ),
                ],
                8,
                LT
            ),
            jt(
                o,
                {
                    id: t.computedId,
                    class: "accordion-collapse",
                    visible: t.visible,
                    accordion: t.parent,
                    "aria-labelledby": `heading${t.computedId}`,
                },
                { default: Te(() => [He("div", FT, [ge(t.$slots, "default")])]), _: 3 },
                8,
                ["id", "visible", "accordion", "aria-labelledby"]
            ),
        ])
    )
}
var UT = xe(MT, [["render", VT]])
const Do = (t, e = NaN) => (Number.isInteger(t) ? t : e),
    HT = (t, e = NaN) => {
        const r = parseInt(t, 10)
        return isNaN(r) ? e : r
    },
    sh = (t, e = NaN) => {
        const r = parseFloat(t.toString())
        return isNaN(r) ? e : r
    },
    qT = be({
        name: "BAlert",
        props: {
            dismissLabel: { type: String, default: "Close" },
            dismissible: { type: Boolean, default: !1 },
            fade: { type: Boolean, default: !1 },
            modelValue: { type: [Boolean, Number], default: !1 },
            show: { type: Boolean, default: !1 },
            variant: { type: String, default: "info" },
        },
        emits: ["dismissed", "dismiss-count-down", "update:modelValue"],
        setup(t, { emit: e }) {
            const r = Ue(),
                n = Ue(),
                i = H(() => ({ [`alert-${t.variant}`]: t.variant, show: t.modelValue, "alert-dismissible": t.dismissible, fade: t.modelValue }))
            let s = 0
            const o = (m) => {
                    if (typeof m == "boolean") return 0
                    const y = Do(m, 0)
                    return y > 0 ? y : 0
                },
                a = () => {
                    s !== void 0 && (clearTimeout(s), (s = void 0))
                },
                l = Ue(o(t.modelValue)),
                c = H(() => t.modelValue || t.show)
            qc(() => {
                var m
                a(), (m = n.value) == null || m.dispose(), (n.value = void 0)
            })
            const f = H(() => (t.modelValue === !0 ? !0 : t.modelValue === !1 || Do(t.modelValue, 0) < 1 ? !1 : !!t.modelValue)),
                u = () => {
                    ;(l.value = o(t.modelValue)), (f.value || t.show) && !n.value && (n.value = new ml(r.value))
                },
                p = () => {
                    typeof t.modelValue == "boolean" ? e("update:modelValue", !1) : e("update:modelValue", 0), e("dismissed")
                }
            return (
                It(() => t.modelValue, u),
                It(() => t.show, u),
                It(l, (m) => {
                    a(),
                        typeof t.modelValue != "boolean" &&
                            (e("dismiss-count-down", m),
                            m === 0 && t.modelValue > 0 && e("dismissed"),
                            t.modelValue !== m && e("update:modelValue", m),
                            m > 0 &&
                                (s = setTimeout(() => {
                                    l.value--
                                }, 1e3)))
                }),
                { dismissClicked: p, isAlertVisible: c, element: r, classes: i }
            )
        },
    }),
    jT = ["aria-label"]
function zT(t, e, r, n, i, s) {
    return t.isAlertVisible
        ? (K(),
          ue(
              "div",
              { key: 0, ref: "element", class: ye(["alert", t.classes]), role: "alert" },
              [
                  ge(t.$slots, "default"),
                  t.dismissible
                      ? (K(),
                        ue(
                            "button",
                            {
                                key: 0,
                                type: "button",
                                class: "btn-close",
                                "data-bs-dismiss": "alert",
                                "aria-label": t.dismissLabel,
                                onClick: e[0] || (e[0] = (...o) => t.dismissClicked && t.dismissClicked(...o)),
                            },
                            null,
                            8,
                            jT
                        ))
                      : Be("", !0),
              ],
              2
          ))
        : Be("", !0)
}
var KT = xe(qT, [["render", zT]])
const GT = Math.min,
    Nd = Math.max,
    ey = Symbol(),
    WT = be({
        name: "BAvatar",
        props: {
            overlap: { type: [Number, String], default: 0.3 },
            rounded: { type: [Boolean, String], default: !1 },
            size: { type: String, required: !1 },
            square: { type: Boolean, default: !1 },
            tag: { type: String, default: "div" },
            variant: { type: String, required: !1 },
        },
        setup(t) {
            const e = H(() => Pd(t.size)),
                r = (s) => (Lo(s) && Gv(s) ? sh(s, 0) : s || 0),
                n = H(() => GT(Nd(r(t.overlap), 0), 1) / 2),
                i = H(() => {
                    let { value: s } = e
                    return (s = s ? `calc(${s} * ${n.value})` : null), s ? { paddingLeft: s, paddingRight: s } : {}
                })
            return Nn(ey, { overlapScale: n, size: t.size, square: t.square, rounded: t.rounded, variant: t.variant }), { paddingStyle: i }
        },
    })
function JT(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tag),
            { class: "b-avatar-group", role: "group" },
            { default: Te(() => [He("div", { class: "b-avatar-group-inner", style: ni(t.paddingStyle) }, [ge(t.$slots, "default")], 4)]), _: 3 }
        )
    )
}
var XT = xe(WT, [["render", JT]])
const Pd = (t) => {
        const e = Lo(t) && Gv(t) ? sh(t, 0) : t
        return yT(e) ? `${e}px` : e || null
    },
    YT = be({
        name: "BAvatar",
        props: {
            alt: { type: String, default: "avatar" },
            ariaLabel: { type: String, required: !1 },
            badge: { type: [Boolean, String], default: !1 },
            badgeLeft: { type: Boolean, default: !1 },
            badgeOffset: { type: String, required: !1 },
            badgeTop: { type: Boolean, default: !1 },
            badgeVariant: { type: String, default: "primary" },
            button: { type: Boolean, default: !1 },
            buttonType: { type: String, default: "button" },
            disabled: { type: Boolean, default: !1 },
            icon: { type: String, required: !1 },
            rounded: { type: [Boolean, String], default: "circle" },
            size: { type: [String, Number], required: !1 },
            square: { type: Boolean, default: !1 },
            src: { type: String, required: !1 },
            text: { type: String, required: !1 },
            textVariant: { type: String, default: void 0 },
            variant: { type: String, default: "secondary" },
        },
        emits: ["click", "img-error"],
        setup(t, { emit: e, slots: r }) {
            const n = ["sm", null, "lg"],
                i = 0.4,
                s = i * 0.7,
                o = sr(ey, null),
                a = (d) => {
                    const b = d
                    return b === "light" || b === "warning" ? "dark" : "light"
                },
                l = H(() => !pm(r.default)),
                c = H(() => !pm(r.badge)),
                f = H(() => t.badge || t.badge === "" || c.value),
                u = H(() => ((o == null ? void 0 : o.size) ? o.size : Pd(t.size))),
                p = H(() => ((o == null ? void 0 : o.variant) ? o.variant : t.variant)),
                m = H(() => ((o == null ? void 0 : o.rounded) ? o.rounded : t.rounded)),
                y = H(() => ({ "aria-label": t.ariaLabel || null, disabled: t.disabled || null })),
                v = H(() => ({ [`bg-${t.badgeVariant}`]: t.badgeVariant })),
                _ = H(() => (t.badge === !0 ? "" : t.badge)),
                C = H(() => `text-${a(t.badgeVariant)}`),
                B = H(() => ({
                    [`b-avatar-${t.size}`]: t.size && n.indexOf(Pd(t.size)) !== -1,
                    [`bg-${p.value}`]: p.value,
                    badge: !t.button && p.value && l.value,
                    rounded: m.value === "" || m.value === !0,
                    ["rounded-circle"]: !t.square && m.value === "circle",
                    ["rounded-0"]: t.square || m.value === "0",
                    ["rounded-1"]: !t.square && m.value === "sm",
                    ["rounded-3"]: !t.square && m.value === "lg",
                    ["rounded-top"]: !t.square && m.value === "top",
                    ["rounded-bottom"]: !t.square && m.value === "bottom",
                    ["rounded-start"]: !t.square && m.value === "left",
                    ["rounded-end"]: !t.square && m.value === "right",
                    btn: t.button,
                    [`btn-${p.value}`]: t.button ? p.value : null,
                })),
                R = H(() => `text-${t.textVariant || a(p.value)}`),
                U = H(() => {
                    if (t.icon) return t.icon
                    if (!t.text && !t.src) return "person-fill"
                }),
                D = H(() => {
                    const d = t.badgeOffset || "0px"
                    return {
                        fontSize: (n.indexOf(u.value || null) === -1 ? `calc(${u.value} * ${s})` : "") || "",
                        top: t.badgeTop ? d : "",
                        bottom: t.badgeTop ? "" : d,
                        left: t.badgeLeft ? d : "",
                        right: t.badgeLeft ? "" : d,
                    }
                }),
                Y = H(() => {
                    const d = n.indexOf(u.value || null) === -1 ? `calc(${u.value} * ${i})` : null
                    return d ? { fontSize: d } : {}
                }),
                J = H(() => {
                    var d
                    const b = ((d = o == null ? void 0 : o.overlapScale) == null ? void 0 : d.value) || 0,
                        w = u.value && b ? `calc(${u.value} * -${b})` : null
                    return w ? { marginLeft: w, marginRight: w } : {}
                }),
                te = H(() => (t.button ? t.buttonType : "span")),
                G = H(() => Rt(Me({}, J.value), { width: u.value, height: u.value }))
            return {
                attrs: y,
                badgeClasses: v,
                badgeStyle: D,
                badgeText: _,
                badgeTextClasses: C,
                classes: B,
                clicked: function (d) {
                    !t.disabled && t.button && e("click", d)
                },
                fontStyle: Y,
                hasBadgeSlot: c,
                hasDefaultSlot: l,
                iconName: U,
                onImgError: (d) => e("img-error", d),
                showBadge: f,
                tag: te,
                tagStyle: G,
                textClasses: R,
            }
        },
    }),
    ZT = { key: 0, class: "b-avatar-custom" },
    QT = { key: 1, class: "b-avatar-img" },
    eC = ["src", "alt"]
function tC(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tag),
            Je({ class: ["b-avatar", t.classes], style: t.tagStyle }, t.attrs, { onClick: t.clicked }),
            {
                default: Te(() => [
                    t.hasDefaultSlot
                        ? (K(), ue("span", ZT, [ge(t.$slots, "default")]))
                        : t.src
                        ? (K(),
                          ue("span", QT, [
                              He(
                                  "img",
                                  { src: t.src, alt: t.alt, onError: e[0] || (e[0] = (...o) => t.onImgError && t.onImgError(...o)) },
                                  null,
                                  40,
                                  eC
                              ),
                          ]))
                        : t.text
                        ? (K(), ue("span", { key: 2, class: ye(["b-avatar-text", t.textClasses]), style: ni(t.fontStyle) }, tt(t.text), 7))
                        : Be("", !0),
                    t.showBadge
                        ? (K(),
                          ue(
                              "span",
                              { key: 3, class: ye(["b-avatar-badge", t.badgeClasses]), style: ni(t.badgeStyle) },
                              [
                                  t.hasBadgeSlot
                                      ? ge(t.$slots, "badge", { key: 0 })
                                      : (K(), ue("span", { key: 1, class: ye(t.badgeTextClasses) }, tt(t.badgeText), 3)),
                              ],
                              6
                          ))
                        : Be("", !0),
                ]),
                _: 3,
            },
            16,
            ["class", "style", "onClick"]
        )
    )
}
var rC = xe(YT, [["render", tC]])
const nC = (t, ...e) => Object.assign(t, ...e),
    iC = (t, e) => Object.defineProperties(t, e),
    sC = (t, e, r) => Object.defineProperty(t, e, r),
    ty = (t, e) =>
        Object.keys(t)
            .filter((r) => e.indexOf(r) === -1)
            .reduce((r, n) => Rt(Me({}, r), { [n]: t[n] }), {}),
    vs = () => ({ enumerable: !0, configurable: !1, writable: !1 }),
    vl = {
        active: { type: Boolean, default: !1 },
        activeClass: { type: String, default: "router-link-active" },
        append: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        event: { type: [String, Array], default: "click" },
        exact: { type: Boolean, default: !1 },
        exactActiveClass: { type: String, default: "router-link-exact-active" },
        href: { type: String },
        rel: { type: String, default: null },
        replace: { type: Boolean, default: !1 },
        routerComponentName: { type: String, default: "router-link" },
        routerTag: { type: String, default: "a" },
        target: { type: String, default: "_self" },
        to: { type: [String, Object], default: null },
    },
    oC = be({
        name: "BLink",
        props: vl,
        emits: ["click"],
        setup(t, { emit: e, attrs: r }) {
            const n = zc(),
                i = Ue(null),
                s = H(() => {
                    const u = t.routerComponentName
                        .split("-")
                        .map((m) => m.charAt(0).toUpperCase() + m.slice(1))
                        .join("")
                    return !((n == null ? void 0 : n.appContext.app.component(u)) !== void 0) || t.disabled || !t.to
                        ? "a"
                        : t.routerComponentName
                }),
                o = H(() => {
                    const u = "#"
                    if (t.href) return t.href
                    if (typeof t.to == "string") return t.to || u
                    const p = t.to
                    if (Object.prototype.toString.call(p) === "[object Object]" && (p.path || p.query || p.hash)) {
                        const m = p.path || "",
                            y = p.query
                                ? `?${Object.keys(p.query)
                                      .map((_) => `${_}=${p.query[_]}`)
                                      .join("=")}`
                                : "",
                            v = !p.hash || p.hash.charAt(0) === "#" ? p.hash || "" : `#${p.hash}`
                        return `${m}${y}${v}` || u
                    }
                    return u
                }),
                a = () => {
                    t.disabled || i.value.focus()
                },
                l = () => {
                    t.disabled || i.value.blur()
                },
                c = function (u) {
                    if (t.disabled) {
                        u.preventDefault(), u.stopImmediatePropagation()
                        return
                    }
                    e("click", u)
                },
                f = H(() => ({
                    to: t.to,
                    href: o.value,
                    target: t.target,
                    rel: t.target === "_blank" && t.rel === null ? "noopener" : t.rel || null,
                    tabindex: t.disabled ? "-1" : typeof r.tabindex == "undefined" ? null : r.tabindex,
                    "aria-disabled": t.disabled ? "true" : null,
                }))
            return { tag: s, routerAttr: f, link: i, focus: a, blur: l, clicked: c }
        },
    })
function aC(t, e, r, n, i, s) {
    return t.tag === "router-link"
        ? (K(),
          we(
              Ie(t.tag),
              Je({ key: 0 }, t.routerAttr, { custom: "" }),
              {
                  default: Te(({ href: o, navigate: a, isActive: l, isExactActive: c }) => [
                      (K(),
                      we(
                          Ie(t.routerTag),
                          Je({ ref: "link", href: o, class: [l && t.activeClass, c && t.exactActiveClass] }, t.$attrs, { onClick: a }),
                          { default: Te(() => [ge(t.$slots, "default")]), _: 2 },
                          1040,
                          ["href", "class", "onClick"]
                      )),
                  ]),
                  _: 3,
              },
              16
          ))
        : (K(),
          we(
              Ie(t.tag),
              Je({ key: 1, ref: "link", class: { active: t.active, disabled: t.disabled } }, t.routerAttr, { onClick: t.clicked }),
              { default: Te(() => [ge(t.$slots, "default")]), _: 3 },
              16,
              ["class", "onClick"]
          ))
}
var lC = xe(oC, [["render", aC]])
const Id = (t) => !!(t.href || t.to),
    gm = (t, e) => e + (t ? _T(t) : ""),
    cC = (t, e, r = (n) => n) => (Yv(t) ? t.slice() : Object.keys(t)).reduce((n, i) => ((n[r(i)] = e[i]), n), {}),
    mm = ty(vl, ["event", "routerTag"]),
    fC = be({
        name: "BBadge",
        props: Me(
            {
                pill: { type: Boolean, default: !1 },
                tag: { type: String, default: "span" },
                variant: { type: String, default: "secondary" },
                textIndicator: { type: Boolean, default: !1 },
                dotIndicator: { type: Boolean, default: !1 },
            },
            mm
        ),
        setup(t) {
            const e = H(() => Id(t)),
                r = H(() => (e.value ? "b-link" : t.tag))
            return {
                classes: H(() => ({
                    [`bg-${t.variant}`]: t.variant,
                    active: t.active,
                    disabled: t.disabled,
                    "text-dark": ["warning", "info", "light"].includes(t.variant),
                    "rounded-pill": t.pill,
                    "position-absolute top-0 start-100 translate-middle": t.textIndicator || t.dotIndicator,
                    "p-2 border border-light rounded-circle": t.dotIndicator,
                    "text-decoration-none": e,
                })),
                props: e.value ? cC(mm, t) : {},
                computedTag: r,
            }
        },
    })
function uC(t, e, r, n, i, s) {
    return (
        K(),
        we(Ie(t.computedTag), Je({ class: ["badge", t.classes] }, t.props), { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 16, [
            "class",
        ])
    )
}
var dC = xe(fC, [["render", uC]])
const ry = Symbol(),
    ny = {
        items: Ln([]),
        reset() {
            this.items = Ln([])
        },
    }
function hC(t) {
    t.provide(ry, ny)
}
function pC() {
    const t = sr(ry)
    return t || ny
}
const gC = be({
    name: "BBreadcrumbItem",
    props: Rt(Me({}, ty(vl, ["event", "routerTag"])), {
        active: { type: Boolean, default: !1 },
        ariaCurrent: { type: String, default: "location" },
        disabled: { type: Boolean, default: !1 },
        text: { type: String, required: !1 },
    }),
    emits: ["click"],
    setup(t, { emit: e }) {
        const r = H(() => ({ active: t.active })),
            n = H(() => (t.active ? "span" : "b-link")),
            i = H(() => ({ "aria-current": t.active ? t.ariaCurrent : void 0 }))
        return {
            liClasses: r,
            computedTag: n,
            computedAriaCurrent: i,
            clicked: function (o) {
                if (t.disabled || t.active) {
                    o.preventDefault(), o.stopImmediatePropagation()
                    return
                }
                t.disabled || e("click", o)
            },
        }
    },
})
function mC(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "li",
            { class: ye(["breadcrumb-item", t.liClasses]) },
            [
                (K(),
                we(
                    Ie(t.computedTag),
                    Je({ "aria-current": t.computedAriaCurrent }, t.$props, { onClick: t.clicked }),
                    { default: Te(() => [ge(t.$slots, "default")]), _: 3 },
                    16,
                    ["aria-current", "onClick"]
                )),
            ],
            2
        )
    )
}
var iy = xe(gC, [["render", mC]])
const bC = be({
        name: "BBreadcrumb",
        components: { BBreadcrumbItem: iy },
        props: { items: { type: Array } },
        setup(t) {
            const e = pC()
            return {
                computedItems: H(() => {
                    const n = t.items || (e == null ? void 0 : e.items) || []
                    let i = !1
                    return n.map(
                        (o, a) => (
                            typeof o == "string" && ((o = { text: o }), a < n.length - 1 && (o.href = "#")),
                            o.active && (i = !0),
                            !o.active && !i && (o.active = a + 1 === n.length),
                            o
                        )
                    )
                }),
            }
        },
    }),
    xC = { "aria-label": "breadcrumb" },
    vC = { class: "breadcrumb" }
function yC(t, e, r, n, i, s) {
    const o = Qt("b-breadcrumb-item")
    return (
        K(),
        ue("nav", xC, [
            He("ol", vC, [
                ge(t.$slots, "prepend"),
                (K(!0),
                ue(
                    Nt,
                    null,
                    Pn(t.computedItems, (a, l) => (K(), we(o, Je({ key: l }, a), { default: Te(() => [Ut(tt(a.text), 1)]), _: 2 }, 1040))),
                    128
                )),
                ge(t.$slots, "default"),
                ge(t.$slots, "append"),
            ]),
        ])
    )
}
var _C = xe(bC, [["render", yC]])
const wC = be({
    name: "BButton",
    props: Rt(Me({}, vl), {
        active: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        href: { type: String, required: !1 },
        pill: { type: Boolean, default: !1 },
        pressed: { type: Boolean, default: null },
        rel: { type: String, default: null },
        size: { type: String },
        squared: { type: Boolean, default: !1 },
        tag: { type: String, default: "button" },
        target: { type: String, default: "_self" },
        type: { type: String, default: "button" },
        variant: { type: String, default: "secondary" },
    }),
    emits: ["click", "update:pressed"],
    setup(t, { emit: e }) {
        const r = t.pressed !== null,
            n = t.tag === "button" && !t.href && !t.to,
            i = !!(t.href || t.to),
            s = !!t.to,
            o = t.href ? !1 : !n,
            a = H(() => ({
                [`btn-${t.variant}`]: t.variant,
                [`btn-${t.size}`]: t.size,
                active: t.active || t.pressed,
                "rounded-pill": t.pill,
                "rounded-0": t.squared,
                disabled: t.disabled,
            })),
            l = H(() => ({
                "aria-disabled": o ? String(t.disabled) : null,
                "aria-pressed": r ? String(t.pressed) : null,
                autocomplete: r ? "off" : null,
                disabled: n ? t.disabled : null,
                href: t.href,
                rel: i ? t.rel : null,
                role: o || i ? "button" : null,
                target: i ? t.target : null,
                type: n ? t.type : null,
                to: n ? null : t.to,
                append: i ? t.append : null,
                activeClass: s ? t.activeClass : null,
                event: s ? t.event : null,
                exact: s ? t.exact : null,
                exactActiveClass: s ? t.exactActiveClass : null,
                replace: s ? t.replace : null,
                routerComponentName: s ? t.routerComponentName : null,
                routerTag: s ? t.routerTag : null,
            })),
            c = function (u) {
                if (t.disabled) {
                    u.preventDefault(), u.stopPropagation()
                    return
                }
                e("click", u), r && e("update:pressed", !t.pressed)
            },
            f = H(() => (s ? "b-link" : t.href ? "a" : t.tag))
        return { classes: a, attrs: l, computedTag: f, clicked: c }
    },
})
function EC(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.computedTag),
            Je({ class: ["btn", t.classes] }, t.attrs, { onClick: t.clicked }),
            { default: Te(() => [ge(t.$slots, "default")]), _: 3 },
            16,
            ["class", "onClick"]
        )
    )
}
var oh = xe(wC, [["render", EC]])
const SC = be({
    name: "BButtonGroup",
    props: {
        ariaRole: { type: String, default: "group" },
        size: { type: String, required: !1 },
        tag: { type: String, default: "div" },
        vertical: { type: Boolean, default: !1 },
    },
    setup(t) {
        return { classes: H(() => ({ "btn-group": !t.vertical, "btn-group-vertical": t.vertical, [`btn-group-${t.size}`]: t.size })) }
    },
})
function AC(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tag),
            { class: ye(t.classes), role: "group", "aria-role": t.ariaRole },
            { default: Te(() => [ge(t.$slots, "default")]), _: 3 },
            8,
            ["class", "aria-role"]
        )
    )
}
var TC = xe(SC, [["render", AC]])
const CC = be({
        name: "BButtonToolbar",
        props: { ariaRole: { type: String, default: "group" }, justify: { type: Boolean, default: !1 } },
        setup(t) {
            return { classes: H(() => ({ "justify-content-between": t.justify })) }
        },
    }),
    kC = ["aria-label"]
function NC(t, e, r, n, i, s) {
    return (
        K(), ue("div", { class: ye([t.classes, "btn-toolbar"]), role: "toolbar", "aria-label": t.ariaRole }, [ge(t.$slots, "default")], 10, kC)
    )
}
var PC = xe(CC, [["render", NC]])
const IC = be({
        name: "BCard",
        props: {
            align: { type: String, required: !1 },
            bgVariant: { type: String, required: !1 },
            bodyBgVariant: { type: String, required: !1 },
            bodyClass: { type: [Array, Object, String], required: !1 },
            bodyTag: { type: String, default: "div" },
            bodyTextVariant: { type: String, required: !1 },
            borderVariant: { type: String, required: !1 },
            footer: { type: String, required: !1 },
            footerBgVariant: { type: String, required: !1 },
            footerBorderVariant: { type: String, required: !1 },
            footerClass: { type: [Array, Object, String], required: !1 },
            footerHtml: { type: String, default: "" },
            footerTag: { type: String, default: "div" },
            footerTextVariant: { type: String, required: !1 },
            header: { type: String, required: !1 },
            headerBgVariant: { type: String, required: !1 },
            headerBorderVariant: { type: String, required: !1 },
            headerClass: { type: [Array, Object, String], required: !1 },
            headerHtml: { type: String, default: "" },
            headerTag: { type: String, default: "div" },
            headerTextVariant: { type: String, required: !1 },
            imgAlt: { type: String, required: !1 },
            imgBottom: { type: Boolean, default: !1 },
            imgEnd: { type: Boolean, default: !1 },
            imgHeight: { type: [String, Number], required: !1 },
            imgLeft: { type: Boolean, default: !1 },
            imgRight: { type: Boolean, default: !1 },
            imgSrc: { type: String, required: !1 },
            imgStart: { type: Boolean, default: !1 },
            imgTop: { type: Boolean, default: !1 },
            imgWidth: { type: [String, Number], required: !1 },
            noBody: { type: Boolean, default: !1 },
            overlay: { type: Boolean, default: !1 },
            subTitle: { type: String, required: !1 },
            subTitleTag: { type: String, default: "h6" },
            subTitleTextVariant: { type: String, default: "muted" },
            tag: { type: String, default: "div" },
            textVariant: { type: String, required: !1 },
            title: { type: String, required: !1 },
            titleTag: { type: String, default: "h4" },
        },
        setup(t) {
            const e = H(() => ({
                    [`text-${t.align}`]: t.align,
                    [`text-${t.textVariant}`]: t.textVariant,
                    [`bg-${t.bgVariant}`]: t.bgVariant,
                    [`border-${t.borderVariant}`]: t.borderVariant,
                    "flex-row": t.imgLeft || t.imgStart,
                    "flex-row-reverse": t.imgEnd || t.imgRight,
                })),
                r = H(() => ({
                    "card-body": !t.noBody,
                    "card-img-overlay": t.overlay,
                    [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant,
                    [`text-${t.bodyTextVariant}`]: t.bodyTextVariant,
                })),
                n = H(() => ({
                    [`bg-${t.footerBgVariant}`]: t.footerBgVariant,
                    [`border-${t.footerBorderVariant}`]: t.footerBorderVariant,
                    [`text-${t.footerTextVariant}`]: t.footerTextVariant,
                })),
                i = H(() => ({
                    [`bg-${t.headerBgVariant}`]: t.headerBgVariant,
                    [`border-${t.headerBorderVariant}`]: t.headerBorderVariant,
                    [`text-${t.headerTextVariant}`]: t.headerTextVariant,
                })),
                s = H(() => ({
                    "card-img": !t.imgEnd && !t.imgRight && !t.imgStart && !t.imgLeft && !t.imgTop && !t.imgTop,
                    "card-img-right": t.imgEnd || t.imgRight,
                    "card-img-left": t.imgStart || t.imgLeft,
                    "card-img-top": t.imgTop,
                    "card-img-bottom": t.imgBottom,
                })),
                o = H(() => ({ src: t.imgSrc, alt: t.imgAlt, height: t.imgHeight, width: t.imgWidth })),
                a = H(() => ({ [`text-${t.subTitleTextVariant}`]: t.subTitleTextVariant }))
            return { classes: e, bodyClasses: r, footerClasses: n, headerClasses: i, imgClasses: s, imgAttr: o, subTitleClasses: a }
        },
    }),
    $C = ["innerHTML"],
    BC = ["innerHTML"]
function OC(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tag),
            { class: ye(["card", t.classes]) },
            {
                default: Te(() => [
                    t.imgSrc && !t.imgBottom ? (K(), ue("img", Je({ key: 0 }, t.imgAttr, { class: t.imgClasses }), null, 16)) : Be("", !0),
                    t.header || t.$slots.header || t.headerHtml
                        ? (K(),
                          we(
                              Ie(t.headerTag),
                              { key: 1, class: ye(["card-header", [t.headerClass, t.headerClasses]]) },
                              {
                                  default: Te(() => [
                                      t.headerHtml
                                          ? (K(), ue("div", { key: 0, innerHTML: t.headerHtml }, null, 8, $C))
                                          : ge(t.$slots, "header", { key: 1 }, () => [Ut(tt(t.header), 1)]),
                                  ]),
                                  _: 3,
                              },
                              8,
                              ["class"]
                          ))
                        : Be("", !0),
                    t.noBody
                        ? Be("", !0)
                        : (K(),
                          we(
                              Ie(t.bodyTag),
                              { key: 2, class: ye([t.bodyClass, t.bodyClasses]) },
                              {
                                  default: Te(() => [
                                      t.title && !t.noBody
                                          ? (K(),
                                            we(
                                                Ie(t.titleTag),
                                                { key: 0, class: "card-title" },
                                                { default: Te(() => [Ut(tt(t.title), 1)]), _: 1 }
                                            ))
                                          : Be("", !0),
                                      t.subTitle && !t.noBody
                                          ? (K(),
                                            we(
                                                Ie(t.subTitleTag),
                                                { key: 1, class: ye(["card-subtitle mb-2", t.subTitleClasses]) },
                                                { default: Te(() => [Ut(tt(t.subTitle), 1)]), _: 1 },
                                                8,
                                                ["class"]
                                            ))
                                          : Be("", !0),
                                      ge(t.$slots, "default"),
                                  ]),
                                  _: 3,
                              },
                              8,
                              ["class"]
                          )),
                    t.noBody ? ge(t.$slots, "default", { key: 3 }) : Be("", !0),
                    t.footer || t.$slots.footer || t.footerHtml
                        ? (K(),
                          we(
                              Ie(t.footerTag),
                              { key: 4, class: ye(["card-footer", [t.footerClass, t.footerClasses]]) },
                              {
                                  default: Te(() => [
                                      t.footerHtml
                                          ? (K(), ue("div", { key: 0, innerHTML: t.footerHtml }, null, 8, BC))
                                          : ge(t.$slots, "footer", { key: 1 }, () => [Ut(tt(t.footer), 1)]),
                                  ]),
                                  _: 3,
                              },
                              8,
                              ["class"]
                          ))
                        : Be("", !0),
                    t.imgSrc && t.imgBottom ? (K(), ue("img", Je({ key: 5 }, t.imgAttr, { class: t.imgClasses }), null, 16)) : Be("", !0),
                ]),
                _: 3,
            },
            8,
            ["class"]
        )
    )
}
var MC = xe(IC, [["render", OC]])
const RC = be({
    name: "BCardBody",
    props: {
        bodyBgVariant: { type: String, required: !1 },
        bodyClass: { type: [Array, Object, String], required: !1 },
        bodyTag: { type: String, default: "div" },
        bodyTextVariant: { type: String, required: !1 },
        overlay: { type: Boolean, default: !1 },
        subTitle: { type: String, required: !1 },
        subTitleTag: { type: String, default: "h4" },
        subTitleTextVariant: { type: String, required: !1 },
        title: { type: String, required: !1 },
        titleTag: { type: String, default: "h4" },
    },
    setup(t) {
        return { classes: H(() => ({ [`text-${t.bodyTextVariant}`]: t.bodyTextVariant, [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant })) }
    },
})
function LC(t, e, r, n, i, s) {
    const o = Qt("b-card-title"),
        a = Qt("b-card-sub-title")
    return (
        K(),
        we(
            Ie(t.bodyTag),
            { class: ye(["card-body", t.classes]) },
            {
                default: Te(() => [
                    t.title ? (K(), we(o, { key: 0, "title-tag": t.titleTag, title: t.title }, null, 8, ["title-tag", "title"])) : Be("", !0),
                    t.subTitle
                        ? (K(),
                          we(
                              a,
                              {
                                  key: 1,
                                  "sub-title-tag": t.subTitleTag,
                                  "sub-title": t.subTitle,
                                  "sub-title-text-variant": t.subTitleTextVariant,
                              },
                              null,
                              8,
                              ["sub-title-tag", "sub-title", "sub-title-text-variant"]
                          ))
                        : Be("", !0),
                    ge(t.$slots, "default"),
                ]),
                _: 3,
            },
            8,
            ["class"]
        )
    )
}
var DC = xe(RC, [["render", LC]])
const FC = be({
        name: "BCardFooter",
        props: {
            footer: { type: String },
            footerBgVariant: { type: String, required: !1 },
            footerBorderVariant: { type: String, required: !1 },
            footerClass: { type: [Array, Object, String], required: !1 },
            footerHtml: { type: String, required: !1 },
            footerTag: { type: String, default: "div" },
            footerTextVariant: { type: String, required: !1 },
        },
        setup(t) {
            return {
                classes: H(() => ({
                    [`text-${t.footerTextVariant}`]: t.footerTextVariant,
                    [`bg-${t.footerBgVariant}`]: t.footerBgVariant,
                    [`border-${t.footerBorderVariant}`]: t.footerBorderVariant,
                })),
            }
        },
    }),
    VC = ["innerHTML"]
function UC(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.footerTag),
            { class: ye(["card-footer", [t.footerClass, t.classes]]) },
            {
                default: Te(() => [
                    t.footerHtml
                        ? (K(), ue("div", { key: 0, innerHTML: t.footerHtml }, null, 8, VC))
                        : ge(t.$slots, "default", { key: 1 }, () => [Ut(tt(t.footer), 1)]),
                ]),
                _: 3,
            },
            8,
            ["class"]
        )
    )
}
var HC = xe(FC, [["render", UC]])
const qC = be({
    name: "BCardGroup",
    props: { columns: { type: Boolean, default: !1 }, deck: { type: Boolean, default: !1 }, tag: { type: String, default: "div" } },
    setup(t) {
        return { classes: H(() => (t.deck ? "card-deck" : t.columns ? "card-columns" : "card-group")) }
    },
})
function jC(t, e, r, n, i, s) {
    return K(), we(Ie(t.tag), { class: ye(t.classes) }, { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 8, ["class"])
}
var zC = xe(qC, [["render", jC]])
const KC = be({
        name: "BCardHeader",
        props: {
            header: { type: String, required: !1 },
            headerBgVariant: { type: String, required: !1 },
            headerBorderVariant: { type: String, required: !1 },
            headerClass: { type: [Array, Object, String], required: !1 },
            headerHtml: { type: String, required: !1 },
            headerTag: { type: String, default: "div" },
            headerTextVariant: { type: String, required: !1 },
        },
        setup(t) {
            return {
                classes: H(() => ({
                    [`text-${t.headerTextVariant}`]: t.headerTextVariant,
                    [`bg-${t.headerBgVariant}`]: t.headerBgVariant,
                    [`border-${t.headerBorderVariant}`]: t.headerBorderVariant,
                })),
            }
        },
    }),
    GC = ["innerHTML"]
function WC(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.headerTag),
            { class: ye(["card-header", [t.headerClass, t.classes]]) },
            {
                default: Te(() => [
                    t.headerHtml
                        ? (K(), ue("div", { key: 0, innerHTML: t.headerHtml }, null, 8, GC))
                        : ge(t.$slots, "default", { key: 1 }, () => [Ut(tt(t.header), 1)]),
                ]),
                _: 3,
            },
            8,
            ["class"]
        )
    )
}
var JC = xe(KC, [["render", WC]])
const XC = be({
    name: "BCardImage",
    props: {
        alt: { type: String, default: null },
        bottom: { type: Boolean, default: !1 },
        end: { type: Boolean, default: !1 },
        height: { type: [Number, String], required: !1 },
        left: { type: Boolean, default: !1 },
        right: { type: Boolean, default: !1 },
        src: { type: String, required: !1 },
        start: { type: Boolean, default: !1 },
        top: { type: Boolean, default: !1 },
        width: { type: [Number, String], required: !1 },
    },
    setup(t) {
        const e = H(() => ({
                src: t.src,
                alt: t.alt,
                width: (typeof t.width == "number" ? t.width : parseInt(t.width, 10)) || void 0,
                height: (typeof t.height == "number" ? t.height : parseInt(t.height, 10)) || void 0,
            })),
            r = H(() => {
                const n = t.left ? "float-left" : t.right ? "float-right" : ""
                let i = "card-img"
                return (
                    t.top
                        ? (i += "-top")
                        : t.right || t.end
                        ? (i += "-right")
                        : t.bottom
                        ? (i += "-bottom")
                        : (t.left || t.start) && (i += "-left"),
                    { [n]: !!n, [i]: !0 }
                )
            })
        return { attrs: e, classes: r }
    },
})
function YC(t, e, r, n, i, s) {
    return K(), ue("img", Je({ class: t.classes }, t.attrs), null, 16)
}
var ZC = xe(XC, [["render", YC]])
const QC = be({
    name: "BCardSubTitle",
    props: { subTitle: { type: String }, subTitleTag: { type: String, default: "h6" }, subTitleTextVariant: { type: String, default: "muted" } },
    setup(t) {
        return { classes: H(() => ({ [`text-${t.subTitleTextVariant}`]: t.subTitleTextVariant })) }
    },
})
function ek(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.subTitleTag),
            { class: ye(["card-subtitle mb-2", t.classes]) },
            { default: Te(() => [ge(t.$slots, "default", {}, () => [Ut(tt(t.subTitle), 1)])]), _: 3 },
            8,
            ["class"]
        )
    )
}
var tk = xe(QC, [["render", ek]])
const rk = {},
    nk = { class: "card-text" }
function ik(t, e) {
    return K(), ue("p", nk, [ge(t.$slots, "default")])
}
var sk = xe(rk, [["render", ik]])
const ok = be({ name: "BCardTitle", props: { title: { type: String }, titleTag: { type: String, default: "h4" } } })
function ak(t, e, r, n, i, s) {
    return (
        K(), we(Ie(t.titleTag), { class: "card-title" }, { default: Te(() => [ge(t.$slots, "default", {}, () => [Ut(tt(t.title), 1)])]), _: 3 })
    )
}
var lk = xe(ok, [["render", ak]])
const sy = Symbol(),
    ck = be({
        name: "BCarousel",
        props: {
            background: { type: String, required: !1 },
            modelValue: { type: Number, default: 0 },
            controls: { type: Boolean, default: !1 },
            id: { type: String },
            imgHeight: { type: String },
            imgWidth: { type: String },
            indicators: { type: Boolean, default: !1 },
            interval: { type: Number, default: 5e3 },
            noTouch: { type: Boolean, default: !1 },
            noWrap: { type: Boolean, default: !1 },
        },
        emits: ["sliding-start", "sliding-end"],
        setup(t, { slots: e, emit: r }) {
            const n = Ue(),
                i = Ue(),
                s = gr(t.id, "accordion"),
                o = Ue([])
            return (
                Bt(n, "slide.bs.carousel", (a) => r("sliding-start", a)),
                Bt(n, "slid.bs.carousel", (a) => r("sliding-end", a)),
                Zt(() => {
                    ;(i.value = new An(n.value, { wrap: !t.noTouch, interval: t.interval, touch: !t.noTouch })),
                        e.default &&
                            (o.value = e.default().filter((a) => {
                                var l
                                return ((l = a.type) == null ? void 0 : l.name) === "BCarouselSlide"
                            }))
                }),
                Nn(sy, { background: t.background, width: t.imgWidth, height: t.imgHeight }),
                { element: n, computedId: s, slides: o }
            )
        },
    }),
    fk = ["id"],
    uk = { key: 0, class: "carousel-indicators" },
    dk = ["data-bs-target", "data-bs-slide-to", "aria-label"],
    hk = { class: "carousel-inner" },
    pk = ["data-bs-target"],
    gk = He("span", { class: "carousel-control-prev-icon", "aria-hidden": "true" }, null, -1),
    mk = He("span", { class: "visually-hidden" }, "Previous", -1),
    bk = [gk, mk],
    xk = ["data-bs-target"],
    vk = He("span", { class: "carousel-control-next-icon", "aria-hidden": "true" }, null, -1),
    yk = He("span", { class: "visually-hidden" }, "Next", -1),
    _k = [vk, yk]
function wk(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "div",
            { id: t.computedId, ref: "element", class: "carousel slide", "data-bs-ride": "carousel" },
            [
                t.indicators
                    ? (K(),
                      ue("div", uk, [
                          (K(!0),
                          ue(
                              Nt,
                              null,
                              Pn(
                                  t.slides,
                                  (o, a) => (
                                      K(),
                                      ue(
                                          "button",
                                          {
                                              key: a,
                                              type: "button",
                                              "data-bs-target": `#${t.computedId}`,
                                              "data-bs-slide-to": a,
                                              class: ye(a === 0 ? "active" : ""),
                                              "aria-current": "true",
                                              "aria-label": `Slide ${a}`,
                                          },
                                          null,
                                          10,
                                          dk
                                      )
                                  )
                              ),
                              128
                          )),
                      ]))
                    : Be("", !0),
                He("div", hk, [ge(t.$slots, "default")]),
                t.controls
                    ? (K(),
                      ue(
                          Nt,
                          { key: 1 },
                          [
                              He(
                                  "button",
                                  {
                                      class: "carousel-control-prev",
                                      type: "button",
                                      "data-bs-target": `#${t.computedId}`,
                                      "data-bs-slide": "prev",
                                  },
                                  bk,
                                  8,
                                  pk
                              ),
                              He(
                                  "button",
                                  {
                                      class: "carousel-control-next",
                                      type: "button",
                                      "data-bs-target": `#${t.computedId}`,
                                      "data-bs-slide": "next",
                                  },
                                  _k,
                                  8,
                                  xk
                              ),
                          ],
                          64
                      ))
                    : Be("", !0),
            ],
            8,
            fk
        )
    )
}
var Ek = xe(ck, [["render", wk]])
const Sk = be({
        name: "BCarouselSlide",
        props: {
            active: { type: Boolean, default: !1 },
            background: { type: String, required: !1 },
            caption: { type: String, required: !1 },
            captionHtml: { type: String, required: !1 },
            captionTag: { type: String, default: "h3" },
            contentTag: { type: String, default: "div" },
            contentVisibleUp: { type: String, required: !1 },
            id: { type: String, required: !1 },
            imgAlt: { type: String, required: !1 },
            imgBlank: { type: Boolean, default: !1 },
            imgBlankColor: { type: String, default: "transparent" },
            imgHeight: { type: String },
            imgSrc: { type: String },
            imgWidth: { type: String },
            interval: { type: [String, Number] },
            text: { type: String, required: !1 },
            textHtml: { type: String, required: !1 },
            textTag: { type: String, default: "p" },
        },
        setup(t) {
            const e = sr(sy, {}),
                r = gr(t.id, "accordion"),
                n = H(() => (t.imgBlank ? t.imgBlank : t.imgSrc)),
                i = H(() => ({ background: `${t.background || e.background || "rgb(171, 171, 171)"} none repeat scroll 0% 0%` })),
                s = H(() => ({ "d-none": t.contentVisibleUp, [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp })),
                o = H(() => t.text && !t.textHtml),
                a = H(() => t.textHtml),
                l = H(() => t.caption && !t.captionHtml),
                c = H(() => t.captionHtml)
            return {
                computedAttr: i,
                computedContentClasses: s,
                computedId: r,
                height: e.height,
                img: n,
                showCaption: l,
                showCaptionAsHtml: c,
                showText: o,
                showTextAsHtml: a,
                width: e.width,
            }
        },
    }),
    Ak = ["id", "data-bs-interval"],
    Tk = { key: 0 },
    Ck = ["innerHTML"],
    kk = { key: 0 },
    Nk = ["innerHTML"]
function Pk(t, e, r, n, i, s) {
    const o = Qt("b-img")
    return (
        K(),
        ue(
            "div",
            { id: t.computedId, class: ye(["carousel-item", { active: t.active }]), "data-bs-interval": t.interval, style: ni(t.computedAttr) },
            [
                ge(t.$slots, "img", {}, () => [
                    jt(
                        o,
                        {
                            class: "d-block w-100",
                            alt: t.imgAlt,
                            src: t.imgSrc,
                            width: t.imgWidth || t.width,
                            height: t.imgHeight || t.height,
                            blank: t.imgBlank,
                            "blank-color": t.imgBlankColor,
                        },
                        null,
                        8,
                        ["alt", "src", "width", "height", "blank", "blank-color"]
                    ),
                ]),
                t.caption || t.captionHtml || t.text || t.textHtml || t.$slots.default
                    ? (K(),
                      we(
                          Ie(t.contentTag),
                          { key: 0, class: ye(["carousel-caption", t.computedContentClasses]) },
                          {
                              default: Te(() => [
                                  t.caption || t.captionHtml
                                      ? (K(),
                                        we(
                                            Ie(t.captionTag),
                                            { key: 0 },
                                            {
                                                default: Te(() => [
                                                    t.showCaption ? (K(), ue("span", Tk, tt(t.caption), 1)) : Be("", !0),
                                                    t.showCaptionAsHtml
                                                        ? (K(), ue("span", { key: 1, innerHTML: t.captionHtml }, null, 8, Ck))
                                                        : Be("", !0),
                                                ]),
                                                _: 1,
                                            }
                                        ))
                                      : Be("", !0),
                                  t.text || t.textHtml
                                      ? (K(),
                                        we(
                                            Ie(t.textTag),
                                            { key: 1 },
                                            {
                                                default: Te(() => [
                                                    t.showText ? (K(), ue("span", kk, tt(t.text), 1)) : Be("", !0),
                                                    t.showTextAsHtml
                                                        ? (K(), ue("span", { key: 1, innerHTML: t.textHtml }, null, 8, Nk))
                                                        : Be("", !0),
                                                ]),
                                                _: 1,
                                            }
                                        ))
                                      : Be("", !0),
                                  ge(t.$slots, "default"),
                              ]),
                              _: 3,
                          },
                          8,
                          ["class"]
                      ))
                    : Be("", !0),
            ],
            14,
            Ak
        )
    )
}
var Ik = xe(Sk, [["render", Pk]])
const $k = be({
        name: "BCloseButton",
        props: { disabled: { type: Boolean, default: !1 }, white: { type: Boolean, default: !1 } },
        setup(t) {
            return { classes: H(() => ({ "btn-close-white": t.white })) }
        },
    }),
    Bk = ["disabled"]
function Ok(t, e, r, n, i, s) {
    return K(), ue("button", { type: "button", class: ye(["btn-close", t.classes]), disabled: t.disabled, "aria-label": "Close" }, null, 10, Bk)
}
var oy = xe($k, [["render", Ok]]),
    yf = (t, e, r) =>
        e
            .concat(["sm", "md", "lg", "xl", "xxl"])
            .reduce((n, i) => ((n[t ? `${t}${i.charAt(0).toUpperCase() + i.slice(1)}` : i] = r), n), Object.create(null)),
    ay = (t, e, r, n = r) =>
        Object.keys(e).reduce(
            (i, s) => (
                t[s] &&
                    i.push(
                        [n, s.replace(r, ""), t[s]]
                            .filter((o) => o)
                            .join("-")
                            .toLowerCase()
                    ),
                i
            ),
            []
        )
const bm = yf("", [], { type: [Boolean, String, Number], default: !1 }),
    xm = yf("offset", [""], { type: [String, Number], default: null }),
    vm = yf("order", [""], { type: [String, Number], default: null }),
    Mk = be({
        name: "BCol",
        props: Rt(
            Me(
                Rt(
                    Me(
                        Rt(Me({ col: { type: Boolean, default: !1 }, cols: { type: [String, Number], default: null } }, bm), {
                            offset: { type: [String, Number], default: null },
                        }),
                        xm
                    ),
                    { order: { type: [String, Number], default: null } }
                ),
                vm
            ),
            { alignSelf: { type: String, default: null }, tag: { type: String, default: "div" } }
        ),
        setup(t) {
            let e = []
            return (
                [
                    { content: bm, propPrefix: "cols", classPrefix: "col" },
                    { content: xm, propPrefix: "offset" },
                    { content: vm, propPrefix: "order" },
                ].forEach((i) => {
                    e = e.concat(ay(t, i.content, i.propPrefix, i.classPrefix))
                }),
                {
                    classes: H(() => ({
                        col: t.col || !e.some((i) => /^col-/.test(i) && !t.cols),
                        [`col-${t.cols}`]: !!t.cols,
                        [`offset-${t.offset}`]: !!t.offset,
                        [`order-${t.order}`]: !!t.order,
                        [`align-self-${t.alignSelf}`]: !!t.alignSelf,
                    })),
                    classList: e,
                }
            )
        },
    })
function Rk(t, e, r, n, i, s) {
    return K(), we(Ie(t.tag), { class: ye([t.classes, t.classList]) }, { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 8, ["class"])
}
var va = xe(Mk, [["render", Rk]])
let eo = { delay: 5e3, value: !0, pos: "top-right" }
class ym {
    constructor(e) {
        ks(e) ? (this.vm = e) : (this.vm = Ln(e)),
            (this.containerPositions = H(() => {
                let r = new Set([])
                return (
                    this.vm.toasts.map((n) => {
                        n.options.pos && r.add(n.options.pos)
                    }),
                    r
                )
            }))
    }
    toasts(e) {
        return H(
            e
                ? () =>
                      this.vm.toasts.filter((r) => {
                          if (r.options.pos == e) return r
                      })
                : () => this.vm.toasts
        )
    }
    displayedToasts(e) {
        return H(() =>
            this.vm.toasts.filter((r) => {
                if (r.options.pos == e && r.options.value) return r
                if (r.options.value) return r
            })
        )
    }
    remove(...e) {
        this.vm.toasts = this.vm.toasts.filter((r) => {
            if (!e.includes(r.options.id)) return r
        })
    }
    isRoot() {
        var e
        return (e = this.vm.root) != null ? e : !1
    }
    show(e, r = eo) {
        let n = Me(Me({ id: ei() }, eo), r),
            i = { options: Ln(n), content: e }
        return this.vm.toasts.push(i), i
    }
    info(e, r = eo) {
        return this.show(e, Me({ variant: "info" }, r))
    }
    danger(e, r = eo) {
        return this.show(e, Me({ variant: "danger" }, r))
    }
    warning(e, r = eo) {
        return this.show(e, Me({ variant: "warning" }, r))
    }
    success(e, r = eo) {
        return this.show(e, Me({ variant: "success" }, r))
    }
    hide() {}
}
class Lk {
    constructor() {
        ;(this.useToast = ly), (this.vms = {})
    }
    getOrCreateViewModel(e) {
        if (e) {
            if (e.root) {
                if (this.rootInstance) return this.vms[this.rootInstance]
                this.rootInstance = e.id
            }
            return (this.vms[e.id] = e), e
        } else {
            if (this.rootInstance) return this.vms[this.rootInstance]
            {
                let r = { root: !0, toasts: [], container: void 0, id: Symbol("toast") }
                return (this.rootInstance = r.id), (this.vms[r.id] = r), r
            }
        }
    }
    getVM(e) {
        if (!e && this.rootInstance) return this.vms[this.rootInstance]
        if (e) return this.vms[e]
    }
}
let $d = "toast",
    Dk = { container: void 0, toasts: [], root: !1 }
function ly(t, e = $d) {
    let r = sr(e !== null ? e : $d)
    if (!t) return new ym(r.getOrCreateViewModel())
    let n = { id: Symbol("toastInstance") },
        i = Me(Me(Me({}, Dk), n), t),
        s = r.getOrCreateViewModel(i)
    return new ym(s)
}
const Fk = {
        install: (t, e = {}) => {
            var r, n
            t.provide((n = (r = e == null ? void 0 : e.BToast) == null ? void 0 : r.injectkey) != null ? n : $d, new Lk())
        },
    },
    Vk = {
        "top-left": "top-0 start-0",
        "top-center": "top-0 start-50",
        "top-right": "top-0 end-0",
        "middle-left": "top-50 start-0 translate-middle-y",
        "middle-center": "top-50 start-50 translate-middle",
        "middle-right": "top-50 end-0 translate-middle-y",
        "bottom-left": "bottom-0 start-0",
        "bottom-center": "bottom-0 start-50",
        "bottom-right": "bottom-0 end-0",
    },
    Uk = be({
        name: "BToaster",
        props: { position: { type: String, default: "top-right" }, instance: { type: Object } },
        setup(t, { emit: e }) {
            return {
                positionClass: H(() => Vk[t.position]),
                handleDestroy: (i) => {
                    var s
                    ;(s = t.instance) == null || s.remove(i)
                },
            }
        },
        computed: {},
    }),
    Hk = He("div", null, null, -1)
function qk(t, e, r, n, i, s) {
    const o = Qt("b-toast")
    return (
        K(),
        ue(
            "div",
            { class: ye([[t.positionClass], "b-toaster position-fixed p-3"]), style: { "z-index": "11" } },
            [
                (K(!0),
                ue(
                    Nt,
                    null,
                    Pn(
                        t.instance.displayedToasts().value,
                        (a) => (
                            K(),
                            we(
                                o,
                                {
                                    id: a.options.id,
                                    key: a.options.id,
                                    modelValue: a.options.value,
                                    "onUpdate:modelValue": (l) => (a.options.value = l),
                                    title: a.content.title,
                                    body: a.content.body,
                                    component: a.content.vnode,
                                    variant: a.options.variant,
                                    onDestroyed: t.handleDestroy,
                                },
                                null,
                                8,
                                ["id", "modelValue", "onUpdate:modelValue", "title", "body", "component", "variant", "onDestroyed"]
                            )
                        )
                    ),
                    128
                )),
                Hk,
            ],
            2
        )
    )
}
var Bd = xe(Uk, [["render", qk]])
const jk = be({
    name: "BContainer",
    props: { fluid: { type: [Boolean, String], default: !1 }, toast: { type: Object }, position: { type: String, required: !1 } },
    setup(t, { slots: e, expose: r }) {
        const n = Ue()
        let i
        const s = H(() => ({
            container: !t.fluid,
            ["container-fluid"]: typeof t.fluid == "boolean" && t.fluid,
            [`container-${t.fluid}`]: typeof t.fluid == "string",
        }))
        return (
            Zt(() => {
                t.toast
            }),
            t.toast && ((i = ly({ container: n, root: t.toast.root })), r({})),
            () => {
                var o
                const a = []
                return (
                    i == null ||
                        i.containerPositions.value.forEach((l) => {
                            a.push(Ae(Bd, { instance: i, position: l }))
                        }),
                    Ae("div", { class: [s.value, t.position], ref: n }, [...a, (o = e.default) == null ? void 0 : o.call(e)])
                )
            }
        )
    },
    methods: {},
})
function Nu(t) {
    return t && typeof t == "object" && t.constructor === Object
}
function Od(t, e, r = !0) {
    const n = t instanceof Date && typeof t.getMonth == "function" ? new Date(t) : Object.assign({}, t)
    return (
        Nu(t) &&
            Nu(e) &&
            Object.keys(e).forEach((i) => {
                Nu(e[i])
                    ? i in t
                        ? (n[i] = Od(t[i], e[i], r))
                        : Object.assign(n, { [i]: e[i] })
                    : Array.isArray(e[i]) && Array.isArray(t[i])
                    ? Object.assign(n, { [i]: r ? t[i].concat(e[i].filter((s) => !t[i].includes(s))) : e[i] })
                    : Object.assign(n, { [i]: e[i] })
            }),
        n
    )
}
const zk = be({
        name: "BDropdown",
        components: { BButton: oh },
        props: {
            autoClose: { type: [Boolean, String], default: !0 },
            block: { type: Boolean, default: !1 },
            boundary: { type: [gT, String], default: "clippingParents" },
            dark: { type: Boolean, default: !1 },
            disabled: { type: Boolean, default: !1 },
            dropup: { type: Boolean, default: !1 },
            dropright: { type: Boolean, default: !1 },
            dropleft: { type: Boolean, default: !1 },
            id: { type: String },
            menuClass: { type: [Array, Object, String] },
            noFlip: { type: Boolean, default: !1 },
            offset: { type: [Number, String], default: 0 },
            popperOpts: { type: Object, default: () => ({}) },
            right: { type: Boolean, default: !1 },
            role: { type: String, default: "menu" },
            size: { type: String },
            split: { type: Boolean, default: !1 },
            splitButtonType: { type: String, default: "button" },
            splitClass: { type: [Array, Object, String] },
            splitHref: { type: String, default: null },
            noCaret: { type: Boolean, default: !1 },
            splitVariant: { type: String },
            text: { type: String },
            toggleClass: { type: [Array, Object, String] },
            toggleText: { type: String, default: "Toggle dropdown" },
            variant: { type: String, default: "secondary" },
        },
        emits: ["show", "shown", "hide", "hidden"],
        setup(t, { emit: e }) {
            const r = Ue(),
                n = Ue(),
                i = Ue(),
                s = gr(t.id, "dropdown")
            Bt(r, "show.bs.dropdown", () => e("show")),
                Bt(r, "shown.bs.dropdown", () => e("shown")),
                Bt(r, "hide.bs.dropdown", () => e("hide")),
                Bt(r, "hidden.bs.dropdown", () => e("hidden"))
            const o = H(() => ({ "d-grid": t.block, "d-flex": t.block && t.split })),
                a = H(() => ({ "dropdown-toggle": !t.split, "dropdown-toggle-no-caret": t.noCaret && !t.split, "w-100": t.split && t.block })),
                l = H(() => ({ "dropdown-menu-dark": t.dark })),
                c = H(() => ({
                    "data-bs-toggle": t.split ? null : "dropdown",
                    "aria-expanded": t.split ? null : !1,
                    ref: t.split ? null : n,
                    href: t.split ? t.splitHref : null,
                })),
                f = H(() => ({ ref: t.split ? n : null })),
                u = () => {
                    var p
                    ;(p = i.value) == null || p.hide()
                }
            return (
                Zt(() => {
                    var p
                    i.value = new Ir((p = n.value) == null ? void 0 : p.$el, {
                        autoClose: t.autoClose,
                        boundary: t.boundary,
                        offset: t.offset.toString(),
                        reference: t.offset || t.split ? "parent" : "toggle",
                        popperConfig: (m) => {
                            const y = {
                                placement: "bottom-start",
                                modifiers: t.noFlip ? [{ name: "flip", options: { fallbackPlacements: [] } }] : [],
                            }
                            return (
                                t.dropup
                                    ? (y.placement = t.right ? "top-end" : "top-start")
                                    : t.dropright
                                    ? (y.placement = "right-start")
                                    : t.dropleft
                                    ? (y.placement = "left-start")
                                    : t.right && (y.placement = "bottom-end"),
                                Od(m, Od(y, t.popperOpts))
                            )
                        },
                    })
                }),
                {
                    parent: r,
                    computedId: s,
                    classes: o,
                    buttonClasses: a,
                    buttonAttr: c,
                    splitAttr: f,
                    dropdownMenuClasses: l,
                    dropdown: n,
                    hide: u,
                }
            )
        },
    }),
    Kk = { class: "visually-hidden" },
    Gk = ["aria-labelledby", "role"]
function Wk(t, e, r, n, i, s) {
    const o = Qt("b-button")
    return (
        K(),
        ue(
            "div",
            { ref: "parent", class: ye([t.classes, "btn-group"]) },
            [
                jt(
                    o,
                    Je(
                        {
                            id: t.computedId,
                            variant: t.splitVariant || t.variant,
                            size: t.size,
                            class: [t.buttonClasses, t.split ? t.splitClass : t.toggleClass],
                            disabled: t.disabled,
                            type: t.splitButtonType,
                        },
                        t.buttonAttr
                    ),
                    { default: Te(() => [Ut(tt(t.text) + " ", 1), ge(t.$slots, "button-content")]), _: 3 },
                    16,
                    ["id", "variant", "size", "class", "disabled", "type"]
                ),
                t.split
                    ? (K(),
                      we(
                          o,
                          Je({ key: 0, variant: t.variant, size: t.size, disabled: t.disabled }, t.splitAttr, {
                              class: [t.toggleClass, "dropdown-toggle-split dropdown-toggle"],
                              "data-bs-toggle": "dropdown",
                              "aria-expanded": "false",
                          }),
                          { default: Te(() => [He("span", Kk, tt(t.toggleText), 1)]), _: 1 },
                          16,
                          ["variant", "size", "disabled", "class"]
                      ))
                    : Be("", !0),
                He(
                    "ul",
                    { class: ye(["dropdown-menu", [t.menuClass, t.dropdownMenuClasses]]), "aria-labelledby": t.computedId, role: t.role },
                    [ge(t.$slots, "default")],
                    10,
                    Gk
                ),
            ],
            2
        )
    )
}
var Jk = xe(zk, [["render", Wk]])
const Xk = be({ name: "BDropdownDivider", props: { tag: { type: String, default: "hr" } } }),
    Yk = { role: "presentation" }
function Zk(t, e, r, n, i, s) {
    return K(), ue("li", Yk, [(K(), we(Ie(t.tag), { class: "dropdown-divider", role: "separator", "aria-orientation": "horizontal" }))])
}
var Qk = xe(Xk, [["render", Zk]])
const eN = be({ name: "BDropdownForm" }),
    tN = { role: "presentation" },
    rN = { class: "px-4 py-3" }
function nN(t, e, r, n, i, s) {
    return K(), ue("li", tN, [He("form", rN, [ge(t.$slots, "default")])])
}
var iN = xe(eN, [["render", nN]])
const sN = be({
        name: "BDropdownGroup",
        inheritAttrs: !1,
        props: {
            ariaDescribedby: { type: String },
            header: { type: String },
            headerClasses: { type: [String, Array, Object], default: null },
            headerTag: { type: String, default: "header" },
            headerVariant: { type: String, default: null },
            id: { type: String },
        },
        setup(t) {
            const e = H(() => (t.id ? [t.id, "group_dd_header"].join("_") : null)),
                r = H(() => (t.headerTag === "header" ? null : "heading"))
            return { classes: H(() => ({ [`text-${t.headerVariant}`]: t.headerVariant })), headerId: e, headerRole: r }
        },
    }),
    oN = { role: "presentation" },
    aN = ["id", "aria-describedby"]
function lN(t, e, r, n, i, s) {
    return (
        K(),
        ue("li", oN, [
            (K(),
            we(
                Ie(t.headerTag),
                { id: t.headerId, class: ye(["dropdown-header", [t.classes, t.headerClasses]]), role: t.headerRole },
                { default: Te(() => [ge(t.$slots, "header", {}, () => [Ut(tt(t.header), 1)])]), _: 3 },
                8,
                ["id", "class", "role"]
            )),
            He(
                "ul",
                Je({ id: t.id, role: "group", class: "list-unstyled" }, t.$attrs, { "aria-describedby": t.ariaDescribedby || t.headerId }),
                [ge(t.$slots, "default")],
                16,
                aN
            ),
        ])
    )
}
var cN = xe(sN, [["render", lN]])
const fN = {},
    uN = { class: "dropdown-header" }
function dN(t, e) {
    return K(), ue("li", null, [He("h6", uN, [ge(t.$slots, "default")])])
}
var hN = xe(fN, [["render", dN]])
const pN = be({
        name: "BDropdownItem",
        inheritAttrs: !1,
        props: {
            active: { type: Boolean, default: !1 },
            disabled: { type: Boolean, default: !1 },
            href: { type: String },
            linkClass: { type: [Array, Object, String] },
            rel: { type: String, default: null },
            target: { type: String, default: "_self" },
            variant: { type: String, default: null },
        },
        emits: ["click"],
        setup(t) {
            const e = H(() => ({ active: t.active, disabled: t.disabled, [`text-${t.variant}`]: t.variant })),
                r = H(() => (t.href ? "a" : "button")),
                n = H(() => ({
                    "aria-current": t.active ? "true" : null,
                    href: r.value === "a" ? t.href : null,
                    rel: t.rel,
                    type: r.value === "button" ? "button" : null,
                    target: t.target,
                }))
            return { classes: e, tag: r, attrs: n }
        },
    }),
    gN = { role: "presentation" }
function mN(t, e, r, n, i, s) {
    return (
        K(),
        ue("li", gN, [
            (K(),
            we(
                Ie(t.tag),
                Je({ class: ["dropdown-item", [t.classes, t.linkClass]] }, t.attrs, { onClick: e[0] || (e[0] = (o) => t.$emit("click", o)) }),
                { default: Te(() => [ge(t.$slots, "default")]), _: 3 },
                16,
                ["class"]
            )),
        ])
    )
}
var bN = xe(pN, [["render", mN]])
const xN = be({
        name: "BDropdownItemButton",
        inheritAttrs: !1,
        props: {
            active: { type: Boolean, default: !1 },
            activeClass: { type: String, default: "active" },
            buttonClass: { type: [String, Array, Object] },
            disabled: { type: Boolean, default: !1 },
            variant: { type: String, default: null },
        },
        emits: ["click"],
        setup(t) {
            const e = H(() => ({ [t.activeClass]: t.active, disabled: t.disabled, [`text-${t.variant}`]: t.variant })),
                r = H(() => ({ role: "menuitem", type: "button", disabled: t.disabled }))
            return { classes: e, attrs: r }
        },
    }),
    vN = { role: "presentation" }
function yN(t, e, r, n, i, s) {
    return (
        K(),
        ue("li", vN, [
            He(
                "button",
                Je({ class: ["dropdown-item", [t.classes, t.buttonClass]] }, t.attrs, { onClick: e[0] || (e[0] = (o) => t.$emit("click", o)) }),
                [ge(t.$slots, "default")],
                16
            ),
        ])
    )
}
var _N = xe(xN, [["render", yN]])
const wN = be({ name: "BDropdownText" }),
    EN = { role: "presentation" },
    SN = { class: "px-4 py-1 mb-0 text-muted" }
function AN(t, e, r, n, i, s) {
    return K(), ue("li", EN, [He("p", SN, [ge(t.$slots, "default")])])
}
var TN = xe(wN, [["render", AN]])
const CN = be({
        name: "BForm",
        props: {
            id: { type: String, required: !1 },
            floating: { type: Boolean, default: !1 },
            novalidate: { type: Boolean, default: !1 },
            validated: { type: Boolean, default: !1 },
        },
        emits: ["submit"],
        setup(t) {
            return { classes: H(() => ({ "form-floating": t.floating, "was-validated": t.validated })) }
        },
    }),
    kN = ["id", "novalidate"]
function NN(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "form",
            {
                id: t.id,
                novalidate: t.novalidate,
                class: ye(t.classes),
                onSubmit: e[0] || (e[0] = Kc((o) => t.$emit("submit", o), ["prevent"])),
            },
            [ge(t.$slots, "default")],
            42,
            kN
        )
    )
}
var PN = xe(CN, [["render", NN]])
const IN = (t) =>
        H(() =>
            t.ariaInvalid === !0 || t.ariaInvalid === "true" || t.ariaInvalid === "" || (typeof t.state == "boolean" ? t.state : null) === !1
                ? "true"
                : t.ariaInvalid
        ),
    cy = (t) =>
        H(() => ({
            "form-check": !t.plain && !t.button,
            "form-check-inline": t.inline,
            "form-switch": t.switch,
            [`form-control-${t.size}`]: t.size && t.size !== "md",
        })),
    fy = (t) =>
        H(() => ({
            "form-check-input": !t.plain && !t.button,
            "is-valid": t.state === !0,
            "is-invalid": t.state === !1,
            "btn-check": t.button,
        })),
    uy = (t) =>
        H(() => ({
            "form-check-label": !t.plain && !t.button,
            btn: t.button,
            [`btn-${t.buttonVariant}`]: t.button,
            [`btn-${t.size}`]: t.button && t.size && t.size !== "md",
        })),
    dy = (t) => H(() => ({ "aria-invalid": IN(t).value, "aria-required": t.required.toString() === "true" ? "true" : null })),
    hy = (t) =>
        H(() => ({
            "was-validated": t.validated,
            "btn-group": t.buttons && !t.stacked,
            "btn-group-vertical": t.stacked,
            [`btn-group-${t.size}`]: t.size,
        })),
    $c = (t, e, r) =>
        t
            .filter((n) => n.type.name === e)
            .map((n) => {
                const i = (n.children.default ? n.children.default() : []).find((s) => s.type.toString() === "Symbol(Text)")
                return { props: Me({ disabled: r }, n.props), text: i ? i.children : "" }
            }),
    py = (t, e) =>
        typeof t == "string"
            ? { props: { value: t, disabled: e.disabled }, text: t }
            : {
                  props: Me({ value: t[e.valueField], disabled: e.disabled || t[e.disabledField] }, t.props),
                  text: t[e.textField],
                  html: t[e.htmlField],
              },
    gy = (t, e, r, n, i) =>
        Rt(Me({}, t), {
            props: Me(
                {
                    "button-variant": r.buttonVariant,
                    form: r.form,
                    name: n.value,
                    id: `${i.value}_option_${e}`,
                    button: r.buttons,
                    state: r.state,
                    plain: r.plain,
                    size: r.size,
                    inline: !r.stacked,
                    required: r.required,
                },
                t.props
            ),
        }),
    $N = be({
        name: "BFormCheckbox",
        inheritAttrs: !1,
        props: {
            id: { type: String, default: void 0 },
            ariaLabel: { type: String },
            ariaLabelledBy: { type: String },
            autofocus: { type: Boolean, default: !1 },
            plain: { type: Boolean, default: !1 },
            button: { type: Boolean, default: !1 },
            switch: { type: Boolean, default: !1 },
            disabled: { type: Boolean, default: !1 },
            buttonVariant: { type: String, default: "secondary" },
            form: { type: String },
            indeterminate: { type: Boolean },
            inline: { type: Boolean, default: !1 },
            name: { type: String },
            required: { type: Boolean, default: void 0 },
            size: { type: String, default: "md" },
            state: { type: Boolean, default: null },
            uncheckedValue: { type: [Boolean, String, Array, Object, Number], default: !1 },
            value: { type: [Boolean, String, Array, Object, Number], default: !0 },
            modelValue: { type: [Boolean, String, Array, Object, Number], default: null },
        },
        emits: ["update:modelValue", "input", "change"],
        setup(t, { emit: e }) {
            const r = gr(t.id, "form-check"),
                n = Ue(null),
                i = Ue(!1),
                s = H({
                    get: () => t.modelValue,
                    set: (m) => {
                        e("input", m), e("update:modelValue", m), e("change", m)
                    },
                }),
                o = H(() =>
                    Array.isArray(t.modelValue) ? t.modelValue.indexOf(t.value) > -1 : JSON.stringify(t.modelValue) === JSON.stringify(t.value)
                ),
                a = cy(t),
                l = fy(t),
                c = uy(t)
            It(
                () => t.modelValue,
                (m) => {
                    e("input", m)
                }
            )
            const f = () => {
                    ;(i.value = !0), t.disabled || n.value.focus()
                },
                u = () => {
                    ;(i.value = !1), t.disabled || n.value.blur()
                },
                p = (m) => {
                    if (!Array.isArray(t.modelValue)) s.value = m ? t.value : t.uncheckedValue
                    else {
                        const y = t.modelValue
                        if (m) y.indexOf(t.value) < 0 && y.push(t.value)
                        else {
                            const v = y.indexOf(t.value)
                            v > -1 && y.splice(v, 1)
                        }
                        s.value = y
                    }
                }
            return (
                t.autofocus &&
                    Zt(() => {
                        n.value.focus()
                    }),
                {
                    input: n,
                    computedId: r,
                    classes: a,
                    inputClasses: l,
                    labelClasses: c,
                    localChecked: s,
                    isChecked: o,
                    isFocused: i,
                    handleClick: p,
                    focus: f,
                    blur: u,
                }
            )
        },
    }),
    BN = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate", "checked"],
    ON = ["for"]
function MN(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "div",
            { class: ye(t.classes) },
            [
                He(
                    "input",
                    Je({ id: t.computedId }, t.$attrs, {
                        ref: "input",
                        class: t.inputClasses,
                        type: "checkbox",
                        disabled: t.disabled,
                        required: t.name && t.required,
                        name: t.name,
                        form: t.form,
                        "aria-label": t.ariaLabel,
                        "aria-labelledby": t.ariaLabelledBy,
                        "aria-required": t.name && t.required ? "true" : null,
                        value: t.value,
                        indeterminate: t.indeterminate,
                        checked: t.isChecked,
                        onClick: e[0] || (e[0] = Kc((o) => t.handleClick(o.target.checked), ["stop"])),
                        onFocus: e[1] || (e[1] = (o) => t.focus()),
                        onBlur: e[2] || (e[2] = (o) => t.blur()),
                    }),
                    null,
                    16,
                    BN
                ),
                t.$slots.default || !t.plain
                    ? (K(),
                      ue(
                          "label",
                          { key: 0, for: t.computedId, class: ye([t.labelClasses, { active: t.isChecked, focus: t.isFocused }]) },
                          [ge(t.$slots, "default")],
                          10,
                          ON
                      ))
                    : Be("", !0),
            ],
            2
        )
    )
}
var RN = xe($N, [["render", MN]])
const LN = be({
        name: "BFormCheckboxGroup",
        props: {
            modelValue: { type: Array, default: () => [] },
            ariaInvalid: { type: [Boolean, String], default: null },
            autofocus: { type: Boolean, default: !1 },
            buttonVariant: { type: String, default: "secondary" },
            buttons: { type: Boolean, default: !1 },
            disabled: { type: Boolean, default: !1 },
            disabledField: { type: String, default: "disabled" },
            form: { type: String },
            htmlField: { type: String, default: "html" },
            id: { type: String },
            name: { type: String },
            options: { type: Array, default: () => [] },
            plain: { type: Boolean, default: !1 },
            required: { type: Boolean, default: !1 },
            size: { type: String },
            stacked: { type: Boolean, default: !1 },
            state: { type: Boolean, default: null },
            switches: { type: Boolean, default: !1 },
            textField: { type: String, default: "text" },
            validated: { type: Boolean, default: !1 },
            valueField: { type: String, default: "value" },
        },
        emits: ["update:modelValue", "change", "input"],
        setup(t, { emit: e, slots: r }) {
            const n = "BFormCheckbox",
                i = gr(t.id, "checkbox"),
                s = gr(t.name, "checkbox"),
                o = H({
                    get: () => t.modelValue,
                    set: (u) => {
                        JSON.stringify(u) !== JSON.stringify(t.modelValue) && (e("input", u), e("update:modelValue", u), e("change", u))
                    },
                }),
                a = H(() =>
                    (r.first ? $c(r.first(), n, t.disabled) : [])
                        .concat(t.options.map((u) => py(u, t)))
                        .concat(r.default ? $c(r.default(), n, t.disabled) : [])
                        .map((u, p) => gy(u, p, t, s, i))
                        .map((u) => {
                            var p
                            return Rt(Me({}, u), {
                                model: t.modelValue.find((m) => {
                                    var y
                                    return ((y = u.props) == null ? void 0 : y.value) === m
                                })
                                    ? (p = u.props) == null
                                        ? void 0
                                        : p.value
                                    : !1,
                                props: Me({ switch: t.switches }, u.props),
                            })
                        })
                ),
                l = (u, p) => {
                    const m = t.modelValue.filter((y) => JSON.stringify(y) !== JSON.stringify(p))
                    JSON.stringify(u) === JSON.stringify(p) && m.push(u), e("update:modelValue", m), e("change", m)
                },
                c = dy(t),
                f = hy(t)
            return (
                It(
                    () => t.modelValue,
                    (u) => {
                        e("input", u)
                    }
                ),
                { attrs: c, classes: f, checkboxList: a, childUpdated: l, computedId: i, localChecked: o }
            )
        },
    }),
    DN = ["id"],
    FN = ["innerHTML"],
    VN = ["textContent"]
function UN(t, e, r, n, i, s) {
    const o = Qt("b-form-checkbox")
    return (
        K(),
        ue(
            "div",
            Je(t.attrs, { id: t.computedId, role: "group", class: [t.classes, "bv-no-focus-ring"], tabindex: "-1" }),
            [
                (K(!0),
                ue(
                    Nt,
                    null,
                    Pn(
                        t.checkboxList,
                        (a, l) => (
                            K(),
                            we(
                                o,
                                Je({ key: l, modelValue: a.model, "onUpdate:modelValue": (c) => (a.model = c) }, a.props, {
                                    onChange: (c) => {
                                        var f
                                        return t.childUpdated(c, (f = a.props) == null ? void 0 : f.value)
                                    },
                                }),
                                {
                                    default: Te(() => [
                                        a.html
                                            ? (K(), ue("span", { key: 0, innerHTML: a.html }, null, 8, FN))
                                            : (K(), ue("span", { key: 1, textContent: tt(a.text) }, null, 8, VN)),
                                    ]),
                                    _: 2,
                                },
                                1040,
                                ["modelValue", "onUpdate:modelValue", "onChange"]
                            )
                        )
                    ),
                    128
                )),
            ],
            16,
            DN
        )
    )
}
var HN = xe(LN, [["render", UN]])
const qN = be({ name: "BFormFloatingLabel", props: { labelFor: { type: String }, label: { type: String } } }),
    jN = { class: "form-floating" },
    zN = ["for"]
function KN(t, e, r, n, i, s) {
    return K(), ue("div", jN, [ge(t.$slots, "default"), He("label", { for: t.labelFor }, tt(t.label), 9, zN)])
}
var GN = xe(qN, [["render", KN]])
const Pu = (t) => "\\" + t,
    WN = (t) => {
        t = kd(t)
        const e = t.length,
            r = t.charCodeAt(0)
        return t.split("").reduce((n, i, s) => {
            const o = t.charCodeAt(s)
            return o === 0
                ? n + "\uFFFD"
                : o === 127 || (o >= 1 && o <= 31) || (s === 0 && o >= 48 && o <= 57) || (s === 1 && o >= 48 && o <= 57 && r === 45)
                ? n + Pu(`${o.toString(16)} `)
                : s === 0 && o === 45 && e === 1
                ? n + Pu(i)
                : o >= 128 || o === 45 || o === 95 || (o >= 48 && o <= 57) || (o >= 65 && o <= 90) || (o >= 97 && o <= 122)
                ? n + i
                : n + Pu(i)
        }, "")
    },
    $r = (t, e = {}, r = {}) => {
        const n = [t]
        let i
        for (let s = 0; s < n.length && !i; s++) {
            const o = n[s]
            i = r[o]
        }
        return i && Jv(i) ? i(e) : i
    },
    JN = be({
        name: "BFormValidFeedback",
        props: {
            ariaLive: { type: String, required: !1 },
            forceShow: { type: Boolean, default: !1 },
            id: { type: String, required: !1 },
            role: { type: String, required: !1 },
            state: { type: Boolean, default: void 0 },
            tag: { type: String, default: "div" },
            tooltip: { type: Boolean, default: !1 },
        },
        setup(t) {
            const e = H(() => t.forceShow === !0 || t.state === !0),
                r = H(() => ({ "d-block": e.value, "valid-feedback": !t.tooltip, "valid-tooltip": t.tooltip }))
            return {
                attrs: H(() => ({
                    id: t.id || null,
                    role: t.role || null,
                    "aria-live": t.ariaLive || null,
                    "aria-atomic": t.ariaLive ? "true" : null,
                })),
                classes: r,
                computedShow: e,
            }
        },
    })
function XN(t, e, r, n, i, s) {
    return K(), we(Ie(t.tag), Je({ class: t.classes }, t.attrs), { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 16, ["class"])
}
var Md = xe(JN, [["render", XN]])
const YN = be({
    name: "BFormInvalidFeedback",
    props: {
        ariaLive: { type: String, required: !1 },
        forceShow: { type: Boolean, default: !1 },
        id: { type: String, required: !1 },
        role: { type: String, required: !1 },
        state: { type: Boolean, default: void 0 },
        tag: { type: String, default: "div" },
        tooltip: { type: Boolean, default: !1 },
    },
    setup(t) {
        const e = H(() => t.forceShow === !0 || t.state === !1),
            r = H(() => ({ "d-block": e.value, "invalid-feedback": !t.tooltip, "invalid-tooltip": t.tooltip }))
        return {
            attrs: H(() => ({
                id: t.id || null,
                role: t.role || null,
                "aria-live": t.ariaLive || null,
                "aria-atomic": t.ariaLive ? "true" : null,
            })),
            classes: r,
            computedShow: e,
        }
    },
})
function ZN(t, e, r, n, i, s) {
    return K(), we(Ie(t.tag), Je({ class: t.classes }, t.attrs), { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 16, ["class"])
}
var Rd = xe(YN, [["render", ZN]])
const QN = be({ name: "BFormRow", props: { tag: { type: String, default: "div" } } })
function eP(t, e, r, n, i, s) {
    return K(), we(Ie(t.tag), { class: "row d-flex flex-wrap" }, { default: Te(() => [ge(t.$slots, "default")]), _: 3 })
}
var fc = xe(QN, [["render", eP]])
const tP = be({
    name: "BFormText",
    props: {
        id: { type: String, required: !1 },
        inline: { type: Boolean, default: !1 },
        tag: { type: String, default: "small" },
        textVariant: { type: String, default: "muted" },
    },
    setup(t) {
        const e = H(() => ({ "form-text": !t.inline, [`text-${t.textVariant}`]: t.textVariant }))
        return { attrs: H(() => ({ id: t.id || null })), classes: e }
    },
})
function rP(t, e, r, n, i, s) {
    return K(), we(Ie(t.tag), Je({ class: t.classes }, t.attrs), { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 16, ["class"])
}
var Ld = xe(tP, [["render", rP]])
const my = ["input", "select", "textarea"],
    nP = my.map((t) => `${t}:not([disabled])`).join(),
    iP = [...my, "a", "button", "label"],
    sP = "label",
    oP = "invalid-feedback",
    aP = "valid-feedback",
    lP = "description",
    cP = "default",
    fP = be({
        name: "BFormGroup",
        components: { BCol: va, BFormInvalidFeedback: Rd, BFormRow: fc, BFormText: Ld, BFormValidFeedback: Md },
        props: {
            contentCols: { type: [Boolean, String, Number], required: !1 },
            contentColsLg: { type: [Boolean, String, Number], required: !1 },
            contentColsMd: { type: [Boolean, String, Number], required: !1 },
            contentColsSm: { type: [Boolean, String, Number], required: !1 },
            contentColsXl: { type: [Boolean, String, Number], required: !1 },
            description: { type: [String], required: !1 },
            disabled: { type: Boolean, default: !1 },
            feedbackAriaLive: { type: String, default: "assertive" },
            id: { type: String, required: !1 },
            invalidFeedback: { type: String, required: !1 },
            label: { type: String, required: !1 },
            labelAlign: { type: [Boolean, String, Number], required: !1 },
            labelAlignLg: { type: [Boolean, String, Number], required: !1 },
            labelAlignMd: { type: [Boolean, String, Number], required: !1 },
            labelAlignSm: { type: [Boolean, String, Number], required: !1 },
            labelAlignXl: { type: [Boolean, String, Number], required: !1 },
            labelClass: { type: [Array, Object, String], required: !1 },
            labelCols: { type: [Boolean, String, Number], required: !1 },
            labelColsLg: { type: [Boolean, String, Number], required: !1 },
            labelColsMd: { type: [Boolean, String, Number], required: !1 },
            labelColsSm: { type: [Boolean, String, Number], required: !1 },
            labelColsXl: { type: [Boolean, String, Number], required: !1 },
            labelFor: { type: String, required: !1 },
            labelSize: { type: String, required: !1 },
            labelSrOnly: { type: Boolean, default: !1 },
            state: { type: Boolean, default: null },
            tooltip: { type: Boolean, default: !1 },
            validFeedback: { type: String, required: !1 },
            validated: { type: Boolean, default: !1 },
            floating: { type: Boolean, default: !1 },
        },
        setup(t, { attrs: e }) {
            const n = ["xs", "sm", "md", "lg", "xl"],
                i = (_, C) =>
                    n.reduce((R, U) => {
                        const D = _[gm(U, `${C}Align`)] || null
                        return D && R.push(["text", U, D].filter((Y) => Y).join("-")), R
                    }, []),
                s = (_, C) =>
                    n.reduce((R, U) => {
                        let D = _[gm(U, `${C}Cols`)]
                        return (
                            (D = D === "" ? !0 : D || !1),
                            !ku(D) && D !== "auto" && ((D = HT(D, 0)), (D = D > 0 ? D : !1)),
                            D && (R[U || (ku(D) ? "col" : "cols")] = D),
                            R
                        )
                    }, {}),
                o = Ue(),
                a = (_, C = null) => {
                    if (pT && t.labelFor) {
                        const B = kT(`#${WN(t.labelFor)}`, o)
                        if (B) {
                            const R = "aria-describedby",
                                U = (_ || "").split(cc),
                                D = (C || "").split(cc),
                                Y = (Zv(B, R) || "")
                                    .split(cc)
                                    .filter((J) => !fT(D, J))
                                    .concat(U)
                                    .filter((J, te, G) => G.indexOf(J) === te)
                                    .filter((J) => J)
                                    .join(" ")
                                    .trim()
                            Y ? PT(B, R, Y) : IT(B, R)
                        }
                    }
                },
                l = H(() => s(t, "content")),
                c = H(() => i(t, "label")),
                f = H(() => s(t, "label")),
                u = H(() => Object.keys(l.value).length > 0 || Object.keys(f.value).length > 0),
                p = H(() => (ku(t.state) ? t.state : null)),
                m = H(() => {
                    const _ = p.value
                    return _ === !0 ? "is-valid" : _ === !1 ? "is-invalid" : null
                }),
                y = H(() =>
                    e.ariaInvalid === !0 || e.ariaInvalid === "true" || e.ariaInvalid === "" || p.value === !1 ? "true" : e.ariaInvalid
                )
            return (
                It(
                    () => null,
                    (_, C) => {
                        _ !== C && a(_, C)
                    }
                ),
                Zt(() => {
                    kn(() => {
                        a(null)
                    })
                }),
                {
                    ariaDescribedby: null,
                    computedAriaInvalid: y,
                    contentColProps: l,
                    isHorizontal: u,
                    labelAlignClasses: c,
                    labelColProps: f,
                    onLegendClick: (_) => {
                        if (t.labelFor) return
                        const { target: C } = _,
                            B = C ? C.tagName : ""
                        if (iP.indexOf(B) !== -1) return
                        const R = NT(nP, o).filter(CT)
                        R.length === 1 && AT(R[0])
                    },
                    stateClass: m,
                }
            )
        },
        render() {
            const t = this.$props,
                e = this.$slots,
                r = gr(),
                n = !t.labelFor
            let i = null
            const s = $r(sP, {}, e) || t.label,
                o = s ? ei("_BV_label_") : null
            if (s || this.isHorizontal) {
                const U = n ? "legend" : "label"
                if (t.labelSrOnly)
                    s && (i = Ae(U, { class: "visually-hidden", id: o, for: t.labelFor || null }, s)),
                        this.isHorizontal ? (i = Ae(va, this.labelColProps, { default: () => i })) : (i = Ae("div", {}, [i]))
                else {
                    const D = Rt(Me({ onClick: n ? this.onLegendClick : null }, this.isHorizontal ? this.labelColProps : {}), {
                        tag: this.isHorizontal ? U : null,
                        id: o,
                        for: t.labelFor || null,
                        tabIndex: n ? "-1" : null,
                        class: [
                            {
                                "bv-no-focus-ring": n,
                                "col-form-label": this.isHorizontal || n,
                                "pt-0": !this.isHorizontal && n,
                                "d-block": !this.isHorizontal && !n,
                                [`col-form-label-${t.labelSize}`]: !!t.labelSize,
                            },
                            this.labelAlignClasses,
                            t.labelClass,
                        ],
                    })
                    this.isHorizontal ? (i = Ae(va, D, { default: () => s })) : (i = Ae(U, D, s))
                }
            }
            let a = null
            const l = $r(oP, {}, e) || this.invalidFeedback,
                c = l ? ei("_BV_feedback_invalid_") : null
            l &&
                (a = Ae(
                    Rd,
                    { ariaLive: t.feedbackAriaLive, id: c, state: t.state, tooltip: t.tooltip, tabindex: l ? "-1" : null },
                    { default: () => l }
                ))
            let f = null
            const u = $r(aP, {}, e) || this.validFeedback,
                p = u ? ei("_BV_feedback_valid_") : null
            u &&
                (f = Ae(
                    Md,
                    { ariaLive: t.feedbackAriaLive, id: p, state: t.state, tooltip: t.tooltip, tabindex: u ? "-1" : null },
                    { default: () => u }
                ))
            let m = null
            const y = $r(lP, {}, e) || this.description,
                v = y ? ei("_BV_description_") : null
            y && (m = Ae(Ld, { id: v, tabindex: "-1" }, { default: () => y }))
            const _ = (this.ariaDescribedby = [v, t.state === !1 ? c : null, t.state === !0 ? p : null].filter((U) => U).join(" ") || null),
                C = [$r(cP, { ariaDescribedby: _, descriptionId: v, id: r, labelId: o }, e) || "", a, f, m]
            !this.isHorizontal && t.floating && C.push(i)
            let B = Ae("div", { ref: "content", class: [{ "form-floating": !this.isHorizontal && t.floating }] }, C)
            this.isHorizontal && (B = Ae(va, Me({ ref: "content" }, this.contentColProps), { default: () => C }))
            const R = {
                class: ["mb-3", this.stateClass, { "was-validated": t.validated }],
                id: gr(t.id).value,
                disabled: n ? t.disabled : null,
                role: n ? null : "group",
                "aria-invalid": this.computedAriaInvalid,
                "aria-labelledby": n && this.isHorizontal ? o : null,
            }
            return this.isHorizontal && !n
                ? Ae(fc, R, { default: () => [i, B] })
                : Ae(
                      n ? "fieldset" : "div",
                      R,
                      this.isHorizontal && n ? [Ae(fc, {}, { default: () => [i, B] })] : this.isHorizontal || !t.floating ? [i, B] : [B]
                  )
        },
    }),
    by = {
        ariaInvalid: { type: [Boolean, String], default: !1 },
        autocomplete: { type: String, required: !1 },
        autofocus: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        form: { type: String, required: !1 },
        formatter: { type: Function, required: !1 },
        id: { type: String, required: !1 },
        lazy: { type: Boolean, default: !1 },
        lazyFormatter: { type: Boolean, default: !1 },
        list: { type: String, required: !1 },
        modelValue: { type: [String, Number], default: "" },
        name: { type: String, required: !1 },
        number: { type: Boolean, default: !1 },
        placeholder: { type: String, required: !1 },
        plaintext: { type: Boolean, default: !1 },
        readonly: { type: Boolean, default: !1 },
        required: { type: Boolean, default: !1 },
        size: { type: String, required: !1 },
        state: { type: Boolean, default: null },
        trim: { type: Boolean, default: !1 },
    }
function xy(t, e) {
    const r = Ue()
    let n = null,
        i = !0
    const s = gr(t.id, "input"),
        o = (v, _, C = !1) => ((v = String(v)), typeof t.formatter == "function" && (!t.lazyFormatter || C) ? ((i = !1), t.formatter(v, _)) : v),
        a = (v) => (t.trim ? v.trim() : t.number ? parseFloat(v) : v),
        l = () => {
            kn(() => {
                var v
                t.autofocus && ((v = r.value) == null || v.focus())
            })
        }
    Zt(l),
        Zt(() => {
            r.value && (r.value.value = t.modelValue)
        }),
        n0(l)
    const c = H(() => (t.ariaInvalid ? t.ariaInvalid.toString() : t.state === !1 ? "true" : void 0)),
        f = (v) => {
            const { value: _ } = v.target,
                C = o(_, v)
            if (C === !1 || v.defaultPrevented) {
                v.preventDefault()
                return
            }
            if (t.lazy) return
            e("input", C)
            const B = a(C)
            t.modelValue !== B && ((n = _), e("update:modelValue", B))
        },
        u = (v) => {
            const { value: _ } = v.target,
                C = o(_, v)
            if (C === !1 || v.defaultPrevented) {
                v.preventDefault()
                return
            }
            if (!t.lazy) return
            ;(n = _), e("update:modelValue", C)
            const B = a(C)
            t.modelValue !== B && e("change", C)
        },
        p = (v) => {
            if ((e("blur", v), !t.lazy && !t.lazyFormatter)) return
            const { value: _ } = v.target,
                C = o(_, v, !0)
            ;(n = _), e("update:modelValue", C)
        },
        m = () => {
            var v
            t.disabled || (v = r.value) == null || v.focus()
        },
        y = () => {
            var v
            t.disabled || (v = r.value) == null || v.blur()
        }
    return (
        It(
            () => t.modelValue,
            (v) => {
                !r.value || ((r.value.value = n && i ? n : v), (n = null), (i = !0))
            }
        ),
        { input: r, computedId: s, computedAriaInvalid: c, onInput: f, onChange: u, onBlur: p, focus: m, blur: y }
    )
}
const _m = ["text", "number", "email", "password", "search", "url", "tel", "date", "time", "range", "color"],
    uP = be({
        name: "BFormInput",
        props: Rt(Me({}, by), {
            max: { type: [String, Number], required: !1 },
            min: { type: [String, Number], required: !1 },
            step: { type: [String, Number], required: !1 },
            type: { type: String, default: "text", validator: (t) => _m.includes(t) },
        }),
        emits: ["update:modelValue", "change", "blur", "input"],
        setup(t, { emit: e }) {
            const r = H(() => {
                    const p = t.type === "range",
                        m = t.type === "color"
                    return {
                        "form-range": p,
                        "form-control": m || (!t.plaintext && !p),
                        "form-control-color": m,
                        "form-control-plaintext": t.plaintext && !p && !m,
                        [`form-control-${t.size}`]: t.size,
                        "is-valid": t.state === !0,
                        "is-invalid": t.state === !1,
                    }
                }),
                n = H(() => (_m.includes(t.type) ? t.type : "text")),
                { input: i, computedId: s, computedAriaInvalid: o, onInput: a, onChange: l, onBlur: c, focus: f, blur: u } = xy(t, e)
            return {
                classes: r,
                localType: n,
                input: i,
                computedId: s,
                computedAriaInvalid: o,
                onInput: a,
                onChange: l,
                onBlur: c,
                focus: f,
                blur: u,
            }
        },
    }),
    dP = [
        "id",
        "name",
        "form",
        "type",
        "disabled",
        "placeholder",
        "required",
        "autocomplete",
        "readonly",
        "min",
        "max",
        "step",
        "list",
        "aria-required",
        "aria-invalid",
    ]
function hP(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "input",
            Je(
                {
                    id: t.computedId,
                    ref: "input",
                    class: t.classes,
                    name: t.name || void 0,
                    form: t.form || void 0,
                    type: t.localType,
                    disabled: t.disabled,
                    placeholder: t.placeholder,
                    required: t.required,
                    autocomplete: t.autocomplete || void 0,
                    readonly: t.readonly || t.plaintext,
                    min: t.min,
                    max: t.max,
                    step: t.step,
                    list: t.type !== "password" ? t.list : void 0,
                    "aria-required": t.required ? "true" : void 0,
                    "aria-invalid": t.computedAriaInvalid,
                },
                t.$attrs,
                {
                    onInput: e[0] || (e[0] = (o) => t.onInput(o)),
                    onChange: e[1] || (e[1] = (o) => t.onChange(o)),
                    onBlur: e[2] || (e[2] = (o) => t.onBlur(o)),
                }
            ),
            null,
            16,
            dP
        )
    )
}
var pP = xe(uP, [["render", hP]])
const gP = be({
        name: "BFormRadio",
        props: {
            ariaLabel: { type: String },
            ariaLabelledBy: { type: String },
            autofocus: { type: Boolean, default: !1 },
            modelValue: { type: [Boolean, String, Array, Object, Number], default: null },
            plain: { type: Boolean, default: !1 },
            button: { type: Boolean, default: !1 },
            switch: { type: Boolean, default: !1 },
            disabled: { type: Boolean, default: !1 },
            buttonVariant: { type: String, default: "secondary" },
            form: { type: String },
            id: { type: String },
            inline: { type: Boolean, default: !1 },
            name: { type: String },
            required: { type: Boolean, default: !1 },
            size: { type: String },
            state: { type: Boolean, default: null },
            value: { type: [String, Boolean, Object, Number], default: !0 },
        },
        emits: ["update:modelValue", "change", "input"],
        setup(t, { emit: e }) {
            const r = gr(t.id, "form-check"),
                n = Ue(null),
                i = Ue(!1),
                s = H({
                    get: () => t.modelValue,
                    set: (m) => {
                        e("input", m), e("change", m), e("update:modelValue", m)
                    },
                }),
                o = () => {
                    ;(i.value = !0), t.disabled || n.value.focus()
                },
                a = () => {
                    ;(i.value = !1), t.disabled || n.value.blur()
                },
                l = H(() =>
                    Array.isArray(t.modelValue)
                        ? (t.modelValue || []).find((m) => m === t.value)
                        : JSON.stringify(t.modelValue) === JSON.stringify(t.value)
                ),
                c = cy(t),
                f = fy(t),
                u = uy(t),
                p = async (m) => {
                    Array.isArray(t.modelValue)
                        ? (t.modelValue || [])[0] !== t.value && (s.value = [t.value])
                        : m && t.modelValue !== t.value && (s.value = t.value)
                }
            return (
                It(
                    () => t.modelValue,
                    (m) => {
                        e("input", m)
                    }
                ),
                t.autofocus &&
                    Zt(() => {
                        n.value.focus()
                    }),
                {
                    localChecked: s,
                    computedId: r,
                    classes: c,
                    inputClasses: f,
                    labelClasses: u,
                    isChecked: l,
                    isFocused: i,
                    input: n,
                    handleClick: p,
                    focus: o,
                    blur: a,
                }
            )
        },
    }),
    mP = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "checked", "aria-required"],
    bP = ["for"]
function xP(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "div",
            { class: ye(t.classes) },
            [
                He(
                    "input",
                    Je({ id: t.computedId }, t.$attrs, {
                        ref: "input",
                        class: t.inputClasses,
                        type: "radio",
                        disabled: t.disabled,
                        required: t.name && t.required,
                        name: t.name,
                        form: t.form,
                        "aria-label": t.ariaLabel,
                        "aria-labelledby": t.ariaLabelledBy,
                        value: t.value,
                        checked: t.isChecked,
                        "aria-required": t.name && t.required ? "true" : null,
                        onClick: e[0] || (e[0] = Kc((o) => t.handleClick(o.target.checked), ["stop"])),
                        onFocus: e[1] || (e[1] = (...o) => t.focus && t.focus(...o)),
                        onBlur: e[2] || (e[2] = (...o) => t.blur && t.blur(...o)),
                    }),
                    null,
                    16,
                    mP
                ),
                t.$slots.default || !t.plain
                    ? (K(),
                      ue(
                          "label",
                          { key: 0, for: t.computedId, class: ye([t.labelClasses, { active: t.isChecked, focus: t.isFocused }]) },
                          [ge(t.$slots, "default")],
                          10,
                          bP
                      ))
                    : Be("", !0),
            ],
            2
        )
    )
}
var vP = xe(gP, [["render", xP]])
const yP = be({
        name: "BFormRadioGroup",
        props: {
            modelValue: { type: [String, Boolean, Array, Object, Number], default: "" },
            ariaInvalid: { type: [Boolean, String], default: null },
            autofocus: { type: Boolean, default: !1 },
            buttonVariant: { type: String, default: "secondary" },
            buttons: { type: Boolean, default: !1 },
            disabled: { type: Boolean, default: !1 },
            disabledField: { type: String, default: "disabled" },
            form: { type: String },
            htmlField: { type: String, default: "html" },
            id: { type: String },
            name: { type: String },
            options: { type: Array, default: () => [] },
            plain: { type: Boolean, default: !1 },
            required: { type: Boolean, default: !1 },
            size: { type: String },
            stacked: { type: Boolean, default: !1 },
            state: { type: Boolean, default: null },
            textField: { type: String, default: "text" },
            validated: { type: Boolean, default: !1 },
            valueField: { type: String, default: "value" },
        },
        emits: ["update:modelValue", "input", "change"],
        setup(t, { emit: e, slots: r }) {
            const n = "BFormRadio",
                i = gr(t.id, "radio"),
                s = gr(t.name, "checkbox"),
                o = H({
                    get: () => t.modelValue,
                    set: (u) => {
                        e("input", u), e("update:modelValue", u), e("change", u)
                    },
                }),
                a = H(() =>
                    (r.first ? $c(r.first(), n, t.disabled) : [])
                        .concat(t.options.map((u) => py(u, t)))
                        .concat(r.default ? $c(r.default(), n, t.disabled) : [])
                        .map((u, p) => gy(u, p, t, s, i))
                        .map((u) => {
                            var p, m
                            return Rt(Me({}, u), {
                                model:
                                    JSON.stringify(t.modelValue) === JSON.stringify((p = u.props) == null ? void 0 : p.value)
                                        ? (m = u.props) == null
                                            ? void 0
                                            : m.value
                                        : null,
                            })
                        })
                ),
                l = (u) => {
                    e("change", u), e("update:modelValue", u)
                },
                c = dy(t),
                f = hy(t)
            return { attrs: c, classes: f, checkboxList: a, childUpdated: l, computedId: i, localChecked: o }
        },
    }),
    _P = ["id"],
    wP = ["innerHTML"],
    EP = ["textContent"]
function SP(t, e, r, n, i, s) {
    const o = Qt("b-form-radio")
    return (
        K(),
        ue(
            "div",
            Je(t.attrs, { id: t.computedId, role: "radiogroup", class: [t.classes, "bv-no-focus-ring"], tabindex: "-1" }),
            [
                (K(!0),
                ue(
                    Nt,
                    null,
                    Pn(
                        t.checkboxList,
                        (a, l) => (
                            K(),
                            we(
                                o,
                                Je({ key: l, modelValue: a.model, "onUpdate:modelValue": (c) => (a.model = c) }, a.props, {
                                    onChange: t.childUpdated,
                                }),
                                {
                                    default: Te(() => [
                                        a.html
                                            ? (K(), ue("span", { key: 0, innerHTML: a.html }, null, 8, wP))
                                            : (K(), ue("span", { key: 1, textContent: tt(a.text) }, null, 8, EP)),
                                    ]),
                                    _: 2,
                                },
                                1040,
                                ["modelValue", "onUpdate:modelValue", "onChange"]
                            )
                        )
                    ),
                    128
                )),
            ],
            16,
            _P
        )
    )
}
var AP = xe(yP, [["render", SP]])
const TP = be({ name: "BFormSelectOption", props: { value: { required: !0 }, disabled: { type: Boolean, default: !1 } } }),
    CP = ["value", "disabled"]
function kP(t, e, r, n, i, s) {
    var o
    return K(), ue("option", { value: (o = t.value) != null ? o : "", disabled: t.disabled }, [ge(t.$slots, "default")], 8, CP)
}
var ah = xe(TP, [["render", kP]])
const lo = (t, e) => {
        if (!t) return t
        if (e in t) return t[e]
        const r = e.split(".")
        return lo(t[r[0]], r.splice(1).join("."))
    },
    Iu = (t, e = null, r, n) => {
        if (Object.prototype.toString.call(t) === "[object Object]") {
            const i = lo(t, n.valueField),
                s = lo(t, n.textField),
                o = lo(t, n.htmlField),
                a = lo(t, n.disabledField),
                l = t[n.optionsField] || null
            return l !== null
                ? { label: String(lo(t, n.labelField) || s), options: lh(l, r, n) }
                : { value: typeof i == "undefined" ? e || s : i, text: String(typeof s == "undefined" ? e : s), html: o, disabled: Boolean(a) }
        }
        return { value: e || t, text: String(t), disabled: !1 }
    },
    lh = (t, e, r) =>
        Array.isArray(t)
            ? t.map((n) => Iu(n, null, e, r))
            : Object.prototype.toString.call(t) === "[object Object]"
            ? (console.warn(`[BootstrapVue warn]: ${e} - Setting prop "options" to an object is deprecated. Use the array format instead.`),
              Object.keys(t).map((n) => {
                  const i = t[n]
                  switch (typeof i) {
                      case "object":
                          return Iu(i.text, String(i.value), e, r)
                      default:
                          return Iu(i, String(n), e, r)
                  }
              }))
            : [],
    NP = be({
        name: "BFormSelectOptionGroup",
        components: { BFormSelectOption: ah },
        props: {
            label: { type: String, required: !0 },
            disabledField: { type: String, default: "disabled" },
            htmlField: { type: String, default: "html" },
            options: { type: [Array, Object], default: () => [] },
            textField: { type: String, default: "text" },
            valueField: { type: String, default: "value" },
        },
        setup(t) {
            return { formOptions: H(() => lh(t.options, "BFormSelectOptionGroup", t)) }
        },
    }),
    PP = ["label"]
function IP(t, e, r, n, i, s) {
    const o = Qt("b-form-select-option")
    return (
        K(),
        ue(
            "optgroup",
            { label: t.label },
            [
                ge(t.$slots, "first"),
                (K(!0),
                ue(
                    Nt,
                    null,
                    Pn(
                        t.formOptions,
                        (a, l) => (
                            K(),
                            we(
                                o,
                                Je({ key: `option_${l}`, value: a.value, disabled: a.disabled }, t.$attrs, { innerHTML: a.html || a.text }),
                                null,
                                16,
                                ["value", "disabled", "innerHTML"]
                            )
                        )
                    ),
                    128
                )),
                ge(t.$slots, "default"),
            ],
            8,
            PP
        )
    )
}
var vy = xe(NP, [["render", IP]])
const $P = be({
        name: "BFormSelect",
        components: { BFormSelectOption: ah, BFormSelectOptionGroup: vy },
        props: {
            ariaInvalid: { type: [Boolean, String], default: !1 },
            autofocus: { type: Boolean, default: !1 },
            disabled: { type: Boolean, default: !1 },
            disabledField: { type: String, default: "disabled" },
            form: { type: String, required: !1 },
            htmlField: { type: String, default: "html" },
            id: { type: String, required: !1 },
            labelField: { type: String, default: "label" },
            multiple: { type: Boolean, default: !1 },
            name: { type: String, required: !1 },
            options: { type: [Array, Object], default: () => [] },
            optionsField: { type: String, default: "options" },
            plain: { type: Boolean, default: !1 },
            required: { type: Boolean, default: !1 },
            selectSize: { type: Number, default: 0 },
            size: { type: String, required: !1 },
            state: { type: Boolean, default: null },
            textField: { type: String, default: "text" },
            valueField: { type: String, default: "value" },
            modelValue: { type: [String, Array, Object, Number], default: "" },
        },
        emits: ["update:modelValue", "change", "input"],
        setup(t, { emit: e }) {
            const r = Ue(),
                n = gr(t.id, "input"),
                i = () => {
                    kn(() => {
                        var p
                        t.autofocus && ((p = r.value) == null || p.focus())
                    })
                }
            Zt(i), n0(i)
            const s = H(() => ({
                    "form-control": t.plain,
                    [`form-control-${t.size}`]: t.size && t.plain,
                    "form-select": !t.plain,
                    [`form-select-${t.size}`]: t.size && !t.plain,
                    "is-valid": t.state === !0,
                    "is-invalid": t.state === !1,
                })),
                o = H(() => (t.selectSize || t.plain ? t.selectSize : null)),
                a = H(() => (t.ariaInvalid ? t.ariaInvalid.toString() : t.state === !1 ? "true" : null)),
                l = H(() => lh(t.options, "BFormSelect", t)),
                c = (p) => {
                    const { target: m } = p,
                        y = Array.from(m.options)
                            .filter((v) => v.selected)
                            .map((v) => ("_value" in v ? v._value : v.value))
                    kn(() => {
                        e("change", m.multiple ? y : y[0]), e("update:modelValue", m.multiple ? y : y[0])
                    })
                },
                f = () => {
                    var p
                    t.disabled || (p = r.value) == null || p.focus()
                },
                u = () => {
                    var p
                    t.disabled || (p = r.value) == null || p.blur()
                }
            return (
                It(
                    () => t.modelValue,
                    (p) => {
                        e("input", p)
                    }
                ),
                {
                    input: r,
                    computedId: n,
                    computedSelectSize: o,
                    computedAriaInvalid: a,
                    classes: s,
                    formOptions: l,
                    onChange: c,
                    focus: f,
                    blur: u,
                }
            )
        },
    }),
    BP = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid", "value"]
function OP(t, e, r, n, i, s) {
    const o = Qt("b-form-select-option-group"),
        a = Qt("b-form-select-option")
    return (
        K(),
        ue(
            "select",
            Je(
                {
                    id: t.computedId,
                    ref: "input",
                    class: t.classes,
                    name: t.name,
                    form: t.form || null,
                    multiple: t.multiple || null,
                    size: t.computedSelectSize,
                    disabled: t.disabled,
                    required: t.required,
                    "aria-required": t.required ? "true" : null,
                    "aria-invalid": t.computedAriaInvalid,
                },
                t.$attrs,
                { value: t.modelValue, onChange: e[0] || (e[0] = (l) => t.onChange(l)) }
            ),
            [
                ge(t.$slots, "first"),
                (K(!0),
                ue(
                    Nt,
                    null,
                    Pn(
                        t.formOptions,
                        (l, c) => (
                            K(),
                            ue(
                                Nt,
                                null,
                                [
                                    Array.isArray(l.options)
                                        ? (K(), we(o, { key: `option_${c}`, label: l.label, options: l.options }, null, 8, ["label", "options"]))
                                        : (K(),
                                          we(
                                              a,
                                              { key: `option2_${c}`, value: l.value, disabled: l.disabled, innerHTML: l.html || l.text },
                                              null,
                                              8,
                                              ["value", "disabled", "innerHTML"]
                                          )),
                                ],
                                64
                            )
                        )
                    ),
                    256
                )),
                ge(t.$slots, "default"),
            ],
            16,
            BP
        )
    )
}
var MP = xe($P, [["render", OP]])
const RP = be({
        name: "BFormTextarea",
        props: Rt(Me({}, by), {
            noResize: { type: Boolean, default: !1 },
            rows: { type: [String, Number], required: !1, default: 2 },
            wrap: { type: String, default: "soft" },
        }),
        emits: ["update:modelValue", "change", "blur", "input"],
        setup(t, { emit: e }) {
            const r = H(() => ({
                    "form-control": !t.plaintext,
                    "form-control-plaintext": t.plaintext,
                    [`form-control-${t.size}`]: t.size,
                    "is-valid": t.state === !0,
                    "is-invalid": t.state === !1,
                })),
                n = H(() => (t.noResize ? { resize: "none" } : void 0)),
                { input: i, computedId: s, computedAriaInvalid: o, onInput: a, onChange: l, onBlur: c, focus: f, blur: u } = xy(t, e)
            return {
                input: i,
                computedId: s,
                computedAriaInvalid: o,
                onInput: a,
                onChange: l,
                onBlur: c,
                focus: f,
                blur: u,
                classes: r,
                computedStyles: n,
            }
        },
    }),
    LP = [
        "id",
        "name",
        "form",
        "disabled",
        "placeholder",
        "required",
        "autocomplete",
        "readonly",
        "aria-required",
        "aria-invalid",
        "rows",
        "wrap",
    ]
function DP(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "textarea",
            Je(
                {
                    id: t.computedId,
                    ref: "input",
                    class: t.classes,
                    name: t.name || void 0,
                    form: t.form || void 0,
                    disabled: t.disabled,
                    placeholder: t.placeholder,
                    required: t.required,
                    autocomplete: t.autocomplete || void 0,
                    readonly: t.readonly || t.plaintext,
                    "aria-required": t.required ? "true" : void 0,
                    "aria-invalid": t.computedAriaInvalid,
                    rows: t.rows,
                    style: t.computedStyles,
                    wrap: t.wrap || void 0,
                },
                t.$attrs,
                {
                    onInput: e[0] || (e[0] = (o) => t.onInput(o)),
                    onChange: e[1] || (e[1] = (o) => t.onChange(o)),
                    onBlur: e[2] || (e[2] = (o) => t.onBlur(o)),
                }
            ),
            null,
            16,
            LP
        )
    )
}
var FP = xe(RP, [["render", DP]])
const VP =
        '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>',
    UP = (t, e, r) =>
        `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(VP.replace("%{w}", String(t)).replace("%{h}", String(e)).replace("%{f}", r))}`,
    HP = be({
        name: "BImg",
        props: {
            alt: { type: String, default: void 0 },
            blank: { type: Boolean, default: !1 },
            blankColor: { type: String, default: "transparent" },
            block: { type: Boolean, default: !1 },
            center: { type: Boolean, default: !1 },
            fluid: { type: Boolean, default: !1 },
            fluidGrow: { type: Boolean, default: !1 },
            height: { type: [Number, String], required: !1 },
            left: { type: Boolean, default: !1 },
            right: { type: Boolean, default: !1 },
            rounded: { type: [Boolean, String], default: !1 },
            sizes: { type: [String, Array], required: !1 },
            src: { type: String, required: !1 },
            srcset: { type: [String, Array], required: !1 },
            thumbnail: { type: Boolean, default: !1 },
            width: { type: [Number, String], required: !1 },
        },
        setup(t) {
            const e = H(() => {
                    let n = t.src,
                        i = (typeof t.width == "number" ? t.width : parseInt(t.width, 10)) || null,
                        s = (typeof t.height == "number" ? t.height : parseInt(t.height, 10)) || null,
                        o = ""
                    typeof t.srcset == "string"
                        ? (o = t.srcset
                              .split(",")
                              .filter((l) => l)
                              .join(","))
                        : Array.isArray(t.srcset) && (o = t.srcset.filter((l) => l).join(","))
                    let a = ""
                    return (
                        typeof t.sizes == "string"
                            ? (a = t.sizes
                                  .split(",")
                                  .filter((l) => l)
                                  .join(","))
                            : Array.isArray(t.sizes) && (a = t.sizes.filter((l) => l).join(",")),
                        t.blank &&
                            (!s && i ? (s = i) : !i && s && (i = s),
                            !i && !s && ((i = 1), (s = 1)),
                            (n = UP(i, s, t.blankColor || "transparent")),
                            (o = ""),
                            (a = "")),
                        { src: n, alt: t.alt, width: i || null, height: s || null, srcset: o || null, sizes: a || null }
                    )
                }),
                r = H(() => {
                    let n = "",
                        i = t.block
                    return (
                        t.left ? (n = "float-start") : t.right ? (n = "float-end") : t.center && ((n = "mx-auto"), (i = !0)),
                        {
                            "img-thumbnail": t.thumbnail,
                            "img-fluid": t.fluid || t.fluidGrow,
                            "w-100": t.fluidGrow,
                            rounded: t.rounded === "" || t.rounded === !0,
                            [`rounded-${t.rounded}`]: typeof t.rounded == "string" && t.rounded !== "",
                            [n]: !!n,
                            "d-block": i,
                        }
                    )
                })
            return { attrs: e, classes: r }
        },
    })
function qP(t, e, r, n, i, s) {
    return K(), ue("img", Je({ class: t.classes }, t.attrs), null, 16)
}
var jP = xe(HP, [["render", qP]])
const zP = be({
        name: "BInputGroup",
        props: {
            append: { type: String, required: !1 },
            appendHtml: { type: String, required: !1 },
            id: { type: String, required: !1 },
            prepend: { type: String, required: !1 },
            prependHtml: { type: String, required: !1 },
            size: { type: String, required: !1 },
            tag: { type: String, default: "div" },
        },
        setup(t) {
            const e = H(() => ({ "input-group-sm": t.size === "sm", "input-group-lg": t.size === "lg" })),
                r = H(() => t.append || t.appendHtml),
                n = H(() => t.prepend || t.prependHtml),
                i = H(() => !!t.appendHtml),
                s = H(() => !!t.prependHtml)
            return { classes: e, hasAppend: r, hasPrepend: n, showAppendHtml: i, showPrependHtml: s }
        },
    }),
    KP = { key: 0, class: "input-group-text" },
    GP = { key: 0 },
    WP = ["innerHTML"],
    JP = { key: 0, class: "input-group-text" },
    XP = { key: 0 },
    YP = ["innerHTML"]
function ZP(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tag),
            { id: t.id, class: ye(["input-group", t.classes]), role: "group" },
            {
                default: Te(() => [
                    ge(t.$slots, "prepend", {}, () => [
                        t.hasPrepend
                            ? (K(),
                              ue("span", KP, [
                                  t.showPrependHtml ? Be("", !0) : (K(), ue("span", GP, tt(t.prepend), 1)),
                                  t.showPrependHtml ? (K(), ue("span", { key: 1, innerHTML: t.prependHtml }, null, 8, WP)) : Be("", !0),
                              ]))
                            : Be("", !0),
                    ]),
                    ge(t.$slots, "default"),
                    ge(t.$slots, "append", {}, () => [
                        t.hasAppend
                            ? (K(),
                              ue("span", JP, [
                                  t.showAppendHtml ? Be("", !0) : (K(), ue("span", XP, tt(t.append), 1)),
                                  t.showAppendHtml ? (K(), ue("span", { key: 1, innerHTML: t.appendHtml }, null, 8, YP)) : Be("", !0),
                              ]))
                            : Be("", !0),
                    ]),
                ]),
                _: 3,
            },
            8,
            ["id", "class"]
        )
    )
}
var QP = xe(zP, [["render", ZP]])
const eI = be({ name: "BInputGroupText", props: { tag: { type: String, default: "div" } } })
function tI(t, e, r, n, i, s) {
    return K(), we(Ie(t.tag), { class: "input-group-text" }, { default: Te(() => [ge(t.$slots, "default")]), _: 3 })
}
var yy = xe(eI, [["render", tI]])
const rI = be({
    name: "BInputGroupAddon",
    components: { BInputGroupText: yy },
    props: {
        append: { type: Boolean, default: !1 },
        id: { type: String, required: !1 },
        isText: { type: Boolean, default: !1 },
        tag: { type: String, default: "div" },
    },
    setup(t) {
        return { computedClasses: H(() => ({ "input-group-append": t.append, "input-group-prepend": !t.append })) }
    },
})
function nI(t, e, r, n, i, s) {
    const o = Qt("b-input-group-text")
    return (
        K(),
        we(
            Ie(t.tag),
            { id: t.id, class: ye(["d-flex", t.computedClasses]) },
            {
                default: Te(() => [
                    t.isText ? (K(), we(o, { key: 0 }, { default: Te(() => [ge(t.$slots, "default")]), _: 3 })) : Be("", !0),
                    t.isText ? Be("", !0) : ge(t.$slots, "default", { key: 1 }),
                ]),
                _: 3,
            },
            8,
            ["id", "class"]
        )
    )
}
var ch = xe(rI, [["render", nI]])
const iI = be({
    name: "BInputGroupAppend",
    components: { BInputGroupAddon: ch },
    props: { id: { type: String, required: !1 }, isText: { type: Boolean, default: !1 }, tag: { type: String, default: "div" } },
})
function sI(t, e, r, n, i, s) {
    const o = Qt("b-input-group-addon")
    return (
        K(),
        we(o, { id: t.id, "is-text": t.isText, tag: t.tag, append: "" }, { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 8, [
            "id",
            "is-text",
            "tag",
        ])
    )
}
var oI = xe(iI, [["render", sI]])
const aI = be({
    name: "BInputGroupPrepend",
    components: { BInputGroupAddon: ch },
    props: { id: { type: String, required: !1 }, isText: { type: Boolean, default: !1 }, tag: { type: String, default: "div" } },
})
function lI(t, e, r, n, i, s) {
    const o = Qt("b-input-group-addon")
    return (
        K(),
        we(o, { id: t.id, "is-text": t.isText, tag: t.tag, append: !1 }, { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 8, [
            "id",
            "is-text",
            "tag",
        ])
    )
}
var cI = xe(aI, [["render", lI]])
const _y = Symbol(),
    fI = be({
        name: "BListGroup",
        props: {
            flush: { type: Boolean, default: !1 },
            horizontal: { type: [Boolean, String], default: !1 },
            numbered: { type: Boolean, default: !1 },
            tag: { type: String, default: "div" },
        },
        setup(t) {
            const e = H(() => {
                    const i = t.flush ? !1 : t.horizontal
                    return {
                        "list-group-flush": t.flush,
                        "list-group-horizontal": i === !0,
                        [`list-group-horizontal-${i}`]: typeof i == "string",
                        "list-group-numbered": t.numbered,
                    }
                }),
                r = () => (t.numbered === !0 ? "ol" : t.tag),
                n = Ue(r())
            return (
                It(
                    () => t.tag,
                    () => (n.value = r())
                ),
                It(
                    () => t.numbered,
                    () => (n.value = r())
                ),
                Nn(_y, { numbered: t.numbered }),
                { classes: e, computedTag: n }
            )
        },
    })
function uI(t, e, r, n, i, s) {
    return (
        K(),
        we(Ie(t.computedTag), { class: ye(["list-group", t.classes]) }, { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 8, ["class"])
    )
}
var dI = xe(fI, [["render", uI]])
const hI = ["a", "router-link", "button", "b-link"],
    pI = be({
        name: "BListGroupItem",
        props: {
            action: { type: Boolean, default: !1 },
            active: { type: Boolean, default: !1 },
            button: { type: Boolean, default: !1 },
            disabled: { type: Boolean, default: !1 },
            href: { type: String },
            tag: { type: String, default: "div" },
            target: { type: String, default: "_self" },
            variant: { type: String },
        },
        setup(t, e) {
            const r = sr(_y, null),
                n = H(() => !t.button && t.href),
                i = H(() => ((r == null ? void 0 : r.numbered) ? "li" : t.button ? "button" : n.value ? "a" : t.tag)),
                s = H(() => {
                    const a = t.action || n.value || t.button || hI.includes(t.tag)
                    return { [`list-group-item-${t.variant}`]: t.variant, "list-group-item-action": a, active: t.active, disabled: t.disabled }
                }),
                o = H(() => {
                    const a = {}
                    return t.button && ((!e.attrs || !e.attrs.type) && (a.type = "button"), t.disabled && (a.disabled = !0)), a
                })
            return { tagComputed: i, classes: s, attrs: o, link: n }
        },
    })
function gI(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tagComputed),
            Je(
                {
                    class: ["list-group-item", t.classes],
                    "aria-current": t.active ? !0 : null,
                    "aria-disabled": t.disabled ? !0 : null,
                    target: t.link ? t.target : null,
                    href: t.button ? null : t.href,
                },
                t.attrs
            ),
            { default: Te(() => [ge(t.$slots, "default")]), _: 3 },
            16,
            ["class", "aria-current", "aria-disabled", "target", "href"]
        )
    )
}
var mI = xe(pI, [["render", gI]])
const bI = be({
        name: "BModal",
        components: { BButton: oh },
        inheritAttrs: !1,
        props: {
            bodyBgVariant: { type: String, required: !1 },
            bodyClass: { type: String, required: !1 },
            bodyTextVariant: { type: String, required: !1 },
            busy: { type: Boolean, default: !1 },
            buttonSize: { type: String, default: "md" },
            cancelDisabled: { type: Boolean, default: !1 },
            cancelTitle: { type: String, default: "Cancel" },
            cancelVariant: { type: String, default: "secondary" },
            centered: { type: Boolean, default: !1 },
            contentClass: { type: String, required: !1 },
            dialogClass: { type: String, required: !1 },
            footerBgVariant: { type: String, required: !1 },
            footerBorderVariant: { type: String, required: !1 },
            footerClass: { type: String, required: !1 },
            footerTextVariant: { type: String, required: !1 },
            fullscreen: { type: [Boolean, String], default: !1 },
            headerBgVariant: { type: String, required: !1 },
            headerBorderVariant: { type: String, required: !1 },
            headerClass: { type: String, required: !1 },
            headerCloseLabel: { type: String, default: "Close" },
            headerCloseWhite: { type: Boolean, default: !1 },
            headerTextVariant: { type: String, required: !1 },
            hideBackdrop: { type: Boolean, default: !1 },
            hideFooter: { type: Boolean, default: !1 },
            hideHeader: { type: Boolean, default: !1 },
            hideHeaderClose: { type: Boolean, default: !1 },
            id: { type: String, required: !1 },
            modalClass: { type: String, required: !1 },
            modelValue: { type: Boolean, default: !1 },
            noCloseOnBackdrop: { type: Boolean, default: !1 },
            noCloseOnEsc: { type: Boolean, default: !1 },
            noFade: { type: Boolean, default: !1 },
            noFocus: { type: Boolean, default: !1 },
            okDisabled: { type: Boolean, default: !1 },
            okOnly: { type: Boolean, default: !1 },
            okTitle: { type: String, default: "Ok" },
            okVariant: { type: String, default: "primary" },
            scrollable: { type: Boolean, default: !1 },
            show: { type: Boolean, default: !1 },
            size: { type: String, required: !1 },
            title: { type: String, required: !1 },
            titleClass: { type: String, required: !1 },
            titleSrOnly: { type: Boolean, default: !1 },
            titleTag: { type: String, default: "h5" },
        },
        emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "ok", "cancel"],
        setup(t, { emit: e, slots: r }) {
            const n = Ue(),
                i = Ue(),
                s = H(() => [{ fade: !t.noFade, show: t.show }, t.modalClass]),
                o = H(() => [
                    {
                        "modal-fullscreen": typeof t.fullscreen == "boolean" ? t.fullscreen : !1,
                        [`modal-fullscreen-${t.fullscreen}-down`]: typeof t.fullscreen == "string" ? t.fullscreen : !1,
                        [`modal-${t.size}`]: t.size,
                        "modal-dialog-centered": t.centered,
                        "modal-dialog-scrollable": t.scrollable,
                    },
                    t.dialogClass,
                ]),
                a = H(() => [{ [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant, [`text-${t.bodyTextVariant}`]: t.bodyTextVariant }, t.bodyClass]),
                l = H(() => [
                    {
                        [`bg-${t.headerBgVariant}`]: t.headerBgVariant,
                        [`border-${t.headerBorderVariant}`]: t.headerBorderVariant,
                        [`text-${t.headerTextVariant}`]: t.headerTextVariant,
                    },
                    t.headerClass,
                ]),
                c = H(() => [
                    {
                        [`bg-${t.footerBgVariant}`]: t.footerBgVariant,
                        [`border-${t.footerBorderVariant}`]: t.footerBorderVariant,
                        [`text-${t.footerTextVariant}`]: t.footerTextVariant,
                    },
                    t.footerClass,
                ]),
                f = H(() => [{ ["visually-hidden"]: t.titleSrOnly }, t.titleClass]),
                u = H(() => !!r["header-close"]),
                p = H(() => [{ ["btn-close-content"]: u.value, ["d-flex"]: u.value, ["btn-close-white"]: !u.value && t.headerCloseWhite }]),
                m = H(() => t.cancelDisabled || t.busy),
                y = H(() => t.okDisabled || t.busy)
            return (
                Bt(n, "shown.bs.modal", (v) => e("shown", v)),
                Bt(n, "hidden.bs.modal", (v) => e("hidden", v)),
                Bt(n, "hidePrevented.bs.modal", (v) => e("hide-prevented", v)),
                Bt(n, "show.bs.modal", (v) => {
                    e("show", v), v.defaultPrevented || e("update:modelValue", !0)
                }),
                Bt(n, "hide.bs.modal", (v) => {
                    e("hide", v), v.defaultPrevented || e("update:modelValue", !1)
                }),
                Zt(() => {
                    var v
                    ;(i.value = new Fs(n.value, {
                        backdrop: t.hideBackdrop ? !1 : t.noCloseOnBackdrop ? "static" : !t.hideBackdrop,
                        keyboard: !t.noCloseOnEsc,
                        focus: !t.noFocus,
                    })),
                        t.modelValue && ((v = i.value) == null || v.show())
                }),
                It(
                    () => t.modelValue,
                    (v) => {
                        var _, C
                        v ? (_ = i.value) == null || _.show() : (C = i.value) == null || C.hide()
                    }
                ),
                {
                    element: n,
                    disableCancel: m,
                    disableOk: y,
                    modalClasses: s,
                    modalDialogClasses: o,
                    computedBodyClasses: a,
                    computedFooterClasses: c,
                    computedHeaderClasses: l,
                    computedTitleClasses: f,
                    computedCloseButtonClasses: p,
                }
            )
        },
    }),
    xI = ["id"],
    vI = ["aria-label"]
function yI(t, e, r, n, i, s) {
    const o = Qt("b-button")
    return (
        K(),
        we(H_, { to: "body" }, [
            He(
                "div",
                Je({ id: t.id, ref: "element", class: ["modal", t.modalClasses], tabindex: "-1" }, t.$attrs),
                [
                    He(
                        "div",
                        { class: ye(["modal-dialog", t.modalDialogClasses]) },
                        [
                            He(
                                "div",
                                { class: ye(["modal-content", t.contentClass]) },
                                [
                                    t.hideHeader
                                        ? Be("", !0)
                                        : (K(),
                                          ue(
                                              "div",
                                              { key: 0, class: ye(["modal-header", t.computedHeaderClasses]) },
                                              [
                                                  (K(),
                                                  we(
                                                      Ie(t.titleTag),
                                                      { class: ye(["modal-title", t.computedTitleClasses]) },
                                                      { default: Te(() => [ge(t.$slots, "title", {}, () => [Ut(tt(t.title), 1)])]), _: 3 },
                                                      8,
                                                      ["class"]
                                                  )),
                                                  t.hideHeaderClose
                                                      ? Be("", !0)
                                                      : (K(),
                                                        ue(
                                                            "button",
                                                            {
                                                                key: 0,
                                                                type: "button",
                                                                class: ye(["btn-close", t.computedCloseButtonClasses]),
                                                                "data-bs-dismiss": "modal",
                                                                "aria-label": t.headerCloseLabel,
                                                            },
                                                            [ge(t.$slots, "header-close")],
                                                            10,
                                                            vI
                                                        )),
                                              ],
                                              2
                                          )),
                                    He("div", { class: ye(["modal-body", t.computedBodyClasses]) }, [ge(t.$slots, "default")], 2),
                                    t.hideFooter
                                        ? Be("", !0)
                                        : (K(),
                                          ue(
                                              "div",
                                              { key: 1, class: ye(["modal-footer", t.computedFooterClasses]) },
                                              [
                                                  ge(t.$slots, "footer", {}, () => [
                                                      t.okOnly
                                                          ? Be("", !0)
                                                          : (K(),
                                                            we(
                                                                o,
                                                                {
                                                                    key: 0,
                                                                    type: "button",
                                                                    class: "btn btn-secondary",
                                                                    "data-bs-dismiss": "modal",
                                                                    disabled: t.disableCancel,
                                                                    size: t.buttonSize,
                                                                    variant: t.cancelVariant,
                                                                    onClick: e[0] || (e[0] = (a) => t.$emit("cancel")),
                                                                },
                                                                { default: Te(() => [Ut(tt(t.cancelTitle), 1)]), _: 1 },
                                                                8,
                                                                ["disabled", "size", "variant"]
                                                            )),
                                                      jt(
                                                          o,
                                                          {
                                                              type: "button",
                                                              class: "btn btn-primary",
                                                              "data-bs-dismiss": "modal",
                                                              disabled: t.disableOk,
                                                              size: t.buttonSize,
                                                              variant: t.okVariant,
                                                              onClick: e[1] || (e[1] = (a) => t.$emit("ok")),
                                                          },
                                                          { default: Te(() => [Ut(tt(t.okTitle), 1)]), _: 1 },
                                                          8,
                                                          ["disabled", "size", "variant"]
                                                      ),
                                                  ]),
                                              ],
                                              2
                                          )),
                                ],
                                2
                            ),
                        ],
                        2
                    ),
                ],
                16,
                xI
            ),
        ])
    )
}
var _I = xe(bI, [["render", yI]])
const wI = be({
    name: "BNav",
    props: {
        align: { type: String },
        fill: { type: Boolean, default: !1 },
        justified: { type: Boolean, default: !1 },
        pills: { type: Boolean, default: !1 },
        tabs: { type: Boolean, default: !1 },
        vertical: { type: Boolean, default: !1 },
    },
    setup(t) {
        return {
            classes: H(() => ({
                "flex-column": t.vertical,
                [`justify-content-${t.align}`]: t.align,
                "nav-tabs": t.tabs,
                "nav-pills": t.pills,
                "nav-fill": t.fill,
                "nav-justified": t.justified,
            })),
        }
    },
})
function EI(t, e, r, n, i, s) {
    return K(), ue("ul", { class: ye(["nav", t.classes]) }, [ge(t.$slots, "default")], 2)
}
var SI = xe(wI, [["render", EI]])
const AI = be({
        name: "BNavItem",
        props: { active: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, href: { type: String, required: !1 } },
        setup(t) {
            return { classes: H(() => ({ active: t.active, disabled: t.disabled })) }
        },
    }),
    TI = ["href", "tabindex", "aria-disabled"]
function CI(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "li",
            { class: ye(["nav-item", t.classes]) },
            [
                He(
                    "a",
                    { href: t.href, class: "nav-link", tabindex: t.disabled ? -1 : null, "aria-disabled": t.disabled ? !0 : null },
                    [ge(t.$slots, "default")],
                    8,
                    TI
                ),
            ],
            2
        )
    )
}
var kI = xe(AI, [["render", CI]])
const NI = be({
        name: "BOffcanvas",
        props: {
            modelValue: { type: Boolean, default: !1 },
            bodyScrolling: { type: Boolean, default: !1 },
            backdrop: { type: Boolean, default: !0 },
            placement: { type: String, default: "start" },
            title: { type: String, required: !0 },
        },
        emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
        setup(t, { emit: e }) {
            const r = Ue(),
                n = Ue()
            Bt(r, "shown.bs.offcanvas", () => e("shown")),
                Bt(r, "hidden.bs.offcanvas", () => e("hidden")),
                Bt(r, "show.bs.offcanvas", () => {
                    e("show"), e("update:modelValue", !0)
                }),
                Bt(r, "hide.bs.offcanvas", () => {
                    e("hide"), e("update:modelValue", !1)
                }),
                Zt(() => {
                    var s
                    ;(n.value = new Wi(r.value)), t.modelValue && ((s = n.value) == null || s.show(r.value))
                })
            const i = H(() => ({ [`offcanvas-${t.placement}`]: t.placement }))
            return (
                It(
                    () => t.modelValue,
                    (s) => {
                        var o, a
                        s ? (o = n.value) == null || o.show(r.value) : (a = n.value) == null || a.hide()
                    }
                ),
                { element: r, classes: i }
            )
        },
    }),
    PI = ["data-bs-backdrop", "data-bs-scroll"],
    II = { class: "offcanvas-header" },
    $I = { id: "offcanvasLabel", class: "offcanvas-title" },
    BI = He("button", { type: "button", class: "btn-close text-reset", "data-bs-dismiss": "offcanvas", "aria-label": "Close" }, null, -1),
    OI = { class: "offcanvas-body" }
function MI(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "div",
            {
                ref: "element",
                class: ye(["offcanvas", t.classes]),
                tabindex: "-1",
                "aria-labelledby": "offcanvasLabel",
                "data-bs-backdrop": t.backdrop,
                "data-bs-scroll": t.bodyScrolling,
            },
            [
                He("div", II, [He("h5", $I, [ge(t.$slots, "title", {}, () => [Ut(tt(t.title), 1)])]), BI]),
                He("div", OI, [ge(t.$slots, "default")]),
            ],
            10,
            PI
        )
    )
}
var RI = xe(NI, [["render", MI]])
const wy = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: "",
    },
    LI = Rt(Me({}, wy), { enterActiveClass: "fade showing", leaveActiveClass: "fade showing" }),
    Bc = be({
        name: "BTransition",
        props: {
            appear: { type: Boolean, default: !1 },
            mode: { type: String, required: !1 },
            noFade: { type: Boolean, default: !1 },
            transProps: { type: Object, required: !1 },
        },
        setup(t, { slots: e }) {
            const r = Ue(t.transProps)
            return (
                Xv(r.value) ||
                    ((r.value = t.noFade ? wy : LI),
                    t.appear &&
                        (r.value = Rt(Me({}, r.value), {
                            appear: !0,
                            appearClass: r.value.enterClass,
                            appearActiveClass: r.value.enterActiveClass,
                            appearToClass: r.value.enterToClass,
                        }))),
                (r.value = Rt(Me({ mode: t.mode }, r.value), { css: !0 })),
                () => Ae(d0, Me({}, r.value), { default: () => (e.default ? e.default() : []) })
            )
        },
    }),
    $u = { top: 0, left: 0, bottom: 0, right: 0 },
    DI = "default",
    FI = "overlay",
    VI = be({
        name: "BOverlay",
        components: { BTransition: Bc },
        props: {
            bgColor: { type: String, required: !1 },
            blur: { type: String, default: "2px" },
            fixed: { type: Boolean, default: !1 },
            noCenter: { type: Boolean, default: !1 },
            noFade: { type: Boolean, default: !1 },
            noWrap: { type: Boolean, default: !1 },
            opacity: {
                type: [Number, String],
                default: 0.85,
                validator: (t) => {
                    const e = sh(t, 0)
                    return e >= 0 && e <= 1
                },
            },
            overlayTag: { type: String, default: "div" },
            rounded: { type: [Boolean, String], default: !1 },
            show: { type: Boolean, default: !1 },
            spinnerSmall: { type: Boolean, default: !1 },
            spinnerType: { type: String, default: "border" },
            spinnerVariant: { type: String, required: !1 },
            variant: { type: String, default: "light" },
            wrapTag: { type: String, default: "div" },
            zIndex: { type: [Number, String], default: 10 },
        },
        emits: ["click", "hidden", "shown"],
        setup(t, { slots: e, emit: r }) {
            const n = H(() => (t.rounded === !0 || t.rounded === "" ? "rounded" : t.rounded ? `rounded-${t.rounded}` : "")),
                i = H(() => (t.variant && !t.bgColor ? `bg-${t.variant}` : "")),
                s = H(() => ({ spinnerType: t.spinnerType || null, spinnerVariant: t.spinnerVariant || null, spinnerSmall: t.spinnerSmall }))
            return () => {
                const o = (f) => Ae(Qt("BSpinner"), { type: f.spinnerType, variant: f.spinnerVariant, small: f.spinnerSmall })
                let a = ""
                if (t.show) {
                    const f = Ae("div", {
                            class: ["position-absolute", i.value, n.value],
                            style: Rt(Me({}, $u), {
                                opacity: t.opacity,
                                backgroundColor: t.bgColor || null,
                                backdropFilter: t.blur ? `blur(${t.blur})` : null,
                            }),
                        }),
                        u = Ae(
                            "div",
                            {
                                class: "position-absolute",
                                style: t.noCenter ? Me({}, $u) : { top: "50%", left: "50%", transform: "translateX(-50%) translateY(-50%)" },
                            },
                            $r(FI, s.value, e) || o(s.value) || ""
                        )
                    a = Ae(
                        t.overlayTag,
                        {
                            class: [
                                "b-overlay",
                                { "position-absolute": !t.noWrap || (t.noWrap && !t.fixed), "position-fixed": t.noWrap && t.fixed },
                            ],
                            style: Rt(Me({}, $u), { zIndex: t.zIndex || 10 }),
                            onClick: (p) => r("click", p),
                            key: "overlay",
                        },
                        [f, u]
                    )
                }
                const l = () =>
                    Ae(
                        Bc,
                        {
                            noFade: t.noFade,
                            transProps: { enterToClass: "show" },
                            name: "fade",
                            onAfterEnter: () => r("shown"),
                            onAfterLeave: () => r("hidden"),
                        },
                        { default: () => a }
                    )
                return t.noWrap
                    ? l()
                    : Ae(t.wrapTag, { class: ["b-overlay-wrap position-relative"], "aria-busy": t.show ? "true" : null }, [
                          Ae("span", $r(DI, {}, e)),
                          l(),
                      ])
            }
        },
    })
function UI(t) {
    return H(() =>
        t.align === "center"
            ? "justify-content-center"
            : t.align === "end"
            ? "justify-content-end"
            : (t.align === "start", "justify-content-start")
    )
}
class _f {
    constructor(e, r = {}) {
        if (
            ((this.cancelable = !0),
            (this.componentId = null),
            (this.defaultPrevented = !1),
            (this.nativeEvent = null),
            (this.relatedTarget = null),
            (this.target = null),
            (this.eventType = ""),
            (this.vueTarget = null),
            !e)
        )
            throw new TypeError(`Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`)
        nC(this, _f.Defaults, this.constructor.Defaults, r, { eventType: e }),
            iC(this, { type: vs(), cancelable: vs(), nativeEvent: vs(), target: vs(), relatedTarget: vs(), vueTarget: vs(), componentId: vs() })
        let n = !1
        ;(this.preventDefault = function () {
            this.cancelable && (n = !0)
        }),
            sC(this, "defaultPrevented", {
                enumerable: !0,
                get() {
                    return n
                },
            })
    }
    static get Defaults() {
        return { eventType: "", cancelable: !0, nativeEvent: null, target: null, relatedTarget: null, vueTarget: null, componentId: null }
    }
}
const HI = 5,
    Ey = 20,
    Sy = 0,
    gn = 3,
    qI = "ellipsis-text",
    jI = "first-text",
    zI = "last-text",
    KI = "next-text",
    GI = "page",
    WI = "prev-text",
    wm = (t) => Math.max(Do(t) || Ey, 1),
    Em = (t) => Math.max(Do(t) || Sy, 0),
    JI = (t, e) => {
        const r = Do(t) || 1
        return r > e ? e : r < 1 ? 1 : r
    },
    XI = be({
        name: "BPagination",
        props: {
            align: { type: String, default: "start" },
            ariaControls: { type: String, required: !1 },
            ariaLabel: { type: String, default: "Pagination" },
            disabled: { type: Boolean, default: !1 },
            ellipsisClass: { type: [Array, String], default: () => [] },
            ellipsisText: { type: String, default: "\u2026" },
            firstClass: { type: [Array, String], default: () => [] },
            firstNumber: { type: Boolean, default: !1 },
            firstText: { type: String, default: "\xAB" },
            hideEllipsis: { type: Boolean, default: !1 },
            hideGotoEndButtons: { type: Boolean, default: !1 },
            labelFirstPage: { type: String, default: "Go to first page" },
            labelLastPage: { type: String, default: "Go to last page" },
            labelNextPage: { type: String, default: "Go to next page" },
            labelPage: { type: String, default: "Go to page" },
            labelPrevPage: { type: String, default: "Go to previous page" },
            lastClass: { type: [Array, String], default: () => [] },
            lastNumber: { type: Boolean, default: !1 },
            lastText: { type: String, default: "\xBB" },
            limit: { type: Number, default: HI },
            modelValue: { type: Number, default: 1 },
            nextClass: { type: [Array, String], default: () => [] },
            nextText: { type: String, default: "\u203A" },
            pageClass: { type: [Array, String], default: () => [] },
            perPage: { type: Number, default: Ey },
            pills: { type: Boolean, default: !1 },
            prevClass: { type: [Array, String], default: () => [] },
            prevText: { type: String, default: "\u2039" },
            size: { type: String, required: !1 },
            totalRows: { type: Number, default: Sy },
        },
        emits: ["update:modelValue", "page-click"],
        setup(t, { emit: e, slots: r }) {
            const n = UI(t),
                i = H(() => Math.ceil(Em(t.totalRows) / wm(t.perPage))),
                s = H(() => {
                    let y = 1
                    return (
                        i.value - t.modelValue + 2 < t.limit && t.limit > gn
                            ? (y = i.value - a.value + 1)
                            : (y = t.modelValue - Math.floor(a.value / 2)),
                        y < 1 ? (y = 1) : y > i.value - a.value && (y = i.value - a.value + 1),
                        t.limit <= gn && t.lastNumber && i.value === y + a.value - 1 && (y = Math.max(y - 1, 1)),
                        y
                    )
                }),
                o = H(() => {
                    const y = i.value - t.modelValue
                    let v = !1
                    return (
                        y + 2 < t.limit && t.limit > gn ? t.limit > gn && (v = !0) : t.limit > gn && (v = !!(!t.hideEllipsis || t.firstNumber)),
                        s.value <= 1 && (v = !1),
                        v && t.firstNumber && s.value < 4 && (v = !1),
                        v
                    )
                }),
                a = H(() => {
                    let y = t.limit
                    return (
                        i.value <= t.limit
                            ? (y = i.value)
                            : t.modelValue < t.limit - 1 && t.limit > gn
                            ? ((!t.hideEllipsis || t.lastNumber) && (y = t.limit - (t.firstNumber ? 0 : 1)), (y = Math.min(y, t.limit)))
                            : i.value - t.modelValue + 2 < t.limit && t.limit > gn
                            ? (!t.hideEllipsis || t.firstNumber) && (y = t.limit - (t.lastNumber ? 0 : 1))
                            : t.limit > gn && (y = t.limit - (t.hideEllipsis ? 0 : 2)),
                        y
                    )
                })
            H(() => {
                let y = a.value
                o.value && t.firstNumber && s.value < 4 && (y = y + 2)
                const v = s.value + y - 1
                return (
                    l.value && t.lastNumber && v > i.value - 3 && (y = y + (v === i.value - 2 ? 2 : 3)),
                    (y = Math.min(y, i.value - s.value + 1)),
                    y
                )
            })
            const l = H(() => {
                    const y = i.value - a.value
                    let v = !1
                    t.modelValue < t.limit - 1 && t.limit > gn
                        ? (!t.hideEllipsis || t.lastNumber) && (v = !0)
                        : t.limit > gn && (v = !!(!t.hideEllipsis || t.lastNumber)),
                        s.value > y && (v = !1)
                    const _ = s.value + a.value - 1
                    return v && t.lastNumber && _ > i.value - 3 && (v = !1), v
                }),
                c = Ln({ pageSize: wm(t.perPage), totalRows: Em(t.totalRows), numberOfPages: i.value }),
                f = (y, v) => {
                    if (v === t.modelValue) return
                    const { target: _ } = y,
                        C = new _f("page-click", { cancelable: !0, vueTarget: this, target: _ })
                    e("page-click", C, v), !C.defaultPrevented && e("update:modelValue", v)
                },
                u = H(() => (t.size ? `pagination-${t.size}` : "")),
                p = H(() => (t.pills ? "b-pagination-pills" : ""))
            It(
                () => t.modelValue,
                (y) => {
                    const v = JI(y, i.value)
                    v !== t.modelValue && e("update:modelValue", v)
                }
            ),
                It(c, (y, v) => {
                    Kv(y) ||
                        (((v.pageSize !== y.pageSize && v.totalRows === y.totalRows) ||
                            (v.numberOfPages !== y.numberOfPages && t.modelValue > v.numberOfPages)) &&
                            e("update:modelValue", 1))
                })
            const m = H(() => {
                const y = []
                for (let v = 0; v < a.value; v++) y.push({ number: s.value + v, classes: null })
                return y
            })
            return () => {
                const y = [],
                    v = m.value.map((G) => G.number),
                    _ = (G) => G === t.modelValue,
                    C = t.modelValue < 1,
                    B = t.align === "fill",
                    R = (G, de, k, d, b, w) => {
                        const E = t.disabled || _(w) || C || G < 1 || G > i.value,
                            T = G < 1 ? 1 : G > i.value ? i.value : G,
                            A = { disabled: E, page: T, index: T - 1 },
                            $ = $r(k, A, r) || d || ""
                        return Ae(
                            "li",
                            { class: ["page-item", { disabled: E, "flex-fill": B, "d-flex": B && !E }, b] },
                            Ae(
                                E ? "span" : "button",
                                {
                                    class: ["page-link", { "flex-grow-1": !E && B }],
                                    "aria-label": de,
                                    "aria-controls": t.ariaControls || null,
                                    "aria-disabled": E ? "true" : null,
                                    role: "menuitem",
                                    type: E ? null : "button",
                                    tabindex: E ? null : "-1",
                                    onClick: (S) => {
                                        E || f(S, T)
                                    },
                                },
                                $
                            )
                        )
                    },
                    U = (G) =>
                        Ae(
                            "li",
                            {
                                class: ["page-item", "disabled", "bv-d-xs-down-none", B ? "flex-fill" : "", t.ellipsisClass],
                                role: "separator",
                                key: `ellipsis-${G ? "last" : "first"}`,
                            },
                            [Ae("span", { class: ["page-link"] }, $r(qI, {}, r) || t.ellipsisText || "...")]
                        ),
                    D = (G, de) => {
                        const k = _(G.number) && !C,
                            d = t.disabled ? null : k || (C && de === 0) ? "0" : "-1",
                            b = { active: k, disabled: t.disabled, page: G.number, index: G.number - 1, content: G.number },
                            w = $r(GI, b, r) || G.number,
                            E = Ae(
                                t.disabled ? "span" : "button",
                                {
                                    class: ["page-link", { "flex-grow-1": !t.disabled && B }],
                                    "aria-controls": t.ariaControls || null,
                                    "aria-disabled": t.disabled ? "true" : null,
                                    "aria-label": t.labelPage ? `${t.labelPage} ${G.number}` : null,
                                    role: "menuitemradio",
                                    type: t.disabled ? null : "button",
                                    tabindex: d,
                                    onClick: (T) => {
                                        t.disabled || f(T, G.number)
                                    },
                                },
                                w
                            )
                        return Ae(
                            "li",
                            {
                                class: [
                                    "page-item",
                                    { disabled: t.disabled, active: k, "flex-fill": B, "d-flex": B && !t.disabled },
                                    t.pageClass,
                                ],
                                role: "presentation",
                                key: `page-${G.number}`,
                            },
                            E
                        )
                    }
                if (!t.hideGotoEndButtons && !t.firstNumber) {
                    const G = R(1, t.labelFirstPage, jI, t.firstText, t.firstClass, 1)
                    y.push(G)
                }
                const Y = R(t.modelValue - 1, t.labelFirstPage, WI, t.prevText, t.prevClass, 1)
                y.push(Y),
                    t.firstNumber && v[0] !== 1 && y.push(D({ number: 1 }, 0)),
                    o.value && y.push(U(!1)),
                    m.value.forEach((G, de) => {
                        const k = o.value && t.firstNumber && v[0] !== 1 ? 1 : 0
                        y.push(D(G, de + k))
                    }),
                    l.value && y.push(U(!0)),
                    t.lastNumber && v[v.length - 1] !== i.value && y.push(D({ number: i.value }, -1))
                const J = R(t.modelValue + 1, t.labelNextPage, KI, t.nextText, t.nextClass, i.value)
                if ((y.push(J), !t.lastNumber && !t.hideGotoEndButtons)) {
                    const G = R(i.value, t.labelLastPage, zI, t.lastText, t.lastClass, i.value)
                    y.push(G)
                }
                return Ae(
                    "ul",
                    {
                        class: ["pagination", u.value, n.value, p.value],
                        role: "menubar",
                        "aria-disabled": t.disabled,
                        "aria-label": t.ariaLabel || null,
                    },
                    y
                )
            }
        },
    }),
    YI = be({
        name: "BPopover",
        props: {
            container: { type: [String, Object], default: "body" },
            content: { type: String },
            id: { type: String },
            noninteractive: { type: Boolean, default: !1 },
            placement: { type: String, default: "right" },
            target: { type: [String, Object], default: void 0 },
            title: { type: String },
            triggers: { type: String, default: "click" },
            show: { type: Boolean, default: !1 },
            variant: { type: String, default: void 0 },
            html: { type: Boolean, default: !0 },
            sanitize: { type: Boolean, default: !1 },
        },
        emits: ["show", "shown", "hide", "hidden", "inserted"],
        setup(t, { emit: e, slots: r }) {
            const n = Ue(),
                i = Ue(),
                s = Ue(),
                o = Ue(),
                a = Ue(),
                l = H(() => ({ [`b-popover-${t.variant}`]: t.variant })),
                c = (u) => {
                    if (typeof u == "string") return u
                    if (u instanceof HTMLElement) return u
                    if (typeof u != "undefined") return u.$el
                },
                f = (u) => {
                    if (!!u) {
                        if (typeof u == "string") {
                            const p = document.getElementById(u)
                            return p || void 0
                        }
                        return u
                    }
                }
            return (
                Zt(() => {
                    var u, p, m
                    kn(() => {
                        ;(i.value = f(c(t.target))),
                            i.value
                                ? (s.value = new Ro(i.value, {
                                      container: c(t.container),
                                      trigger: t.triggers,
                                      placement: t.placement,
                                      title: t.title || r.title ? o.value : "",
                                      content: a.value,
                                      html: t.html,
                                      sanitize: t.sanitize,
                                  }))
                                : console.warn("[B-Popover] Target is a mandatory props.")
                    }),
                        (p = (u = n.value) == null ? void 0 : u.parentNode) == null || p.removeChild(n.value),
                        t.show && ((m = s.value) == null || m.show())
                }),
                It(
                    () => t.show,
                    (u, p) => {
                        var m, y
                        u !== p && (u ? (m = s.value) == null || m.show() : (y = s.value) == null || y.hide())
                    }
                ),
                Bt(i, "show.bs.popover", () => e("show")),
                Bt(i, "shown.bs.popover", () => e("shown")),
                Bt(i, "hide.bs.popover", () => e("hide")),
                Bt(i, "hidden.bs.popover", () => e("hidden")),
                Bt(i, "inserted.bs.popover", () => e("inserted")),
                { element: n, titleRef: o, contentRef: a, classes: l }
            )
        },
    }),
    ZI = ["id"],
    QI = { ref: "titleRef" },
    e$ = { ref: "contentRef" }
function t$(t, e, r, n, i, s) {
    return (
        K(),
        ue(
            "div",
            { id: t.id, ref: "element", class: ye(["popover b-popover", t.classes]), role: "tooltip", tabindex: "-1" },
            [
                He("div", QI, [ge(t.$slots, "title", {}, () => [Ut(tt(t.title), 1)])], 512),
                He("div", e$, [ge(t.$slots, "default", {}, () => [Ut(tt(t.content), 1)])], 512),
            ],
            10,
            ZI
        )
    )
}
var r$ = xe(YI, [["render", t$]])
const Ay = Symbol(),
    n$ = be({
        name: "BProgress",
        props: {
            animated: { type: Boolean, default: !1 },
            max: { type: [Number, String] },
            height: { type: String },
            precision: { type: [Number, String], default: 0 },
            showProgress: { type: Boolean, default: !1 },
            showValue: { type: Boolean, default: !1 },
            striped: { type: Boolean, default: !1 },
            value: { type: [Number, String], default: 0 },
            variant: { type: String },
        },
        setup(t) {
            Nn(Ay, { animated: t.animated, max: t.max, showProgress: t.showProgress, showValue: t.showValue, striped: t.striped })
        },
    })
function i$(t, e, r, n, i, s) {
    const o = Qt("b-progress-bar")
    return (
        K(),
        ue(
            "div",
            { class: "progress", style: ni({ height: t.height }) },
            [
                ge(t.$slots, "default", {}, () => [
                    jt(
                        o,
                        l2(
                            kb({
                                animated: t.animated,
                                max: t.max,
                                precision: t.precision,
                                showProgress: t.showProgress,
                                showValue: t.showValue,
                                striped: t.striped,
                                value: t.value,
                                variant: t.variant,
                            })
                        ),
                        null,
                        16
                    ),
                ]),
            ],
            4
        )
    )
}
var s$ = xe(n$, [["render", i$]])
const o$ = be({
        name: "BProgressBar",
        props: {
            animated: { type: Boolean, default: !1 },
            label: { type: String },
            labelHtml: { type: String },
            max: { type: [Number, String] },
            precision: { type: [Number, String], default: 0 },
            showProgress: { type: Boolean, default: !1 },
            showValue: { type: Boolean, default: !1 },
            striped: { type: Boolean, default: !1 },
            value: { type: [Number, String], default: 0 },
            variant: { type: String },
        },
        setup(t, { slots: e }) {
            const r = sr(Ay),
                n = H(() => ({
                    "progress-bar-animated": t.animated || (r == null ? void 0 : r.animated),
                    "progress-bar-striped": t.striped || (r == null ? void 0 : r.striped) || t.animated || (r == null ? void 0 : r.animated),
                    [`bg-${t.variant}`]: t.variant,
                })),
                i = H(() => {
                    if (t.showValue || (r == null ? void 0 : r.showValue)) return parseFloat(t.value).toFixed(t.precision)
                    if (t.showProgress || (r == null ? void 0 : r.showProgress)) {
                        const a = ((t.value * 100) / parseInt(t.max || 100)).toString()
                        return parseFloat(a).toFixed(t.precision)
                    }
                    return t.label || ""
                }),
                s = H(() =>
                    t.max || (r == null ? void 0 : r.max)
                        ? `${(t.value * 100) / parseInt(t.max || (r == null ? void 0 : r.max))}%`
                        : typeof t.value == "string"
                        ? t.value
                        : `${t.value}%`
                ),
                o = H(() => {
                    const a = {
                        class: ["progress-bar", n.value],
                        role: "progressbar",
                        "aria-valuenow": t.value,
                        "aria-valuemin": 0,
                        "aria-valuemax": t.max,
                        style: { width: s.value },
                    }
                    return t.labelHtml ? Rt(Me({}, a), { innerHTML: t.labelHtml }) : a
                })
            return () => {
                var a
                return Ae("div", o.value, ((a = e.default) == null ? void 0 : a.call(e)) || i.value)
            }
        },
    }),
    Sm = yf("cols", [""], { type: [String, Number], default: null }),
    a$ = be({
        name: "BRow",
        props: Me(
            {
                tag: { type: String, default: "div" },
                gutterX: { type: String, default: null },
                gutterY: { type: String, default: null },
                alignV: { type: String, default: null },
                alignH: { type: String, default: null },
                alignContent: { type: String, default: null },
            },
            Sm
        ),
        setup(t) {
            const e = ay(t, Sm, "cols", "row-cols")
            return {
                classes: H(() => ({
                    [`gx-${t.gutterX}`]: t.gutterX !== null,
                    [`gy-${t.gutterY}`]: t.gutterY !== null,
                    [`align-items-${t.alignV}`]: t.alignV,
                    [`justify-content-${t.alignH}`]: t.alignH,
                    [`align-content-${t.alignContent}`]: t.alignContent,
                })),
                rowColsClasses: e,
            }
        },
    })
function l$(t, e, r, n, i, s) {
    return (
        K(),
        we(Ie(t.tag), { class: ye(["row", [t.classes, t.rowColsClasses]]) }, { default: Te(() => [ge(t.$slots, "default")]), _: 3 }, 8, [
            "class",
        ])
    )
}
var c$ = xe(a$, [["render", l$]])
const f$ = be({
        name: "BSpinner",
        props: {
            label: { type: String },
            role: { type: String, default: "status" },
            small: { type: Boolean, default: !1 },
            tag: { type: String, default: "span" },
            type: { type: String, default: "border" },
            variant: { type: String },
        },
        setup(t) {
            return {
                classes: H(() => ({
                    "spinner-border": t.type === "border",
                    "spinner-border-sm": t.type === "border" && t.small,
                    "spinner-grow": t.type === "grow",
                    "spinner-grow-sm": t.type === "grow" && t.small,
                    [`text-${t.variant}`]: !!t.variant,
                })),
            }
        },
    }),
    u$ = { key: 0, class: "visually-hidden" }
function d$(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tag),
            { class: ye(t.classes), role: t.label || t.$slots.label ? t.role : null, "aria-hidden": t.label || t.$slots.label ? null : !0 },
            {
                default: Te(() => [
                    t.label || t.$slots.label ? (K(), ue("span", u$, [ge(t.$slots, "label", {}, () => [Ut(tt(t.label), 1)])])) : Be("", !0),
                ]),
                _: 3,
            },
            8,
            ["class", "role", "aria-hidden"]
        )
    )
}
var h$ = xe(f$, [["render", d$]])
const Ty = Symbol(),
    p$ = (t) =>
        !t || !t.default
            ? []
            : t
                  .default()
                  .reduce((e, r) => (typeof r.type == "symbol" ? (e = e.concat(r.children)) : e.push(r), e), [])
                  .filter((e) => {
                      var r
                      return ((r = e.type) == null ? void 0 : r.name) === "BTab"
                  }),
    g$ = be({
        name: "BTabs",
        props: {
            activeNavItemClass: { type: [Array, Object, String], default: null },
            activeTabClass: { type: [Array, Object, String], default: null },
            align: { type: String, default: null },
            card: { type: Boolean, default: !1 },
            contentClass: { type: [Array, Object, String], default: null },
            end: { type: Boolean, default: !1 },
            fill: { type: Boolean, default: !1 },
            id: { type: String, default: null },
            justified: { type: Boolean, default: !1 },
            lazy: { type: Boolean, default: !1 },
            navClass: { type: [Array, Object, String], default: null },
            navWrapperClass: { type: [Array, Object, String], default: null },
            noFade: { type: Boolean, default: !1 },
            noNavStyle: { type: Boolean, default: !1 },
            pills: { type: Boolean, default: !1 },
            small: { type: Boolean, default: !1 },
            tag: { type: String, default: "div" },
            vertical: { type: Boolean, default: !1 },
            modelValue: { type: Number, default: -1 },
        },
        emits: ["update:modelValue", "activate-tab", "click"],
        setup(t, { slots: e, emit: r }) {
            const n = Ue(t.modelValue),
                i = Ue(""),
                s = H({
                    get: () => n.value,
                    set: (p) => {
                        ;(n.value = p),
                            o.value.length > 0 && p >= 0 && p < o.value.length ? (i.value = o.value[p].buttonId) : (i.value = ""),
                            r("update:modelValue", p)
                    },
                }),
                o = H(() => {
                    let p = []
                    return (
                        e.default &&
                            (p = p$(e).map((m, y) => {
                                m.props || (m.props = {})
                                const v = m.props["button-id"] || ei("tab"),
                                    _ = m.props.id || ei(),
                                    C = s.value > -1 ? y === s.value : m.props.active === "",
                                    B = m.props["title-item-class"],
                                    R = m.props["title-link-attributes"]
                                return {
                                    buttonId: v,
                                    contentId: _,
                                    active: C,
                                    disabled: m.props.disabled === "",
                                    navItemClasses: [
                                        { active: C, disabled: m.props.disabled === "" },
                                        C && t.activeNavItemClass ? t.activeNavItemClass : null,
                                        m.props["title-link-class"],
                                    ],
                                    tabClasses: [{ fade: !t.noFade }, C && t.activeTabClass ? t.activeTabClass : null],
                                    target: `#${_}`,
                                    title: m.props.title,
                                    titleItemClass: B,
                                    titleLinkAttributes: R,
                                    onClick: m.props.onClick,
                                    tab: m,
                                }
                            })),
                        p
                    )
                }),
                a = H(() => !((o == null ? void 0 : o.value) && o.value.length > 0)),
                l = H(() => ({ "d-flex align-items-start": t.vertical })),
                c = H(() => ({
                    "nav-pills": t.pills,
                    "flex-column me-3": t.vertical,
                    [`justify-content-${t.align}`]: !!t.align,
                    "nav-fill": t.fill,
                    "card-header-tabs": t.card,
                    "nav-justified": t.justified,
                    "nav-tabs": !t.noNavStyle && !t.pills,
                    small: t.small,
                })),
                f = (p) => {
                    let m = !1
                    if (
                        p !== void 0 &&
                        p > -1 &&
                        p < o.value.length &&
                        !o.value[p].disabled &&
                        (s.value < 0 || o.value[p].buttonId !== i.value)
                    ) {
                        const y = new _f("activate-tab", { cancelable: !0, vueTarget: this })
                        r("activate-tab", p, s.value, y), y.defaultPrevented || ((s.value = p), (m = !0))
                    }
                    return !m && t.modelValue !== s.value && r("update:modelValue", s.value), m
                },
                u = (p, m) => {
                    var y
                    f(m),
                        m >= 0 &&
                            !o.value[m].disabled &&
                            ((y = o.value[m]) == null ? void 0 : y.onClick) &&
                            Jv(o.value[m].onClick) &&
                            o.value[m].onClick(p)
                }
            return (
                f(n.value),
                It(
                    () => t.modelValue,
                    (p, m) => {
                        if (p === m) return
                        if (((p = Nd(p, -1)), (m = Nd(m, -1)), o.value.length <= 0)) {
                            s.value = -1
                            return
                        }
                        const y = p > m
                        let v = p
                        const _ = o.value.length - 1
                        for (; v >= 0 && v <= _ && o.value[v].disabled; ) v += y ? 1 : -1
                        if (v < 0) {
                            f(0)
                            return
                        }
                        if (v >= o.value.length) {
                            f(o.value.length - 1)
                            return
                        }
                        f(v)
                    }
                ),
                It(
                    () => o.value,
                    () => {
                        let p = o.value.map((m) => m.active && !m.disabled).lastIndexOf(!0)
                        p < 0 &&
                            (s.value >= o.value.length
                                ? (p = o.value.map((m) => !m.disabled).lastIndexOf(!0))
                                : o.value[s.value] && !o.value[s.value].disabled && (p = s.value)),
                            p < 0 && (p = o.value.map((m) => !m.disabled).indexOf(!0)),
                            o.value.forEach((m, y) => (m.active = y === p)),
                            f(p)
                    }
                ),
                Zt(() => {
                    if (s.value < 0 && o.value.length > 0 && !o.value.some((p) => p.active)) {
                        const p = o.value.map((m) => !m.disabled).indexOf(!0)
                        f(p >= 0 ? p : -1)
                    }
                }),
                Nn(Ty, { lazy: t.lazy, card: t.card }),
                { tabs: o, showEmpty: a, classes: l, navTabsClasses: c, tabIndex: s, handleClick: u }
            )
        },
    }),
    m$ = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"]
function b$(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tag),
            { id: t.id, class: ye(["tabs", t.classes]) },
            {
                default: Te(() => [
                    t.end
                        ? (K(),
                          ue(
                              "div",
                              { key: 0, class: ye(["tab-content", t.contentClass]) },
                              [
                                  (K(!0),
                                  ue(
                                      Nt,
                                      null,
                                      Pn(
                                          t.tabs,
                                          ({ tab: o, contentId: a, tabClasses: l, active: c }, f) => (
                                              K(), we(Ie(o), { key: f, id: a, class: ye(l), active: c }, null, 8, ["id", "class", "active"])
                                          )
                                      ),
                                      128
                                  )),
                                  t.showEmpty
                                      ? (K(),
                                        ue(
                                            "div",
                                            { key: "bv-empty-tab", class: ye(["tab-pane active", { "card-body": t.card }]) },
                                            [ge(t.$slots, "empty")],
                                            2
                                        ))
                                      : Be("", !0),
                              ],
                              2
                          ))
                        : Be("", !0),
                    He(
                        "div",
                        { class: ye([t.navWrapperClass, { "card-header": t.card, "ms-auto": t.vertical && t.end }]) },
                        [
                            He(
                                "ul",
                                { class: ye(["nav", [t.navTabsClasses, t.navClass]]), role: "tablist" },
                                [
                                    ge(t.$slots, "tabs-start"),
                                    (K(!0),
                                    ue(
                                        Nt,
                                        null,
                                        Pn(
                                            t.tabs,
                                            ({ tab: o, buttonId: a, contentId: l, navItemClasses: c, active: f, target: u }, p) => (
                                                K(),
                                                ue(
                                                    "li",
                                                    { key: p, class: ye(["nav-item", o.props["title-item-class"]]) },
                                                    [
                                                        He(
                                                            "a",
                                                            Je(
                                                                {
                                                                    id: a,
                                                                    class: ["nav-link", c],
                                                                    "data-bs-toggle": "tab",
                                                                    "data-bs-target": u,
                                                                    href: "#",
                                                                    role: "tab",
                                                                    "aria-controls": l,
                                                                    "aria-selected": f,
                                                                },
                                                                o.props["title-link-attributes"],
                                                                { onClick: Kc((m) => t.handleClick(m, p), ["stop"]) }
                                                            ),
                                                            [
                                                                o.children && o.children.title
                                                                    ? (K(), we(Ie(o.children.title), { key: 0 }))
                                                                    : (K(), ue(Nt, { key: 1 }, [Ut(tt(o.props.title), 1)], 64)),
                                                            ],
                                                            16,
                                                            m$
                                                        ),
                                                    ],
                                                    2
                                                )
                                            )
                                        ),
                                        128
                                    )),
                                    ge(t.$slots, "tabs-end"),
                                ],
                                2
                            ),
                        ],
                        2
                    ),
                    t.end
                        ? Be("", !0)
                        : (K(),
                          ue(
                              "div",
                              { key: 1, class: ye(["tab-content", t.contentClass]) },
                              [
                                  (K(!0),
                                  ue(
                                      Nt,
                                      null,
                                      Pn(
                                          t.tabs,
                                          ({ tab: o, contentId: a, tabClasses: l, active: c }, f) => (
                                              K(), we(Ie(o), { key: f, id: a, class: ye(l), active: c }, null, 8, ["id", "class", "active"])
                                          )
                                      ),
                                      128
                                  )),
                                  t.showEmpty
                                      ? (K(),
                                        ue(
                                            "div",
                                            { key: "bv-empty-tab", class: ye(["tab-pane active", { "card-body": t.card }]) },
                                            [ge(t.$slots, "empty")],
                                            2
                                        ))
                                      : Be("", !0),
                              ],
                              2
                          )),
                ]),
                _: 3,
            },
            8,
            ["id", "class"]
        )
    )
}
var x$ = xe(g$, [["render", b$]])
const v$ = be({
    name: "BTab",
    props: {
        active: { type: Boolean, default: !1 },
        buttonId: { type: String, default: null },
        disabled: { type: Boolean, default: !1 },
        id: { type: String },
        lazy: { type: Boolean, default: !1 },
        noBody: { type: [Boolean, String], default: !1 },
        tag: { type: String, default: "div" },
        title: { type: String },
        titleItemClass: { type: [Array, Object, String], default: null },
        titleLinkAttributes: { type: Object, default: null },
        titleLinkClass: { type: [Array, Object, String], default: null },
    },
    setup(t) {
        const e = sr(Ty),
            r = H(() => (e == null ? void 0 : e.lazy) || t.lazy),
            n = H(() => t.active && !t.disabled),
            i = H(() => n.value || !r.value)
        return {
            classes: H(() => ({ active: t.active, show: t.active, "card-body": e.card && t.noBody === !1 })),
            computedLazy: r,
            computedActive: n,
            showSlot: i,
        }
    },
})
function y$(t, e, r, n, i, s) {
    return (
        K(),
        we(
            Ie(t.tag),
            { id: t.id, class: ye(["tab-pane", t.classes]), role: "tabpanel", "aria-labelledby": "profile-tab" },
            { default: Te(() => [t.showSlot ? ge(t.$slots, "default", { key: 0 }) : Be("", !0)]), _: 3 },
            8,
            ["id", "class"]
        )
    )
}
var _$ = xe(v$, [["render", y$]])
const w$ = () => ({
        normaliseFields: (e, r) => {
            const n = []
            return !(e == null ? void 0 : e.length) && (r == null ? void 0 : r.length)
                ? (Object.keys(r[0]).forEach((i) => n.push({ key: i, label: hm(i) })), n)
                : (Array.isArray(e) &&
                      e.forEach((i) => {
                          typeof i == "string" ? n.push({ key: i, label: hm(i) }) : bT(i) && i.key && Lo(i.key) && n.push(Me({}, i))
                      }),
                  n)
        },
    }),
    E$ = be({
        name: "BTable",
        props: {
            align: { type: String },
            caption: { type: String },
            captionTop: { type: Boolean, default: !1 },
            borderless: { type: Boolean, default: !1 },
            bordered: { type: Boolean, default: !1 },
            borderVariant: { type: String },
            dark: { type: Boolean, default: !1 },
            fields: { type: Array, default: () => [] },
            footClone: { type: Boolean, default: !1 },
            hover: { type: Boolean, default: !1 },
            items: { type: Array, default: () => [] },
            responsive: { type: [Boolean, String], default: !1 },
            small: { type: Boolean, default: !1 },
            striped: { type: Boolean, default: !1 },
            variant: { type: String },
        },
        setup(t, { slots: e }) {
            const r = H(() => ({
                    [`align-${t.align}`]: t.align,
                    [`table-${t.variant}`]: t.variant,
                    "table-striped": t.striped,
                    "table-hover": t.hover,
                    "table-dark": t.dark,
                    "table-bordered": t.bordered,
                    [`border-${t.borderVariant}`]: t.borderVariant,
                    "table-borderless": t.borderless,
                    "table-sm": t.small,
                    "caption-top": t.captionTop,
                })),
                n = w$(),
                i = H(() => n.normaliseFields(t.fields, t.items))
            return () => {
                let s
                ;(s = null), e["thead-top"] && (s = e["thead-top"]())
                let o
                ;(o = null),
                    e["thead-sub"] &&
                        (o = Ae(
                            "tr",
                            i.value.map((u) =>
                                Ae(
                                    "td",
                                    { scope: "col", class: [u.class, u.thClass, u.variant ? `table-${u.variant}` : ""] },
                                    e["thead-sub"](Me({ items: i.value }, u))
                                )
                            )
                        ))
                const a = Ae("thead", [
                        s,
                        Ae(
                            "tr",
                            i.value.map((u) => {
                                var p
                                const m = `head(${u.key})`
                                let y = u.label
                                return (
                                    e[m] && (y = (p = e[m]) == null ? void 0 : p.call(e, { label: u.label })),
                                    Ae(
                                        "th",
                                        Rt(Me({}, u.thAttr), {
                                            scope: "col",
                                            class: [u.class, u.thClass, u.variant ? `table-${u.variant}` : ""],
                                            title: u.headerTitle,
                                            abbr: u.headerAbbr,
                                            style: u.thStyle,
                                        }),
                                        y
                                    )
                                )
                            })
                        ),
                        o,
                    ]),
                    l = [
                        Ae(
                            "tbody",
                            t.items.map((u, p) =>
                                Ae(
                                    "tr",
                                    { class: [u._rowVariant ? `table-${u._rowVariant}` : null] },
                                    i.value.map((m) => {
                                        var y
                                        const v = `cell(${m.key})`
                                        let _ = u[m.key]
                                        return (
                                            e[v] &&
                                                (_ =
                                                    (y = e[v]) == null
                                                        ? void 0
                                                        : y.call(e, { value: u[m.key], index: p, item: u, items: t.items })),
                                            Ae(
                                                "td",
                                                Rt(Me({}, m.tdAttr), {
                                                    class: [
                                                        m.class,
                                                        m.tdClass,
                                                        m.variant ? `table-${m.variant}` : "",
                                                        (u == null ? void 0 : u._cellVariants) && (u == null ? void 0 : u._cellVariants[m.key])
                                                            ? `table-${u == null ? void 0 : u._cellVariants[m.key]}`
                                                            : "",
                                                    ],
                                                }),
                                                _
                                            )
                                        )
                                    })
                                )
                            )
                        ),
                    ],
                    c = [a, l]
                if (e["table-caption"]) c.push(Ae("caption", e["table-caption"]()))
                else if (t.caption) {
                    const u = Ae("caption", t.caption)
                    c.push(u)
                }
                if (t.footClone) {
                    const u = Ae(
                        "tfoot",
                        Ae(
                            "tr",
                            i.value.map((p) =>
                                Ae(
                                    "th",
                                    Rt(Me({}, p.thAttr), {
                                        scope: "col",
                                        class: [p.class, p.thClass, p.variant ? `table-${p.variant}` : ""],
                                        title: p.headerTitle,
                                        abbr: p.headerAbbr,
                                        style: p.thStyle,
                                    }),
                                    p.label
                                )
                            )
                        )
                    )
                    c.push(u)
                }
                const f = Ae("table", { class: ["table", r.value] }, c)
                return t.responsive
                    ? Ae(
                          "div",
                          {
                              class: {
                                  "table-responsive": typeof t.responsive == "boolean",
                                  [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
                              },
                          },
                          f
                      )
                    : f
            }
        },
    })
function S$(t, e, r, n, i, s) {
    return K(), ue("div")
}
var A$ = xe(E$, [["render", S$]])
const T$ = "toast-title",
    C$ = 5e3,
    k$ = be({
        name: "BToast",
        emits: ["destroyed", "update:modelValue"],
        props: Rt(Me({}, vl), {
            delay: { type: Number, default: 5e3 },
            bodyClass: { type: String },
            body: { type: Object },
            headerClass: { type: String },
            headerTag: { type: String, default: "div" },
            animation: { type: Boolean, default: !0 },
            id: { type: String },
            isStatus: { type: Boolean, default: !1 },
            autoHide: { type: Boolean, default: !0 },
            noCloseButton: { type: Boolean, default: !1 },
            noFade: { type: Boolean, default: !1 },
            noHoverPause: { type: Boolean, default: !1 },
            solid: { type: Boolean, default: !1 },
            static: { type: Boolean, default: !1 },
            title: { type: String },
            modelValue: { type: Boolean, default: !1 },
            toastClass: { type: Array },
            variant: { type: String },
        }),
        setup(t, { emit: e, slots: r }) {
            Ue(), Ue(null)
            const n = Ue(!1),
                i = Ue(!1),
                s = Ue(!1),
                o = H(() => ({ [`b-toast-${t.variant}`]: t.variant, show: s.value || n.value }))
            let a, l
            const c = () => {
                    clearTimeout(a), (a = void 0)
                },
                f = H(() => Math.max(Do(t.delay, 0), C$)),
                u = () => {
                    t.modelValue &&
                        ((l = 0),
                        c(),
                        (i.value = !0),
                        Kl(() => {
                            s.value = !1
                        }))
                },
                p = () => {
                    c(),
                        e("update:modelValue", !0),
                        (l = 0),
                        (i.value = !1),
                        kn(() => {
                            Kl(() => {
                                s.value = !0
                            })
                        })
                }
            It(
                () => t.modelValue,
                (R) => {
                    R ? p() : u()
                }
            )
            const m = () => {
                    c(), t.autoHide && ((a = setTimeout(u, l || f.value)), (l = 0))
                },
                y = () => {
                    ;(n.value = !0), e("update:modelValue", !0)
                },
                v = () => {
                    ;(n.value = !1), m()
                },
                _ = () => {
                    n.value = !0
                },
                C = () => {
                    ;(n.value = !1), (l = 0), e("update:modelValue", !1)
                }
            H(() => ({ OnBeforeEnter: y, OnAfterEnter: v, OnBeforeLeave: _, OnAfterLeave: C })),
                i0(() => {
                    e("destroyed", t.id)
                }),
                Zt(() => {
                    kn(() => {
                        t.modelValue &&
                            Kl(() => {
                                p()
                            })
                    })
                })
            const B = () => {
                kn(() => {
                    Kl(() => {
                        u()
                    })
                })
            }
            return () => {
                const R = () => {
                    const D = [],
                        Y = $r(T$, { hide: u }, r)
                    Y ? D.push(Ae(Y)) : t.title && D.push(Ae("strong", { class: "me-auto" }, t.title)),
                        t.noCloseButton ||
                            D.push(
                                Ae(oy, {
                                    class: ["btn-close"],
                                    onClick: () => {
                                        u()
                                    },
                                })
                            )
                    const J = []
                    if (
                        (D.length > 0 && J.push(Ae(t.headerTag, { class: "toast-header" }, { default: () => D })),
                        $r("default", { hide: u }, r) || t.body)
                    ) {
                        const te = Ae(
                            Id(t) ? "b-link" : "div",
                            { class: ["toast-body", t.bodyClass], onClick: Id(t) ? { click: B } : {} },
                            $r("default", { hide: u }, r) || t.body
                        )
                        J.push(te)
                    }
                    return Ae("div", { class: ["toast", t.toastClass, o.value], tabindex: "0" }, J)
                }
                return Ae(
                    "div",
                    {
                        class: ["b-toast"],
                        id: t.id,
                        role: i.value ? null : t.isStatus ? "status" : "alert",
                        "aria-live": i.value ? null : t.isStatus ? "polite" : "assertive",
                        "aria-atomic": i.value ? null : "true",
                    },
                    [
                        Ae(Bc, { noFade: t.noFade, onAfterEnter: v, onBeforeEnter: y, onAfterLeave: C, onBeforeLeave: _ }, () => [
                            s.value ? R() : "",
                        ]),
                    ]
                )
            }
        },
    })
var N$ = {
        BAccordion: rT,
        BAccordionItem: UT,
        BAlert: KT,
        BAvatar: rC,
        BAvatarGroup: XT,
        BBadge: dC,
        BBreadcrumb: _C,
        BBreadcrumbItem: iy,
        BButton: oh,
        BButtonGroup: TC,
        BButtonToolbar: PC,
        BCard: MC,
        BCardBody: DC,
        BCardFooter: HC,
        BCardGroup: zC,
        BCardHeader: JC,
        BCardImg: ZC,
        BCardSubTitle: tk,
        BCardText: sk,
        BCardTitle: lk,
        BCarousel: Ek,
        BCarouselSlide: Ik,
        BCloseButton: oy,
        BCol: va,
        BCollapse: Hv,
        BContainer: jk,
        BDropdown: Jk,
        BDropdownDivider: Qk,
        BDropdownForm: iN,
        BDropdownGroup: cN,
        BDropdownHeader: hN,
        BDropdownItem: bN,
        BDropdownItemButton: _N,
        BDropdownText: TN,
        BForm: PN,
        BFormCheckbox: RN,
        BFormCheckboxGroup: HN,
        BFormFloatingLabel: GN,
        BFormGroup: fP,
        BFormInput: pP,
        BFormInvalidFeedback: Rd,
        BFormRadio: vP,
        BFormRadioGroup: AP,
        BFormRow: fc,
        BFormSelect: MP,
        BFormSelectOption: ah,
        BFormSelectOptionGroup: vy,
        BFormText: Ld,
        BFormTextarea: FP,
        BFormValidFeedback: Md,
        BImg: jP,
        BInputGroup: QP,
        BInputGroupAddon: ch,
        BInputGroupAppend: oI,
        BInputGroupPrepend: cI,
        BInputGroupText: yy,
        BLink: lC,
        BListGroup: dI,
        BListGroupItem: mI,
        BModal: _I,
        BNav: SI,
        BNavItem: kI,
        BOffcanvas: RI,
        BOverlay: VI,
        BPagination: XI,
        BPopover: r$,
        BProgress: s$,
        BProgressBar: o$,
        BRow: c$,
        BSpinner: h$,
        BTab: _$,
        BTable: A$,
        BToast: k$,
        BToaster: Bd,
        BToastContainer: Bd,
        BTabs: x$,
        BTransition: Bc,
        ToastPlugin: Fk,
    },
    P$ = {
        mounted(t, e) {
            let r = e.value
            Object.keys(e.modifiers).length > 0 && ([r] = Object.keys(e.modifiers)),
                t.setAttribute("data-bs-toggle", "modal"),
                t.setAttribute("data-bs-target", `#${r}`)
        },
    }
const I$ = {
    mounted(t, e) {
        let r = "right"
        const n = []
        e.modifiers.left
            ? (r = "left")
            : e.modifiers.right
            ? (r = "right")
            : e.modifiers.bottom
            ? (r = "bottom")
            : e.modifiers.top && (r = "top"),
            e.modifiers.manual
                ? n.push("manual")
                : (e.modifiers.click && n.push("click"), e.modifiers.hover && n.push("hover"), e.modifiers.focus && n.push("focus")),
            t.setAttribute("data-bs-toggle", "popover"),
            new Ro(t, { trigger: n.length === 0 ? "click" : n.join(" "), placement: r, content: e.value })
    },
    unmounted(t) {
        const e = Ro.getInstance(t)
        e == null || e.dispose()
    },
}
function $$(t) {
    if (t.manual) return "manual"
    const e = []
    return t.click && e.push("click"), t.hover && e.push("hover"), t.focus && e.push("focus"), e.length > 0 ? e.join(" ") : "hover focus"
}
function B$(t) {
    return t.left ? "left" : t.right ? "right" : t.bottom ? "bottom" : "top"
}
function O$(t) {
    return (t == null ? void 0 : t.delay) ? t.delay : 50
}
const M$ = {
        beforeMount(t, e) {
            t.setAttribute("data-bs-toogle", "tooltip")
            const r = /<("[^"]*"|'[^']*'|[^'">])*>/.test(t.title),
                n = $$(e.modifiers),
                i = B$(e.modifiers),
                s = O$(e.value)
            new ti(t, { trigger: n, placement: i, delay: s, html: r })
        },
        updated(t) {
            const e = t.getAttribute("title")
            if (e !== "") {
                const r = ti.getInstance(t)
                r == null || r.hide(), t.setAttribute("data-bs-original-title", e || ""), t.setAttribute("title", "")
            }
        },
        unmounted(t) {
            const e = ti.getInstance(t)
            e == null || e.dispose()
        },
    },
    uc = new Map()
function Cy(t) {
    if (uc.has(t)) {
        const e = uc.get(t)
        e && e.stop && e.stop(), uc.delete(t)
    }
}
function Am(t, e) {
    const r = { margin: "0px", once: !1, callback: e.value }
    Object.keys(e.modifiers).forEach((i) => {
        Number.isInteger(i) ? (r.margin = `${i}px`) : i.toLowerCase() === "once" && (r.once = !0)
    }),
        Cy(t)
    const n = new L$(t, r.margin, r.once, r.callback, e.instance)
    uc.set(t, n)
}
const R$ = {
    beforeMount(t, e) {
        Am(t, e)
    },
    updated(t, e) {
        Am(t, e)
    },
    unmounted(t) {
        Cy(t)
    },
}
class L$ {
    constructor(e, r, n, i, s) {
        ;(this.element = e), (this.margin = r), (this.once = n), (this.callback = i), (this.instance = s), this.createObserver()
    }
    createObserver() {
        if ((this.observer && this.stop(), !(this.doneOnce || typeof this.callback != "function"))) {
            try {
                this.observer = new IntersectionObserver(this.handler.bind(this), { root: null, rootMargin: this.margin, threshold: 0 })
            } catch {
                console.error("Intersection Observer not supported"), (this.doneOnce = !0), (this.observer = void 0), this.callback(null)
                return
            }
            this.instance.$nextTick(() => {
                this.observer && this.observer.observe(this.element)
            })
        }
    }
    handler(e) {
        const [r] = e,
            n = Boolean(r.isIntersecting || r.intersectionRatio > 0)
        n !== this.visible && ((this.visible = n), this.callback(n), this.once && this.visible && ((this.doneOnce = !0), this.stop()))
    }
    stop() {
        this.observer && this.observer.disconnect(), (this.observer = null)
    }
}
var D$ = {
        mounted(t, e) {
            e.value !== !1 && t.focus()
        },
    },
    F$ = { BModal: P$, BPopover: I$, BToggle: Qv, BTooltip: M$, BVisible: R$, focus: D$ }
const XB = {
    install(t, e = {}) {
        Object.entries(N$).forEach(([r, n]) => {
            t.component(r, n)
        }),
            Object.entries(F$).forEach(([r, n]) => {
                t.directive(r, n)
            }),
            hC(t)
    },
}
var ky = {},
    Oc = {},
    Ny = {},
    yl = {},
    _l = {}
const V$ = "@gnosis.pm/safe-apps-sdk",
    U$ = "7.0.0",
    H$ = "SDK developed to integrate third-party apps with Safe app.",
    q$ = "dist/src/index.js",
    j$ = "dist/src/index.d.ts",
    z$ = ["dist/**/*", "README.md"],
    K$ = ["Gnosis", "sdk", "apps"],
    G$ = {
        test: "jest",
        "format-dist": `sed -i 's/"files":/"_files":/' dist/package.json`,
        build: "yarn rimraf dist && tsc && yarn format-dist",
        lint: "tslint -p tsconfig.json",
    },
    W$ = "Gnosis (https://gnosis.io)",
    J$ = "MIT",
    X$ = { "@gnosis.pm/safe-react-gateway-sdk": "^2.8.5", ethers: "^5.4.7" },
    Y$ = { rimraf: "^3.0.2" },
    Z$ = { type: "git", url: "git+https://github.com/gnosis/safe-apps-sdk.git" },
    Q$ = { url: "https://github.com/gnosis/safe-apps-sdk/issues" },
    eB = "https://github.com/gnosis/safe-apps-sdk#readme",
    tB = { access: "public" }
var rB = {
        name: V$,
        version: U$,
        description: H$,
        main: q$,
        typings: j$,
        _files: z$,
        keywords: K$,
        scripts: G$,
        author: W$,
        license: J$,
        dependencies: X$,
        devDependencies: Y$,
        repository: Z$,
        bugs: Q$,
        homepage: eB,
        publishConfig: tB,
    },
    nB =
        (Vt && Vt.__importDefault) ||
        function (t) {
            return t && t.__esModule ? t : { default: t }
        }
Object.defineProperty(_l, "__esModule", { value: !0 })
_l.getSDKVersion = void 0
const iB = nB(rB),
    sB = () => iB.default.version.slice(0, 5)
_l.getSDKVersion = sB
var wf = {}
Object.defineProperty(wf, "__esModule", { value: !0 })
wf.generateRequestId = void 0
const oB = (t) => t.toString(16).padStart(2, "0"),
    aB = (t) => {
        const e = new Uint8Array((t || 40) / 2)
        return window.crypto.getRandomValues(e), Array.from(e, oB).join("")
    },
    lB = () => (typeof window != "undefined" ? aB(10) : new Date().getTime().toString(36))
wf.generateRequestId = lB
Object.defineProperty(yl, "__esModule", { value: !0 })
yl.MessageFormatter = void 0
const cB = _l,
    fB = wf
class Ef {}
yl.MessageFormatter = Ef
Ef.makeRequest = (t, e) => ({ id: (0, fB.generateRequestId)(), method: t, params: e, env: { sdkVersion: (0, cB.getSDKVersion)() } })
Ef.makeResponse = (t, e, r) => ({ id: t, success: !0, version: r, data: e })
Ef.makeErrorResponse = (t, e, r) => ({ id: t, success: !1, error: e, version: r })
var Xo = {}
;(function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.Methods = void 0),
        (function (e) {
            ;(e.sendTransactions = "sendTransactions"),
                (e.rpcCall = "rpcCall"),
                (e.getChainInfo = "getChainInfo"),
                (e.getSafeInfo = "getSafeInfo"),
                (e.getTxBySafeTxHash = "getTxBySafeTxHash"),
                (e.getSafeBalances = "getSafeBalances"),
                (e.signMessage = "signMessage")
        })(t.Methods || (t.Methods = {}))
})(Xo)
;(function (t) {
    var e =
            (Vt && Vt.__createBinding) ||
            (Object.create
                ? function (s, o, a, l) {
                      l === void 0 && (l = a),
                          Object.defineProperty(s, l, {
                              enumerable: !0,
                              get: function () {
                                  return o[a]
                              },
                          })
                  }
                : function (s, o, a, l) {
                      l === void 0 && (l = a), (s[l] = o[a])
                  }),
        r =
            (Vt && Vt.__exportStar) ||
            function (s, o) {
                for (var a in s) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && e(o, s, a)
            }
    Object.defineProperty(t, "__esModule", { value: !0 })
    const n = yl
    class i {
        constructor(o = null, a = !1) {
            ;(this.allowedOrigins = null),
                (this.callbacks = new Map()),
                (this.debugMode = !1),
                (this.isValidMessage = ({ origin: l, data: c, source: f }) => {
                    const u = !c,
                        p = f === window.parent,
                        y = (typeof c.version != "undefined" && parseInt(c.version.split(".")[0])) >= 1
                    let v = !0
                    return Array.isArray(this.allowedOrigins) && (v = this.allowedOrigins.find((_) => _.test(l)) !== void 0), !u && p && y && v
                }),
                (this.logIncomingMessage = (l) => {
                    console.info(`Safe Apps SDK v1: A message was received from origin ${l.origin}. `, l.data)
                }),
                (this.onParentMessage = (l) => {
                    this.isValidMessage(l) && (this.debugMode && this.logIncomingMessage(l), this.handleIncomingMessage(l.data))
                }),
                (this.handleIncomingMessage = (l) => {
                    const { id: c } = l,
                        f = this.callbacks.get(c)
                    f && (f(l), this.callbacks.delete(c))
                }),
                (this.send = (l, c) => {
                    const f = n.MessageFormatter.makeRequest(l, c)
                    if (typeof window == "undefined") throw new Error("Window doesn't exist")
                    return (
                        window.parent.postMessage(f, "*"),
                        new Promise((u, p) => {
                            this.callbacks.set(f.id, (m) => {
                                if (!m.success) {
                                    p(new Error(m.error))
                                    return
                                }
                                u(m)
                            })
                        })
                    )
                }),
                (this.allowedOrigins = o),
                (this.debugMode = a),
                window.addEventListener("message", this.onParentMessage)
        }
    }
    ;(t.default = i), r(Xo, t)
})(Ny)
var Sf = {}
Object.defineProperty(Sf, "__esModule", { value: !0 })
Sf.TXs = void 0
const Bu = Xo
class uB {
    constructor(e) {
        this.communicator = e
    }
    async getBySafeTxHash(e) {
        if (!e) throw new Error("Invalid safeTxHash")
        return (await this.communicator.send(Bu.Methods.getTxBySafeTxHash, { safeTxHash: e })).data
    }
    async signMessage(e) {
        const r = { message: e }
        return (await this.communicator.send(Bu.Methods.signMessage, r)).data
    }
    async send({ txs: e, params: r }) {
        if (!e || !e.length) throw new Error("No transactions were passed")
        const n = { txs: e, params: r }
        return (await this.communicator.send(Bu.Methods.sendTransactions, n)).data
    }
}
Sf.TXs = uB
var Af = {},
    wl = {}
Object.defineProperty(wl, "__esModule", { value: !0 })
wl.RPC_CALLS = void 0
wl.RPC_CALLS = {
    eth_call: "eth_call",
    eth_gasPrice: "eth_gasPrice",
    eth_getLogs: "eth_getLogs",
    eth_getBalance: "eth_getBalance",
    eth_getCode: "eth_getCode",
    eth_getBlockByHash: "eth_getBlockByHash",
    eth_getBlockByNumber: "eth_getBlockByNumber",
    eth_getStorageAt: "eth_getStorageAt",
    eth_getTransactionByHash: "eth_getTransactionByHash",
    eth_getTransactionReceipt: "eth_getTransactionReceipt",
    eth_getTransactionCount: "eth_getTransactionCount",
    eth_estimateGas: "eth_estimateGas",
}
Object.defineProperty(Af, "__esModule", { value: !0 })
Af.Eth = void 0
const Hr = wl,
    dB = Xo,
    Kn = {
        defaultBlockParam: (t = "latest") => t,
        returnFullTxObjectParam: (t = !1) => t,
        blockNumberToHex: (t) => (Number.isInteger(t) ? `0x${t.toString(16)}` : t),
    }
class hB {
    constructor(e) {
        ;(this.communicator = e),
            (this.call = this.buildRequest({ call: Hr.RPC_CALLS.eth_call, formatters: [null, Kn.defaultBlockParam] })),
            (this.getBalance = this.buildRequest({ call: Hr.RPC_CALLS.eth_getBalance, formatters: [null, Kn.defaultBlockParam] })),
            (this.getCode = this.buildRequest({ call: Hr.RPC_CALLS.eth_getCode, formatters: [null, Kn.defaultBlockParam] })),
            (this.getStorageAt = this.buildRequest({
                call: Hr.RPC_CALLS.eth_getStorageAt,
                formatters: [null, Kn.blockNumberToHex, Kn.defaultBlockParam],
            })),
            (this.getPastLogs = this.buildRequest({ call: Hr.RPC_CALLS.eth_getLogs })),
            (this.getBlockByHash = this.buildRequest({ call: Hr.RPC_CALLS.eth_getBlockByHash, formatters: [null, Kn.returnFullTxObjectParam] })),
            (this.getBlockByNumber = this.buildRequest({
                call: Hr.RPC_CALLS.eth_getBlockByNumber,
                formatters: [Kn.blockNumberToHex, Kn.returnFullTxObjectParam],
            })),
            (this.getTransactionByHash = this.buildRequest({ call: Hr.RPC_CALLS.eth_getTransactionByHash })),
            (this.getTransactionReceipt = this.buildRequest({ call: Hr.RPC_CALLS.eth_getTransactionReceipt })),
            (this.getTransactionCount = this.buildRequest({
                call: Hr.RPC_CALLS.eth_getTransactionCount,
                formatters: [null, Kn.defaultBlockParam],
            })),
            (this.getGasPrice = this.buildRequest({ call: Hr.RPC_CALLS.eth_gasPrice })),
            (this.getEstimateGas = (r) => this.buildRequest({ call: Hr.RPC_CALLS.eth_estimateGas })([r]))
    }
    buildRequest(e) {
        const { call: r, formatters: n } = e
        return async (i) => {
            n &&
                Array.isArray(i) &&
                n.forEach((a, l) => {
                    a && (i[l] = a(i[l]))
                })
            const s = { call: r, params: i || [] }
            return (await this.communicator.send(dB.Methods.rpcCall, s)).data
        }
    }
}
Af.Eth = hB
var Tf = {},
    Py = Mw(I8),
    Tn = {}
Object.defineProperty(Tn, "__esModule", { value: !0 })
Tn.MAGIC_VALUE_BYTES = Tn.MAGIC_VALUE = Tn.EIP_1271_BYTES_INTERFACE = Tn.EIP_1271_INTERFACE = void 0
const Iy = Py,
    pB = "0x1626ba7e"
Tn.MAGIC_VALUE = pB
const gB = "0x20c13b0b"
Tn.MAGIC_VALUE_BYTES = gB
const mB = new Iy.ethers.utils.Interface(["function isValidSignature(bytes32 _dataHash, bytes calldata _signature) external view"])
Tn.EIP_1271_INTERFACE = mB
const bB = new Iy.ethers.utils.Interface(["function isValidSignature(bytes calldata _data, bytes calldata _signature) public view"])
Tn.EIP_1271_BYTES_INTERFACE = bB
Object.defineProperty(Tf, "__esModule", { value: !0 })
Tf.Safe = void 0
const Tm = Py,
    Gl = Tn,
    ha = Xo,
    Cm = wl
class xB {
    constructor(e) {
        this.communicator = e
    }
    async getChainInfo() {
        return (await this.communicator.send(ha.Methods.getChainInfo, void 0)).data
    }
    async getInfo() {
        return (await this.communicator.send(ha.Methods.getSafeInfo, void 0)).data
    }
    async experimental_getBalances({ currency: e = "usd" } = {}) {
        return (await this.communicator.send(ha.Methods.getSafeBalances, { currency: e })).data
    }
    async check1271Signature(e, r = "0x") {
        const n = await this.getInfo(),
            i = Gl.EIP_1271_INTERFACE.encodeFunctionData("isValidSignature", [e, r]),
            s = { call: Cm.RPC_CALLS.eth_call, params: [{ to: n.safeAddress, data: i }, "latest"] }
        try {
            return (await this.communicator.send(ha.Methods.rpcCall, s)).data.slice(0, 10).toLowerCase() === Gl.MAGIC_VALUE
        } catch {
            return !1
        }
    }
    async check1271SignatureBytes(e, r = "0x") {
        const n = await this.getInfo(),
            i = Tm.ethers.utils.arrayify(e),
            s = Gl.EIP_1271_BYTES_INTERFACE.encodeFunctionData("isValidSignature", [i, r]),
            o = { call: Cm.RPC_CALLS.eth_call, params: [{ to: n.safeAddress, data: s }, "latest"] }
        try {
            return (await this.communicator.send(ha.Methods.rpcCall, o)).data.slice(0, 10).toLowerCase() === Gl.MAGIC_VALUE_BYTES
        } catch {
            return !1
        }
    }
    calculateMessageHash(e) {
        return Tm.ethers.utils.hashMessage(e)
    }
    async isMessageSigned(e, r = "0x") {
        const n = this.calculateMessageHash(e)
        return await this.isMessageHashSigned(n, r)
    }
    async isMessageHashSigned(e, r = "0x") {
        const n = [this.check1271Signature.bind(this), this.check1271SignatureBytes.bind(this)]
        for (const i of n) if (await i(e, r)) return !0
        return !1
    }
}
Tf.Safe = xB
var vB =
    (Vt && Vt.__importDefault) ||
    function (t) {
        return t && t.__esModule ? t : { default: t }
    }
Object.defineProperty(Oc, "__esModule", { value: !0 })
const yB = vB(Ny),
    _B = Sf,
    wB = Af,
    EB = Tf
class SB {
    constructor(e = {}) {
        const { allowedDomains: r = null, debug: n = !1 } = e
        ;(this.communicator = new yB.default(r, n)),
            (this.eth = new wB.Eth(this.communicator)),
            (this.txs = new _B.TXs(this.communicator)),
            (this.safe = new EB.Safe(this.communicator))
    }
}
Oc.default = SB
var $y = {},
    By = {}
Object.defineProperty(By, "__esModule", { value: !0 })
var Oy = {}
Object.defineProperty(Oy, "__esModule", { value: !0 })
var My = {},
    Ry = { exports: {} }
;(function (t, e) {
    ;(function (r, n) {
        t.exports = n()
    })(Vt, function () {
        return (() => {
            var r = {
                    204: (o, a, l) => {
                        o.exports = self.fetch || (self.fetch = l(869).default || l(869))
                    },
                    869: (o, a, l) => {
                        function c(f, u) {
                            return (
                                (u = u || {}),
                                new Promise(function (p, m) {
                                    var y = new XMLHttpRequest(),
                                        v = [],
                                        _ = [],
                                        C = {},
                                        B = function () {
                                            return {
                                                ok: ((y.status / 100) | 0) == 2,
                                                statusText: y.statusText,
                                                status: y.status,
                                                url: y.responseURL,
                                                text: function () {
                                                    return Promise.resolve(y.responseText)
                                                },
                                                json: function () {
                                                    return Promise.resolve(y.responseText).then(JSON.parse)
                                                },
                                                blob: function () {
                                                    return Promise.resolve(new Blob([y.response]))
                                                },
                                                clone: B,
                                                headers: {
                                                    keys: function () {
                                                        return v
                                                    },
                                                    entries: function () {
                                                        return _
                                                    },
                                                    get: function (U) {
                                                        return C[U.toLowerCase()]
                                                    },
                                                    has: function (U) {
                                                        return U.toLowerCase() in C
                                                    },
                                                },
                                            }
                                        }
                                    for (var R in (y.open(u.method || "get", f, !0),
                                    (y.onload = function () {
                                        y.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function (U, D, Y) {
                                            v.push((D = D.toLowerCase())), _.push([D, Y]), (C[D] = C[D] ? C[D] + "," + Y : Y)
                                        }),
                                            p(B())
                                    }),
                                    (y.onerror = m),
                                    (y.withCredentials = u.credentials == "include"),
                                    u.headers))
                                        y.setRequestHeader(R, u.headers[R])
                                    y.send(u.body || null)
                                })
                            )
                        }
                        l.r(a), l.d(a, { default: () => c })
                    },
                },
                n = {}
            function i(o) {
                var a = n[o]
                if (a !== void 0) return a.exports
                var l = (n[o] = { exports: {} })
                return r[o](l, l.exports, i), l.exports
            }
            ;(i.n = (o) => {
                var a = o && o.__esModule ? () => o.default : () => o
                return i.d(a, { a }), a
            }),
                (i.d = (o, a) => {
                    for (var l in a) i.o(a, l) && !i.o(o, l) && Object.defineProperty(o, l, { enumerable: !0, get: a[l] })
                }),
                (i.o = (o, a) => Object.prototype.hasOwnProperty.call(o, a)),
                (i.r = (o) => {
                    typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }),
                        Object.defineProperty(o, "__esModule", { value: !0 })
                })
            var s = {}
            return (
                (() => {
                    i.r(s),
                        i.d(s, {
                            FEATURES: () => m,
                            GAS_PRICE_TYPE: () => p,
                            Operation: () => a,
                            RPC_AUTHENTICATION: () => u,
                            SafeAppAccessPolicyTypes: () => o,
                            TokenType: () => f,
                            TransactionStatus: () => l,
                            TransferDirection: () => c,
                            getBalances: () => R,
                            getChainConfig: () => b,
                            getChainsConfig: () => d,
                            getCollectibles: () => Y,
                            getDecodedData: () => T,
                            getFiatCurrencies: () => U,
                            getMasterCopies: () => E,
                            getOwnedSafes: () => D,
                            getSafeApps: () => w,
                            getSafeInfo: () => B,
                            getTransactionDetails: () => G,
                            getTransactionHistory: () => J,
                            getTransactionQueue: () => te,
                            postSafeGasEstimation: () => de,
                            proposeTransaction: () => k,
                        })
                    var o,
                        a,
                        l,
                        c,
                        f,
                        u,
                        p,
                        m,
                        y = i(204),
                        v = i.n(y)
                    function _(A, $) {
                        return (
                            (S = this),
                            (g = void 0),
                            (O = function () {
                                var j, L, h, P, M
                                return (function (V, z) {
                                    var ee,
                                        ne,
                                        W,
                                        N,
                                        I = {
                                            label: 0,
                                            sent: function () {
                                                if (1 & W[0]) throw W[1]
                                                return W[1]
                                            },
                                            trys: [],
                                            ops: [],
                                        }
                                    return (
                                        (N = { next: q(0), throw: q(1), return: q(2) }),
                                        typeof Symbol == "function" &&
                                            (N[Symbol.iterator] = function () {
                                                return this
                                            }),
                                        N
                                    )
                                    function q(Q) {
                                        return function (ie) {
                                            return (function (Z) {
                                                if (ee) throw new TypeError("Generator is already executing.")
                                                for (; I; )
                                                    try {
                                                        if (
                                                            ((ee = 1),
                                                            ne &&
                                                                (W =
                                                                    2 & Z[0]
                                                                        ? ne.return
                                                                        : Z[0]
                                                                        ? ne.throw || ((W = ne.return) && W.call(ne), 0)
                                                                        : ne.next) &&
                                                                !(W = W.call(ne, Z[1])).done)
                                                        )
                                                            return W
                                                        switch (((ne = 0), W && (Z = [2 & Z[0], W.value]), Z[0])) {
                                                            case 0:
                                                            case 1:
                                                                W = Z
                                                                break
                                                            case 4:
                                                                return I.label++, { value: Z[1], done: !1 }
                                                            case 5:
                                                                I.label++, (ne = Z[1]), (Z = [0])
                                                                continue
                                                            case 7:
                                                                ;(Z = I.ops.pop()), I.trys.pop()
                                                                continue
                                                            default:
                                                                if (
                                                                    !(
                                                                        (W = (W = I.trys).length > 0 && W[W.length - 1]) ||
                                                                        (Z[0] !== 6 && Z[0] !== 2)
                                                                    )
                                                                ) {
                                                                    I = 0
                                                                    continue
                                                                }
                                                                if (Z[0] === 3 && (!W || (Z[1] > W[0] && Z[1] < W[3]))) {
                                                                    I.label = Z[1]
                                                                    break
                                                                }
                                                                if (Z[0] === 6 && I.label < W[1]) {
                                                                    ;(I.label = W[1]), (W = Z)
                                                                    break
                                                                }
                                                                if (W && I.label < W[2]) {
                                                                    ;(I.label = W[2]), I.ops.push(Z)
                                                                    break
                                                                }
                                                                W[2] && I.ops.pop(), I.trys.pop()
                                                                continue
                                                        }
                                                        Z = z.call(V, I)
                                                    } catch (oe) {
                                                        ;(Z = [6, oe]), (ne = 0)
                                                    } finally {
                                                        ee = W = 0
                                                    }
                                                if (5 & Z[0]) throw Z[1]
                                                return { value: Z[0] ? Z[1] : void 0, done: !0 }
                                            })([Q, ie])
                                        }
                                    }
                                })(this, function (V) {
                                    switch (V.label) {
                                        case 0:
                                            return (
                                                $ != null &&
                                                    (j = {
                                                        method: "POST",
                                                        body: typeof $ == "string" ? $ : JSON.stringify($),
                                                        headers: { "Content-Type": "application/json" },
                                                    }),
                                                [4, v()(A, j)]
                                            )
                                        case 1:
                                            return [4, (L = V.sent()).json()]
                                        case 2:
                                            if (((h = V.sent()), !L.ok)) {
                                                P = ""
                                                try {
                                                    P = (M = h).code + ": " + M.message
                                                } catch {
                                                    P = L.statusText
                                                }
                                                throw new Error(P)
                                            }
                                            return [2, h]
                                    }
                                })
                            }),
                            new ((x = void 0) || (x = Promise))(function (j, L) {
                                function h(V) {
                                    try {
                                        M(O.next(V))
                                    } catch (z) {
                                        L(z)
                                    }
                                }
                                function P(V) {
                                    try {
                                        M(O.throw(V))
                                    } catch (z) {
                                        L(z)
                                    }
                                }
                                function M(V) {
                                    var z
                                    V.done
                                        ? j(V.value)
                                        : ((z = V.value),
                                          z instanceof x
                                              ? z
                                              : new x(function (ee) {
                                                    ee(z)
                                                })).then(h, P)
                                }
                                M((O = O.apply(S, g || [])).next())
                            })
                        )
                        var S, g, x, O
                    }
                    function C(A, $, S, g) {
                        if (g) return _(g)
                        var x = S
                        return _(
                            "" +
                                A +
                                (function (O, j) {
                                    return j
                                        ? Object.keys(j).reduce(function (L, h) {
                                              return (function (P, M, V) {
                                                  return P.replace(new RegExp("\\{" + M + "\\}", "g"), V)
                                              })(L, h, String(j[h]))
                                          }, O)
                                        : O
                                })($, x == null ? void 0 : x.path) +
                                (function (O) {
                                    if (!O) return ""
                                    var j = new URLSearchParams()
                                    Object.keys(O).forEach(function (h) {
                                        O[h] != null && j.append(h, String(O[h]))
                                    })
                                    var L = j.toString()
                                    return L ? "?" + L : ""
                                })(x == null ? void 0 : x.query),
                            x == null ? void 0 : x.body
                        )
                    }
                    function B(A, $, S) {
                        return C(A, "/v1/chains/{chainId}/safes/{address}", { path: { chainId: $, address: S } })
                    }
                    function R(A, $, S, g, x) {
                        return (
                            g === void 0 && (g = "usd"),
                            x === void 0 && (x = {}),
                            C(A, "/v1/chains/{chainId}/safes/{address}/balances/{currency}", {
                                path: { chainId: $, address: S, currency: g },
                                query: x,
                            })
                        )
                    }
                    function U(A) {
                        return C(A, "/v1/balances/supported-fiat-codes")
                    }
                    function D(A, $, S) {
                        return C(A, "/v1/chains/{chainId}/owners/{address}/safes", { path: { chainId: $, address: S } })
                    }
                    function Y(A, $, S, g) {
                        return (
                            g === void 0 && (g = {}),
                            C(A, "/v1/chains/{chainId}/safes/{address}/collectibles", { path: { chainId: $, address: S }, query: g })
                        )
                    }
                    function J(A, $, S, g) {
                        return C(
                            A,
                            "/v1/chains/{chainId}/safes/{safe_address}/transactions/history",
                            { path: { chainId: $, safe_address: S }, query: {} },
                            g
                        )
                    }
                    function te(A, $, S, g) {
                        return C(
                            A,
                            "/v1/chains/{chainId}/safes/{safe_address}/transactions/queued",
                            { path: { chainId: $, safe_address: S }, query: {} },
                            g
                        )
                    }
                    function G(A, $, S) {
                        return C(A, "/v1/chains/{chainId}/transactions/{transactionId}", { path: { chainId: $, transactionId: S } })
                    }
                    function de(A, $, S, g) {
                        return C(A, "/v2/chains/{chainId}/safes/{safe_address}/multisig-transactions/estimations", {
                            path: { chainId: $, safe_address: S },
                            body: g,
                        })
                    }
                    function k(A, $, S, g) {
                        return C(A, "/v1/chains/{chainId}/transactions/{safe_address}/propose", {
                            path: { chainId: $, safe_address: S },
                            body: g,
                        })
                    }
                    function d(A, $) {
                        return C(A, "/v1/chains", { query: $ })
                    }
                    function b(A, $) {
                        return C(A, "/v1/chains/{chainId}", { path: { chainId: $ } })
                    }
                    function w(A, $, S) {
                        return S === void 0 && (S = {}), C(A, "/v1/chains/{chainId}/safe-apps", { path: { chainId: $ }, query: S })
                    }
                    function E(A, $) {
                        return C(A, "/v1/chains/{chainId}/about/master-copies", { path: { chainId: $ } })
                    }
                    function T(A, $, S) {
                        return C(A, "/v1/chains/{chainId}/data-decoder", { path: { chainId: $ }, body: { data: S } })
                    }
                    ;(function (A) {
                        ;(A.NoRestrictions = "NO_RESTRICTIONS"), (A.DomainAllowlist = "DOMAIN_ALLOWLIST")
                    })(o || (o = {})),
                        (function (A) {
                            ;(A[(A.CALL = 0)] = "CALL"), (A[(A.DELEGATE = 1)] = "DELEGATE")
                        })(a || (a = {})),
                        (function (A) {
                            ;(A.AWAITING_CONFIRMATIONS = "AWAITING_CONFIRMATIONS"),
                                (A.AWAITING_EXECUTION = "AWAITING_EXECUTION"),
                                (A.CANCELLED = "CANCELLED"),
                                (A.FAILED = "FAILED"),
                                (A.SUCCESS = "SUCCESS"),
                                (A.PENDING = "PENDING"),
                                (A.WILL_BE_REPLACED = "WILL_BE_REPLACED")
                        })(l || (l = {})),
                        (function (A) {
                            ;(A.INCOMING = "INCOMING"), (A.OUTGOING = "OUTGOING"), (A.UNKNOWN = "UNKNOWN")
                        })(c || (c = {})),
                        (function (A) {
                            ;(A.ERC20 = "ERC20"), (A.ERC721 = "ERC721"), (A.NATIVE_COIN = "NATIVE_COIN")
                        })(f || (f = {})),
                        (function (A) {
                            ;(A.API_KEY_PATH = "API_KEY_PATH"), (A.NO_AUTHENTICATION = "NO_AUTHENTICATION"), (A.UNKNOWN = "UNKNOWN")
                        })(u || (u = {})),
                        (function (A) {
                            ;(A.ORACLE = "ORACLE"), (A.FIXED = "FIXED"), (A.UNKNOWN = "UNKNOWN")
                        })(p || (p = {})),
                        (function (A) {
                            ;(A.ERC721 = "ERC721"),
                                (A.SAFE_APPS = "SAFE_APPS"),
                                (A.CONTRACT_INTERACTION = "CONTRACT_INTERACTION"),
                                (A.DOMAIN_LOOKUP = "DOMAIN_LOOKUP"),
                                (A.SPENDING_LIMIT = "SPENDING_LIMIT"),
                                (A.EIP1559 = "EIP1559"),
                                (A.SAFE_TX_GAS_OPTIONAL = "SAFE_TX_GAS_OPTIONAL")
                        })(m || (m = {}))
                })(),
                s
            )
        })()
    })
})(Ry)
;(function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), (t.TransferDirection = t.TransactionStatus = t.TokenType = t.Operation = void 0)
    var e = Ry.exports
    Object.defineProperty(t, "Operation", {
        enumerable: !0,
        get: function () {
            return e.Operation
        },
    }),
        Object.defineProperty(t, "TokenType", {
            enumerable: !0,
            get: function () {
                return e.TokenType
            },
        }),
        Object.defineProperty(t, "TransactionStatus", {
            enumerable: !0,
            get: function () {
                return e.TransactionStatus
            },
        }),
        Object.defineProperty(t, "TransferDirection", {
            enumerable: !0,
            get: function () {
                return e.TransferDirection
            },
        })
})(My)
var Ly = {}
Object.defineProperty(Ly, "__esModule", { value: !0 })
;(function (t) {
    var e =
            (Vt && Vt.__createBinding) ||
            (Object.create
                ? function (n, i, s, o) {
                      o === void 0 && (o = s),
                          Object.defineProperty(n, o, {
                              enumerable: !0,
                              get: function () {
                                  return i[s]
                              },
                          })
                  }
                : function (n, i, s, o) {
                      o === void 0 && (o = s), (n[o] = i[s])
                  }),
        r =
            (Vt && Vt.__exportStar) ||
            function (n, i) {
                for (var s in n) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, n, s)
            }
    Object.defineProperty(t, "__esModule", { value: !0 }), r(By, t), r(Oy, t), r(My, t), r(Ly, t)
})($y)
;(function (t) {
    var e =
            (Vt && Vt.__createBinding) ||
            (Object.create
                ? function (o, a, l, c) {
                      c === void 0 && (c = l),
                          Object.defineProperty(o, c, {
                              enumerable: !0,
                              get: function () {
                                  return a[l]
                              },
                          })
                  }
                : function (o, a, l, c) {
                      c === void 0 && (c = l), (o[c] = a[l])
                  }),
        r =
            (Vt && Vt.__exportStar) ||
            function (o, a) {
                for (var l in o) l !== "default" && !Object.prototype.hasOwnProperty.call(a, l) && e(a, o, l)
            },
        n =
            (Vt && Vt.__importDefault) ||
            function (o) {
                return o && o.__esModule ? o : { default: o }
            }
    Object.defineProperty(t, "__esModule", { value: !0 }), (t.getSDKVersion = void 0)
    const i = n(Oc)
    ;(t.default = i.default), r(Oc, t), r($y, t), r(Xo, t), r(yl, t)
    var s = _l
    Object.defineProperty(t, "getSDKVersion", {
        enumerable: !0,
        get: function () {
            return s.getSDKVersion
        },
    })
})(ky)
var YB = Ow(ky),
    AB = {},
    Cf = {},
    fh = { exports: {} },
    wo = typeof Reflect == "object" ? Reflect : null,
    km =
        wo && typeof wo.apply == "function"
            ? wo.apply
            : function (e, r, n) {
                  return Function.prototype.apply.call(e, r, n)
              },
    dc
wo && typeof wo.ownKeys == "function"
    ? (dc = wo.ownKeys)
    : Object.getOwnPropertySymbols
    ? (dc = function (e) {
          return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
      })
    : (dc = function (e) {
          return Object.getOwnPropertyNames(e)
      })
function TB(t) {
    console && console.warn && console.warn(t)
}
var Dy =
    Number.isNaN ||
    function (e) {
        return e !== e
    }
function ot() {
    ot.init.call(this)
}
fh.exports = ot
fh.exports.once = PB
ot.EventEmitter = ot
ot.prototype._events = void 0
ot.prototype._eventsCount = 0
ot.prototype._maxListeners = void 0
var Nm = 10
function kf(t) {
    if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
}
Object.defineProperty(ot, "defaultMaxListeners", {
    enumerable: !0,
    get: function () {
        return Nm
    },
    set: function (t) {
        if (typeof t != "number" || t < 0 || Dy(t))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".")
        Nm = t
    },
})
ot.init = function () {
    ;(this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) &&
        ((this._events = Object.create(null)), (this._eventsCount = 0)),
        (this._maxListeners = this._maxListeners || void 0)
}
ot.prototype.setMaxListeners = function (e) {
    if (typeof e != "number" || e < 0 || Dy(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".")
    return (this._maxListeners = e), this
}
function Fy(t) {
    return t._maxListeners === void 0 ? ot.defaultMaxListeners : t._maxListeners
}
ot.prototype.getMaxListeners = function () {
    return Fy(this)
}
ot.prototype.emit = function (e) {
    for (var r = [], n = 1; n < arguments.length; n++) r.push(arguments[n])
    var i = e === "error",
        s = this._events
    if (s !== void 0) i = i && s.error === void 0
    else if (!i) return !1
    if (i) {
        var o
        if ((r.length > 0 && (o = r[0]), o instanceof Error)) throw o
        var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""))
        throw ((a.context = o), a)
    }
    var l = s[e]
    if (l === void 0) return !1
    if (typeof l == "function") km(l, this, r)
    else for (var c = l.length, f = jy(l, c), n = 0; n < c; ++n) km(f[n], this, r)
    return !0
}
function Vy(t, e, r, n) {
    var i, s, o
    if (
        (kf(r),
        (s = t._events),
        s === void 0
            ? ((s = t._events = Object.create(null)), (t._eventsCount = 0))
            : (s.newListener !== void 0 && (t.emit("newListener", e, r.listener ? r.listener : r), (s = t._events)), (o = s[e])),
        o === void 0)
    )
        (o = s[e] = r), ++t._eventsCount
    else if (
        (typeof o == "function" ? (o = s[e] = n ? [r, o] : [o, r]) : n ? o.unshift(r) : o.push(r),
        (i = Fy(t)),
        i > 0 && o.length > i && !o.warned)
    ) {
        o.warned = !0
        var a = new Error(
            "Possible EventEmitter memory leak detected. " +
                o.length +
                " " +
                String(e) +
                " listeners added. Use emitter.setMaxListeners() to increase limit"
        )
        ;(a.name = "MaxListenersExceededWarning"), (a.emitter = t), (a.type = e), (a.count = o.length), TB(a)
    }
    return t
}
ot.prototype.addListener = function (e, r) {
    return Vy(this, e, r, !1)
}
ot.prototype.on = ot.prototype.addListener
ot.prototype.prependListener = function (e, r) {
    return Vy(this, e, r, !0)
}
function CB() {
    if (!this.fired)
        return (
            this.target.removeListener(this.type, this.wrapFn),
            (this.fired = !0),
            arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
        )
}
function Uy(t, e, r) {
    var n = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r },
        i = CB.bind(n)
    return (i.listener = r), (n.wrapFn = i), i
}
ot.prototype.once = function (e, r) {
    return kf(r), this.on(e, Uy(this, e, r)), this
}
ot.prototype.prependOnceListener = function (e, r) {
    return kf(r), this.prependListener(e, Uy(this, e, r)), this
}
ot.prototype.removeListener = function (e, r) {
    var n, i, s, o, a
    if ((kf(r), (i = this._events), i === void 0)) return this
    if (((n = i[e]), n === void 0)) return this
    if (n === r || n.listener === r)
        --this._eventsCount === 0
            ? (this._events = Object.create(null))
            : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r))
    else if (typeof n != "function") {
        for (s = -1, o = n.length - 1; o >= 0; o--)
            if (n[o] === r || n[o].listener === r) {
                ;(a = n[o].listener), (s = o)
                break
            }
        if (s < 0) return this
        s === 0 ? n.shift() : kB(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || r)
    }
    return this
}
ot.prototype.off = ot.prototype.removeListener
ot.prototype.removeAllListeners = function (e) {
    var r, n, i
    if (((n = this._events), n === void 0)) return this
    if (n.removeListener === void 0)
        return (
            arguments.length === 0
                ? ((this._events = Object.create(null)), (this._eventsCount = 0))
                : n[e] !== void 0 && (--this._eventsCount === 0 ? (this._events = Object.create(null)) : delete n[e]),
            this
        )
    if (arguments.length === 0) {
        var s = Object.keys(n),
            o
        for (i = 0; i < s.length; ++i) (o = s[i]), o !== "removeListener" && this.removeAllListeners(o)
        return this.removeAllListeners("removeListener"), (this._events = Object.create(null)), (this._eventsCount = 0), this
    }
    if (((r = n[e]), typeof r == "function")) this.removeListener(e, r)
    else if (r !== void 0) for (i = r.length - 1; i >= 0; i--) this.removeListener(e, r[i])
    return this
}
function Hy(t, e, r) {
    var n = t._events
    if (n === void 0) return []
    var i = n[e]
    return i === void 0 ? [] : typeof i == "function" ? (r ? [i.listener || i] : [i]) : r ? NB(i) : jy(i, i.length)
}
ot.prototype.listeners = function (e) {
    return Hy(this, e, !0)
}
ot.prototype.rawListeners = function (e) {
    return Hy(this, e, !1)
}
ot.listenerCount = function (t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : qy.call(t, e)
}
ot.prototype.listenerCount = qy
function qy(t) {
    var e = this._events
    if (e !== void 0) {
        var r = e[t]
        if (typeof r == "function") return 1
        if (r !== void 0) return r.length
    }
    return 0
}
ot.prototype.eventNames = function () {
    return this._eventsCount > 0 ? dc(this._events) : []
}
function jy(t, e) {
    for (var r = new Array(e), n = 0; n < e; ++n) r[n] = t[n]
    return r
}
function kB(t, e) {
    for (; e + 1 < t.length; e++) t[e] = t[e + 1]
    t.pop()
}
function NB(t) {
    for (var e = new Array(t.length), r = 0; r < e.length; ++r) e[r] = t[r].listener || t[r]
    return e
}
function PB(t, e) {
    return new Promise(function (r, n) {
        function i(o) {
            t.removeListener(e, s), n(o)
        }
        function s() {
            typeof t.removeListener == "function" && t.removeListener("error", i), r([].slice.call(arguments))
        }
        zy(t, e, s, { once: !0 }), e !== "error" && IB(t, i, { once: !0 })
    })
}
function IB(t, e, r) {
    typeof t.on == "function" && zy(t, "error", e, r)
}
function zy(t, e, r, n) {
    if (typeof t.on == "function") n.once ? t.once(e, r) : t.on(e, r)
    else if (typeof t.addEventListener == "function")
        t.addEventListener(e, function i(s) {
            n.once && t.removeEventListener(e, i), r(s)
        })
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t)
}
var Nf = {}
Object.defineProperty(Nf, "__esModule", { value: !0 })
Nf.getLowerCase = void 0
function $B(t) {
    return t && t.toLowerCase()
}
Nf.getLowerCase = $B
Object.defineProperty(Cf, "__esModule", { value: !0 })
Cf.SafeAppProvider = void 0
const BB = fh.exports,
    Wl = Nf
class OB extends BB.EventEmitter {
    constructor(e, r) {
        super()
        ;(this.submittedTxs = new Map()), (this.safe = e), (this.sdk = r)
    }
    async connect() {
        this.emit("connect", { chainId: this.chainId })
    }
    async disconnect() {}
    get chainId() {
        return this.safe.chainId
    }
    async request(e) {
        const { method: r, params: n = [] } = e
        switch (r) {
            case "eth_accounts":
                return [this.safe.safeAddress]
            case "net_version":
            case "eth_chainId":
                return `0x${this.chainId.toString(16)}`
            case "personal_sign": {
                const [l, c] = n
                if (this.safe.safeAddress.toLowerCase() !== c.toLowerCase()) throw new Error("The address or message hash is invalid")
                return await this.sdk.txs.signMessage(l), "0x"
            }
            case "eth_sign": {
                const [l, c] = n
                if (this.safe.safeAddress.toLowerCase() !== l.toLowerCase() || !c.startsWith("0x"))
                    throw new Error("The address or message hash is invalid")
                return await this.sdk.txs.signMessage(c), "0x"
            }
            case "eth_sendTransaction":
                const i = Object.assign({ value: "0", data: "0x" }, n[0]),
                    s = await this.sdk.txs.send({ txs: [i] })
                return (
                    this.submittedTxs.set(s.safeTxHash, {
                        from: this.safe.safeAddress,
                        hash: s.safeTxHash,
                        gas: 0,
                        gasPrice: "0x00",
                        nonce: 0,
                        input: i.data,
                        value: i.value,
                        to: i.to,
                        blockHash: null,
                        blockNumber: null,
                        transactionIndex: null,
                    }),
                    s.safeTxHash
                )
            case "eth_blockNumber":
                return (await this.sdk.eth.getBlockByNumber(["latest"])).number
            case "eth_getBalance":
                return this.sdk.eth.getBalance([(0, Wl.getLowerCase)(n[0]), n[1]])
            case "eth_getCode":
                return this.sdk.eth.getCode([(0, Wl.getLowerCase)(n[0]), n[1]])
            case "eth_getTransactionCount":
                return this.sdk.eth.getTransactionCount([(0, Wl.getLowerCase)(n[0]), n[1]])
            case "eth_getStorageAt":
                return this.sdk.eth.getStorageAt([(0, Wl.getLowerCase)(n[0]), n[1], n[2]])
            case "eth_getBlockByNumber":
                return this.sdk.eth.getBlockByNumber([n[0], n[1]])
            case "eth_getBlockByHash":
                return this.sdk.eth.getBlockByHash([n[0], n[1]])
            case "eth_getTransactionByHash":
                let a = n[0]
                try {
                    a = (await this.sdk.txs.getBySafeTxHash(a)).txHash || a
                } catch {}
                return this.submittedTxs.has(a)
                    ? this.submittedTxs.get(a)
                    : this.sdk.eth.getTransactionByHash([a]).then((l) => (l && (l.hash = n[0]), l))
            case "eth_getTransactionReceipt": {
                let l = n[0]
                try {
                    l = (await this.sdk.txs.getBySafeTxHash(l)).txHash || l
                } catch {}
                return this.sdk.eth.getTransactionReceipt([l]).then((c) => (c && (c.transactionHash = n[0]), c))
            }
            case "eth_estimateGas":
                return this.sdk.eth.getEstimateGas(n[0])
            case "eth_call":
                return this.sdk.eth.call([n[0], n[1]])
            case "eth_getLogs":
                return this.sdk.eth.getPastLogs([n[0]])
            case "eth_gasPrice":
                return this.sdk.eth.getGasPrice()
            default:
                throw Error(`"${e.method}" not implemented`)
        }
    }
    send(e, r) {
        e || r("Undefined request"),
            this.request(e)
                .then((n) => r(null, { jsonrpc: "2.0", id: e.id, result: n }))
                .catch((n) => r(n, null))
    }
}
Cf.SafeAppProvider = OB
;(function (t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), (t.SafeAppProvider = void 0)
    var e = Cf
    Object.defineProperty(t, "SafeAppProvider", {
        enumerable: !0,
        get: function () {
            return e.SafeAppProvider
        },
    })
})(AB)
var Yo = 1e9,
    MB = {
        precision: 20,
        rounding: 4,
        toExpNeg: -7,
        toExpPos: 21,
        LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286",
    }
var Ot = !0,
    Gr = "[DecimalError] ",
    Bs = Gr + "Invalid argument: ",
    uh = Gr + "Exponent out of range: ",
    Zo = Math.floor,
    ws = Math.pow,
    RB = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    Br,
    Jt = 1e7,
    kt = 7,
    Ky = 9007199254740991,
    Mc = Zo(Ky / kt),
    ve = {}
ve.absoluteValue = ve.abs = function () {
    var t = new this.constructor(this)
    return t.s && (t.s = 1), t
}
ve.comparedTo = ve.cmp = function (t) {
    var e,
        r,
        n,
        i,
        s = this
    if (((t = new s.constructor(t)), s.s !== t.s)) return s.s || -t.s
    if (s.e !== t.e) return (s.e > t.e) ^ (s.s < 0) ? 1 : -1
    for (n = s.d.length, i = t.d.length, e = 0, r = n < i ? n : i; e < r; ++e)
        if (s.d[e] !== t.d[e]) return (s.d[e] > t.d[e]) ^ (s.s < 0) ? 1 : -1
    return n === i ? 0 : (n > i) ^ (s.s < 0) ? 1 : -1
}
ve.decimalPlaces = ve.dp = function () {
    var t = this,
        e = t.d.length - 1,
        r = (e - t.e) * kt
    if (((e = t.d[e]), e)) for (; e % 10 == 0; e /= 10) r--
    return r < 0 ? 0 : r
}
ve.dividedBy = ve.div = function (t) {
    return ri(this, new this.constructor(t))
}
ve.dividedToIntegerBy = ve.idiv = function (t) {
    var e = this,
        r = e.constructor
    return ct(ri(e, new r(t), 0, 1), r.precision)
}
ve.equals = ve.eq = function (t) {
    return !this.cmp(t)
}
ve.exponent = function () {
    return Kt(this)
}
ve.greaterThan = ve.gt = function (t) {
    return this.cmp(t) > 0
}
ve.greaterThanOrEqualTo = ve.gte = function (t) {
    return this.cmp(t) >= 0
}
ve.isInteger = ve.isint = function () {
    return this.e > this.d.length - 2
}
ve.isNegative = ve.isneg = function () {
    return this.s < 0
}
ve.isPositive = ve.ispos = function () {
    return this.s > 0
}
ve.isZero = function () {
    return this.s === 0
}
ve.lessThan = ve.lt = function (t) {
    return this.cmp(t) < 0
}
ve.lessThanOrEqualTo = ve.lte = function (t) {
    return this.cmp(t) < 1
}
ve.logarithm = ve.log = function (t) {
    var e,
        r = this,
        n = r.constructor,
        i = n.precision,
        s = i + 5
    if (t === void 0) t = new n(10)
    else if (((t = new n(t)), t.s < 1 || t.eq(Br))) throw Error(Gr + "NaN")
    if (r.s < 1) throw Error(Gr + (r.s ? "NaN" : "-Infinity"))
    return r.eq(Br) ? new n(0) : ((Ot = !1), (e = ri(il(r, s), il(t, s), s)), (Ot = !0), ct(e, i))
}
ve.minus = ve.sub = function (t) {
    var e = this
    return (t = new e.constructor(t)), e.s == t.s ? Jy(e, t) : Gy(e, ((t.s = -t.s), t))
}
ve.modulo = ve.mod = function (t) {
    var e,
        r = this,
        n = r.constructor,
        i = n.precision
    if (((t = new n(t)), !t.s)) throw Error(Gr + "NaN")
    return r.s ? ((Ot = !1), (e = ri(r, t, 0, 1).times(t)), (Ot = !0), r.minus(e)) : ct(new n(r), i)
}
ve.naturalExponential = ve.exp = function () {
    return Wy(this)
}
ve.naturalLogarithm = ve.ln = function () {
    return il(this)
}
ve.negated = ve.neg = function () {
    var t = new this.constructor(this)
    return (t.s = -t.s || 0), t
}
ve.plus = ve.add = function (t) {
    var e = this
    return (t = new e.constructor(t)), e.s == t.s ? Gy(e, t) : Jy(e, ((t.s = -t.s), t))
}
ve.precision = ve.sd = function (t) {
    var e,
        r,
        n,
        i = this
    if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(Bs + t)
    if (((e = Kt(i) + 1), (n = i.d.length - 1), (r = n * kt + 1), (n = i.d[n]), n)) {
        for (; n % 10 == 0; n /= 10) r--
        for (n = i.d[0]; n >= 10; n /= 10) r++
    }
    return t && e > r ? e : r
}
ve.squareRoot = ve.sqrt = function () {
    var t,
        e,
        r,
        n,
        i,
        s,
        o,
        a = this,
        l = a.constructor
    if (a.s < 1) {
        if (!a.s) return new l(0)
        throw Error(Gr + "NaN")
    }
    for (
        t = Kt(a),
            Ot = !1,
            i = Math.sqrt(+a),
            i == 0 || i == 1 / 0
                ? ((e = Cn(a.d)),
                  (e.length + t) % 2 == 0 && (e += "0"),
                  (i = Math.sqrt(e)),
                  (t = Zo((t + 1) / 2) - (t < 0 || t % 2)),
                  i == 1 / 0 ? (e = "5e" + t) : ((e = i.toExponential()), (e = e.slice(0, e.indexOf("e") + 1) + t)),
                  (n = new l(e)))
                : (n = new l(i.toString())),
            r = l.precision,
            i = o = r + 3;
        ;

    )
        if (((s = n), (n = s.plus(ri(a, s, o + 2)).times(0.5)), Cn(s.d).slice(0, o) === (e = Cn(n.d)).slice(0, o))) {
            if (((e = e.slice(o - 3, o + 1)), i == o && e == "4999")) {
                if ((ct(s, r + 1, 0), s.times(s).eq(a))) {
                    n = s
                    break
                }
            } else if (e != "9999") break
            o += 4
        }
    return (Ot = !0), ct(n, r)
}
ve.times = ve.mul = function (t) {
    var e,
        r,
        n,
        i,
        s,
        o,
        a,
        l,
        c,
        f = this,
        u = f.constructor,
        p = f.d,
        m = (t = new u(t)).d
    if (!f.s || !t.s) return new u(0)
    for (
        t.s *= f.s,
            r = f.e + t.e,
            l = p.length,
            c = m.length,
            l < c && ((s = p), (p = m), (m = s), (o = l), (l = c), (c = o)),
            s = [],
            o = l + c,
            n = o;
        n--;

    )
        s.push(0)
    for (n = c; --n >= 0; ) {
        for (e = 0, i = l + n; i > n; ) (a = s[i] + m[n] * p[i - n - 1] + e), (s[i--] = a % Jt | 0), (e = (a / Jt) | 0)
        s[i] = (s[i] + e) % Jt | 0
    }
    for (; !s[--o]; ) s.pop()
    return e ? ++r : s.shift(), (t.d = s), (t.e = r), Ot ? ct(t, u.precision) : t
}
ve.toDecimalPlaces = ve.todp = function (t, e) {
    var r = this,
        n = r.constructor
    return (r = new n(r)), t === void 0 ? r : (qn(t, 0, Yo), e === void 0 ? (e = n.rounding) : qn(e, 0, 8), ct(r, t + Kt(r) + 1, e))
}
ve.toExponential = function (t, e) {
    var r,
        n = this,
        i = n.constructor
    return (
        t === void 0
            ? (r = Vs(n, !0))
            : (qn(t, 0, Yo), e === void 0 ? (e = i.rounding) : qn(e, 0, 8), (n = ct(new i(n), t + 1, e)), (r = Vs(n, !0, t + 1))),
        r
    )
}
ve.toFixed = function (t, e) {
    var r,
        n,
        i = this,
        s = i.constructor
    return t === void 0
        ? Vs(i)
        : (qn(t, 0, Yo),
          e === void 0 ? (e = s.rounding) : qn(e, 0, 8),
          (n = ct(new s(i), t + Kt(i) + 1, e)),
          (r = Vs(n.abs(), !1, t + Kt(n) + 1)),
          i.isneg() && !i.isZero() ? "-" + r : r)
}
ve.toInteger = ve.toint = function () {
    var t = this,
        e = t.constructor
    return ct(new e(t), Kt(t) + 1, e.rounding)
}
ve.toNumber = function () {
    return +this
}
ve.toPower = ve.pow = function (t) {
    var e,
        r,
        n,
        i,
        s,
        o,
        a = this,
        l = a.constructor,
        c = 12,
        f = +(t = new l(t))
    if (!t.s) return new l(Br)
    if (((a = new l(a)), !a.s)) {
        if (t.s < 1) throw Error(Gr + "Infinity")
        return a
    }
    if (a.eq(Br)) return a
    if (((n = l.precision), t.eq(Br))) return ct(a, n)
    if (((e = t.e), (r = t.d.length - 1), (o = e >= r), (s = a.s), o)) {
        if ((r = f < 0 ? -f : f) <= Ky) {
            for (i = new l(Br), e = Math.ceil(n / kt + 4), Ot = !1; r % 2 && ((i = i.times(a)), Im(i.d, e)), (r = Zo(r / 2)), r !== 0; )
                (a = a.times(a)), Im(a.d, e)
            return (Ot = !0), t.s < 0 ? new l(Br).div(i) : ct(i, n)
        }
    } else if (s < 0) throw Error(Gr + "NaN")
    return (
        (s = s < 0 && t.d[Math.max(e, r)] & 1 ? -1 : 1), (a.s = 1), (Ot = !1), (i = t.times(il(a, n + c))), (Ot = !0), (i = Wy(i)), (i.s = s), i
    )
}
ve.toPrecision = function (t, e) {
    var r,
        n,
        i = this,
        s = i.constructor
    return (
        t === void 0
            ? ((r = Kt(i)), (n = Vs(i, r <= s.toExpNeg || r >= s.toExpPos)))
            : (qn(t, 1, Yo),
              e === void 0 ? (e = s.rounding) : qn(e, 0, 8),
              (i = ct(new s(i), t, e)),
              (r = Kt(i)),
              (n = Vs(i, t <= r || r <= s.toExpNeg, t))),
        n
    )
}
ve.toSignificantDigits = ve.tosd = function (t, e) {
    var r = this,
        n = r.constructor
    return (
        t === void 0 ? ((t = n.precision), (e = n.rounding)) : (qn(t, 1, Yo), e === void 0 ? (e = n.rounding) : qn(e, 0, 8)), ct(new n(r), t, e)
    )
}
ve.toString =
    ve.valueOf =
    ve.val =
    ve.toJSON =
    ve[Symbol.for("nodejs.util.inspect.custom")] =
        function () {
            var t = this,
                e = Kt(t),
                r = t.constructor
            return Vs(t, e <= r.toExpNeg || e >= r.toExpPos)
        }
function Gy(t, e) {
    var r,
        n,
        i,
        s,
        o,
        a,
        l,
        c,
        f = t.constructor,
        u = f.precision
    if (!t.s || !e.s) return e.s || (e = new f(t)), Ot ? ct(e, u) : e
    if (((l = t.d), (c = e.d), (o = t.e), (i = e.e), (l = l.slice()), (s = o - i), s)) {
        for (
            s < 0 ? ((n = l), (s = -s), (a = c.length)) : ((n = c), (i = o), (a = l.length)),
                o = Math.ceil(u / kt),
                a = o > a ? o + 1 : a + 1,
                s > a && ((s = a), (n.length = 1)),
                n.reverse();
            s--;

        )
            n.push(0)
        n.reverse()
    }
    for (a = l.length, s = c.length, a - s < 0 && ((s = a), (n = c), (c = l), (l = n)), r = 0; s; )
        (r = ((l[--s] = l[s] + c[s] + r) / Jt) | 0), (l[s] %= Jt)
    for (r && (l.unshift(r), ++i), a = l.length; l[--a] == 0; ) l.pop()
    return (e.d = l), (e.e = i), Ot ? ct(e, u) : e
}
function qn(t, e, r) {
    if (t !== ~~t || t < e || t > r) throw Error(Bs + t)
}
function Cn(t) {
    var e,
        r,
        n,
        i = t.length - 1,
        s = "",
        o = t[0]
    if (i > 0) {
        for (s += o, e = 1; e < i; e++) (n = t[e] + ""), (r = kt - n.length), r && (s += Ii(r)), (s += n)
        ;(o = t[e]), (n = o + ""), (r = kt - n.length), r && (s += Ii(r))
    } else if (o === 0) return "0"
    for (; o % 10 === 0; ) o /= 10
    return s + o
}
var ri = (function () {
    function t(n, i) {
        var s,
            o = 0,
            a = n.length
        for (n = n.slice(); a--; ) (s = n[a] * i + o), (n[a] = s % Jt | 0), (o = (s / Jt) | 0)
        return o && n.unshift(o), n
    }
    function e(n, i, s, o) {
        var a, l
        if (s != o) l = s > o ? 1 : -1
        else
            for (a = l = 0; a < s; a++)
                if (n[a] != i[a]) {
                    l = n[a] > i[a] ? 1 : -1
                    break
                }
        return l
    }
    function r(n, i, s) {
        for (var o = 0; s--; ) (n[s] -= o), (o = n[s] < i[s] ? 1 : 0), (n[s] = o * Jt + n[s] - i[s])
        for (; !n[0] && n.length > 1; ) n.shift()
    }
    return function (n, i, s, o) {
        var a,
            l,
            c,
            f,
            u,
            p,
            m,
            y,
            v,
            _,
            C,
            B,
            R,
            U,
            D,
            Y,
            J,
            te,
            G = n.constructor,
            de = n.s == i.s ? 1 : -1,
            k = n.d,
            d = i.d
        if (!n.s) return new G(n)
        if (!i.s) throw Error(Gr + "Division by zero")
        for (l = n.e - i.e, J = d.length, D = k.length, m = new G(de), y = m.d = [], c = 0; d[c] == (k[c] || 0); ) ++c
        if ((d[c] > (k[c] || 0) && --l, s == null ? (B = s = G.precision) : o ? (B = s + (Kt(n) - Kt(i)) + 1) : (B = s), B < 0)) return new G(0)
        if (((B = (B / kt + 2) | 0), (c = 0), J == 1))
            for (f = 0, d = d[0], B++; (c < D || f) && B--; c++) (R = f * Jt + (k[c] || 0)), (y[c] = (R / d) | 0), (f = R % d | 0)
        else {
            for (
                f = (Jt / (d[0] + 1)) | 0,
                    f > 1 && ((d = t(d, f)), (k = t(k, f)), (J = d.length), (D = k.length)),
                    U = J,
                    v = k.slice(0, J),
                    _ = v.length;
                _ < J;

            )
                v[_++] = 0
            ;(te = d.slice()), te.unshift(0), (Y = d[0]), d[1] >= Jt / 2 && ++Y
            do
                (f = 0),
                    (a = e(d, v, J, _)),
                    a < 0
                        ? ((C = v[0]),
                          J != _ && (C = C * Jt + (v[1] || 0)),
                          (f = (C / Y) | 0),
                          f > 1
                              ? (f >= Jt && (f = Jt - 1),
                                (u = t(d, f)),
                                (p = u.length),
                                (_ = v.length),
                                (a = e(u, v, p, _)),
                                a == 1 && (f--, r(u, J < p ? te : d, p)))
                              : (f == 0 && (a = f = 1), (u = d.slice())),
                          (p = u.length),
                          p < _ && u.unshift(0),
                          r(v, u, _),
                          a == -1 && ((_ = v.length), (a = e(d, v, J, _)), a < 1 && (f++, r(v, J < _ ? te : d, _))),
                          (_ = v.length))
                        : a === 0 && (f++, (v = [0])),
                    (y[c++] = f),
                    a && v[0] ? (v[_++] = k[U] || 0) : ((v = [k[U]]), (_ = 1))
            while ((U++ < D || v[0] !== void 0) && B--)
        }
        return y[0] || y.shift(), (m.e = l), ct(m, o ? s + Kt(m) + 1 : s)
    }
})()
function Wy(t, e) {
    var r,
        n,
        i,
        s,
        o,
        a,
        l = 0,
        c = 0,
        f = t.constructor,
        u = f.precision
    if (Kt(t) > 16) throw Error(uh + Kt(t))
    if (!t.s) return new f(Br)
    for (e == null ? ((Ot = !1), (a = u)) : (a = e), o = new f(0.03125); t.abs().gte(0.1); ) (t = t.times(o)), (c += 5)
    for (n = ((Math.log(ws(2, c)) / Math.LN10) * 2 + 5) | 0, a += n, r = i = s = new f(Br), f.precision = a; ; ) {
        if (((i = ct(i.times(t), a)), (r = r.times(++l)), (o = s.plus(ri(i, r, a))), Cn(o.d).slice(0, a) === Cn(s.d).slice(0, a))) {
            for (; c--; ) s = ct(s.times(s), a)
            return (f.precision = u), e == null ? ((Ot = !0), ct(s, u)) : s
        }
        s = o
    }
}
function Kt(t) {
    for (var e = t.e * kt, r = t.d[0]; r >= 10; r /= 10) e++
    return e
}
function Ou(t, e, r) {
    if (e > t.LN10.sd()) throw ((Ot = !0), r && (t.precision = r), Error(Gr + "LN10 precision limit exceeded"))
    return ct(new t(t.LN10), e)
}
function Ii(t) {
    for (var e = ""; t--; ) e += "0"
    return e
}
function il(t, e) {
    var r,
        n,
        i,
        s,
        o,
        a,
        l,
        c,
        f,
        u = 1,
        p = 10,
        m = t,
        y = m.d,
        v = m.constructor,
        _ = v.precision
    if (m.s < 1) throw Error(Gr + (m.s ? "NaN" : "-Infinity"))
    if (m.eq(Br)) return new v(0)
    if ((e == null ? ((Ot = !1), (c = _)) : (c = e), m.eq(10))) return e == null && (Ot = !0), Ou(v, c)
    if (((c += p), (v.precision = c), (r = Cn(y)), (n = r.charAt(0)), (s = Kt(m)), Math.abs(s) < 15e14)) {
        for (; (n < 7 && n != 1) || (n == 1 && r.charAt(1) > 3); ) (m = m.times(t)), (r = Cn(m.d)), (n = r.charAt(0)), u++
        ;(s = Kt(m)), n > 1 ? ((m = new v("0." + r)), s++) : (m = new v(n + "." + r.slice(1)))
    } else
        return (
            (l = Ou(v, c + 2, _).times(s + "")),
            (m = il(new v(n + "." + r.slice(1)), c - p).plus(l)),
            (v.precision = _),
            e == null ? ((Ot = !0), ct(m, _)) : m
        )
    for (a = o = m = ri(m.minus(Br), m.plus(Br), c), f = ct(m.times(m), c), i = 3; ; ) {
        if (((o = ct(o.times(f), c)), (l = a.plus(ri(o, new v(i), c))), Cn(l.d).slice(0, c) === Cn(a.d).slice(0, c)))
            return (
                (a = a.times(2)),
                s !== 0 && (a = a.plus(Ou(v, c + 2, _).times(s + ""))),
                (a = ri(a, new v(u), c)),
                (v.precision = _),
                e == null ? ((Ot = !0), ct(a, _)) : a
            )
        ;(a = l), (i += 2)
    }
}
function Pm(t, e) {
    var r, n, i
    for (
        (r = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
            (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), (r += +e.slice(n + 1)), (e = e.substring(0, n))) : r < 0 && (r = e.length),
            n = 0;
        e.charCodeAt(n) === 48;

    )
        ++n
    for (i = e.length; e.charCodeAt(i - 1) === 48; ) --i
    if (((e = e.slice(n, i)), e)) {
        if (((i -= n), (r = r - n - 1), (t.e = Zo(r / kt)), (t.d = []), (n = (r + 1) % kt), r < 0 && (n += kt), n < i)) {
            for (n && t.d.push(+e.slice(0, n)), i -= kt; n < i; ) t.d.push(+e.slice(n, (n += kt)))
            ;(e = e.slice(n)), (n = kt - e.length)
        } else n -= i
        for (; n--; ) e += "0"
        if ((t.d.push(+e), Ot && (t.e > Mc || t.e < -Mc))) throw Error(uh + r)
    } else (t.s = 0), (t.e = 0), (t.d = [0])
    return t
}
function ct(t, e, r) {
    var n,
        i,
        s,
        o,
        a,
        l,
        c,
        f,
        u = t.d
    for (o = 1, s = u[0]; s >= 10; s /= 10) o++
    if (((n = e - o), n < 0)) (n += kt), (i = e), (c = u[(f = 0)])
    else {
        if (((f = Math.ceil((n + 1) / kt)), (s = u.length), f >= s)) return t
        for (c = s = u[f], o = 1; s >= 10; s /= 10) o++
        ;(n %= kt), (i = n - kt + o)
    }
    if (
        (r !== void 0 &&
            ((s = ws(10, o - i - 1)),
            (a = (c / s) % 10 | 0),
            (l = e < 0 || u[f + 1] !== void 0 || c % s),
            (l =
                r < 4
                    ? (a || l) && (r == 0 || r == (t.s < 0 ? 3 : 2))
                    : a > 5 ||
                      (a == 5 &&
                          (r == 4 ||
                              l ||
                              (r == 6 && (n > 0 ? (i > 0 ? c / ws(10, o - i) : 0) : u[f - 1]) % 10 & 1) ||
                              r == (t.s < 0 ? 8 : 7))))),
        e < 1 || !u[0])
    )
        return (
            l
                ? ((s = Kt(t)), (u.length = 1), (e = e - s - 1), (u[0] = ws(10, (kt - (e % kt)) % kt)), (t.e = Zo(-e / kt) || 0))
                : ((u.length = 1), (u[0] = t.e = t.s = 0)),
            t
        )
    if (
        (n == 0
            ? ((u.length = f), (s = 1), f--)
            : ((u.length = f + 1), (s = ws(10, kt - n)), (u[f] = i > 0 ? ((c / ws(10, o - i)) % ws(10, i) | 0) * s : 0)),
        l)
    )
        for (;;)
            if (f == 0) {
                ;(u[0] += s) == Jt && ((u[0] = 1), ++t.e)
                break
            } else {
                if (((u[f] += s), u[f] != Jt)) break
                ;(u[f--] = 0), (s = 1)
            }
    for (n = u.length; u[--n] === 0; ) u.pop()
    if (Ot && (t.e > Mc || t.e < -Mc)) throw Error(uh + Kt(t))
    return t
}
function Jy(t, e) {
    var r,
        n,
        i,
        s,
        o,
        a,
        l,
        c,
        f,
        u,
        p = t.constructor,
        m = p.precision
    if (!t.s || !e.s) return e.s ? (e.s = -e.s) : (e = new p(t)), Ot ? ct(e, m) : e
    if (((l = t.d), (u = e.d), (n = e.e), (c = t.e), (l = l.slice()), (o = c - n), o)) {
        for (
            f = o < 0,
                f ? ((r = l), (o = -o), (a = u.length)) : ((r = u), (n = c), (a = l.length)),
                i = Math.max(Math.ceil(m / kt), a) + 2,
                o > i && ((o = i), (r.length = 1)),
                r.reverse(),
                i = o;
            i--;

        )
            r.push(0)
        r.reverse()
    } else {
        for (i = l.length, a = u.length, f = i < a, f && (a = i), i = 0; i < a; i++)
            if (l[i] != u[i]) {
                f = l[i] < u[i]
                break
            }
        o = 0
    }
    for (f && ((r = l), (l = u), (u = r), (e.s = -e.s)), a = l.length, i = u.length - a; i > 0; --i) l[a++] = 0
    for (i = u.length; i > o; ) {
        if (l[--i] < u[i]) {
            for (s = i; s && l[--s] === 0; ) l[s] = Jt - 1
            --l[s], (l[i] += Jt)
        }
        l[i] -= u[i]
    }
    for (; l[--a] === 0; ) l.pop()
    for (; l[0] === 0; l.shift()) --n
    return l[0] ? ((e.d = l), (e.e = n), Ot ? ct(e, m) : e) : new p(0)
}
function Vs(t, e, r) {
    var n,
        i = Kt(t),
        s = Cn(t.d),
        o = s.length
    return (
        e
            ? (r && (n = r - o) > 0 ? (s = s.charAt(0) + "." + s.slice(1) + Ii(n)) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)),
              (s = s + (i < 0 ? "e" : "e+") + i))
            : i < 0
            ? ((s = "0." + Ii(-i - 1) + s), r && (n = r - o) > 0 && (s += Ii(n)))
            : i >= o
            ? ((s += Ii(i + 1 - o)), r && (n = r - i - 1) > 0 && (s = s + "." + Ii(n)))
            : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), (s += Ii(n)))),
        t.s < 0 ? "-" + s : s
    )
}
function Im(t, e) {
    if (t.length > e) return (t.length = e), !0
}
function Xy(t) {
    var e, r, n
    function i(s) {
        var o = this
        if (!(o instanceof i)) return new i(s)
        if (((o.constructor = i), s instanceof i)) {
            ;(o.s = s.s), (o.e = s.e), (o.d = (s = s.d) ? s.slice() : s)
            return
        }
        if (typeof s == "number") {
            if (s * 0 !== 0) throw Error(Bs + s)
            if (s > 0) o.s = 1
            else if (s < 0) (s = -s), (o.s = -1)
            else {
                ;(o.s = 0), (o.e = 0), (o.d = [0])
                return
            }
            if (s === ~~s && s < 1e7) {
                ;(o.e = 0), (o.d = [s])
                return
            }
            return Pm(o, s.toString())
        } else if (typeof s != "string") throw Error(Bs + s)
        if ((s.charCodeAt(0) === 45 ? ((s = s.slice(1)), (o.s = -1)) : (o.s = 1), RB.test(s))) Pm(o, s)
        else throw Error(Bs + s)
    }
    if (
        ((i.prototype = ve),
        (i.ROUND_UP = 0),
        (i.ROUND_DOWN = 1),
        (i.ROUND_CEIL = 2),
        (i.ROUND_FLOOR = 3),
        (i.ROUND_HALF_UP = 4),
        (i.ROUND_HALF_DOWN = 5),
        (i.ROUND_HALF_EVEN = 6),
        (i.ROUND_HALF_CEIL = 7),
        (i.ROUND_HALF_FLOOR = 8),
        (i.clone = Xy),
        (i.config = i.set = LB),
        t === void 0 && (t = {}),
        t)
    )
        for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], e = 0; e < n.length; )
            t.hasOwnProperty((r = n[e++])) || (t[r] = this[r])
    return i.config(t), i
}
function LB(t) {
    if (!t || typeof t != "object") throw Error(Gr + "Object expected")
    var e,
        r,
        n,
        i = ["precision", 1, Yo, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0]
    for (e = 0; e < i.length; e += 3)
        if ((n = t[(r = i[e])]) !== void 0)
            if (Zo(n) === n && n >= i[e + 1] && n <= i[e + 2]) this[r] = n
            else throw Error(Bs + r + ": " + n)
    if ((n = t[(r = "LN10")]) !== void 0)
        if (n == Math.LN10) this[r] = new this(n)
        else throw Error(Bs + r + ": " + n)
    return this
}
var Yy = Xy(MB)
Br = new Yy(1)
var ZB = Yy
export {
    VB as A,
    ce as B,
    ix as C,
    ZB as D,
    ge as E,
    Nt as F,
    zB as G,
    UB as H,
    Za as I,
    Ue as J,
    HB as K,
    jB as L,
    qB as M,
    XB as N,
    FB as S,
    ff as W,
    He as a,
    jt as b,
    ue as c,
    Ut as d,
    Be as e,
    be as f,
    we as g,
    Ie as h,
    sr as i,
    el as j,
    Gb as k,
    pe as l,
    Cx as m,
    YB as n,
    K as o,
    Xm as p,
    AB as q,
    Qt as r,
    H as s,
    tt as t,
    Ln as u,
    nt as v,
    Te as w,
    ya as x,
    Pn as y,
    ye as z,
}
